{"meta":{"title":"CloverYuki","subtitle":null,"description":"论一只菜鸡如何毁掉一个好主题","author":"yuuki","url":""},"pages":[{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2020-02-18T00:38:20.679Z","comments":false,"path":"bangumi/index.html","permalink":"/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2020-04-12T14:58:11.969Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"[白い世界から]] 与&nbsp; Yukina&nbsp; （ 雪(yuki)凪(na)） ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"books","date":"2019-02-10T13:32:48.000Z","updated":"2020-02-18T00:38:20.680Z","comments":false,"path":"books/index.html","permalink":"/books/index.html","excerpt":"","text":""},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2020-02-18T00:38:20.680Z","comments":false,"path":"client/index.html","permalink":"/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2020-02-18T16:54:14.441Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"有啥就说 不要含糊。 不明白为啥改不了","keywords":"留言板"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2020-02-18T00:38:20.682Z","comments":false,"path":"donate/index.html","permalink":"/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2020-02-18T00:38:20.683Z","comments":false,"path":"lab/index.html","permalink":"/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2020-02-18T00:38:20.684Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2020-02-18T00:38:20.685Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2020-02-18T00:38:20.685Z","comments":true,"path":"rss/index.html","permalink":"/rss/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2020-02-18T00:38:20.687Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2020-02-18T00:38:20.686Z","comments":false,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":"","keywords":null},{"title":"","date":"2020-02-18T00:38:20.672Z","updated":"2020-02-18T00:38:20.672Z","comments":true,"path":"404/404.html","permalink":"/404/404.html","excerpt":"","text":"404 html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video { margin: 0; padding: 0; border: 0; vertical-align: baseline; font: inherit; font-size: 100%; } tbody, tfoot, thead, tr, th, td { margin: 0; padding: 0; border: 0; font: inherit; font-size: 100%; } /* HTML5 display-role reset for older browsers */ article, aside, details, figcaption, figure, footer, header, hgroup, menu, nav, section { display: block; } body { line-height: 1; } ol, ul { list-style: none; } q:before, q:after { content: ''; content: none; } body { width: 100%; *zoom: 1; } body:before, body:after { display: table; content: \"\"; } body:after { clear: both; } html, body { height: 100%; } html { height: 100%; max-height: 100%; } body { color: #333333; font-size: 1em; font-family: \"ff-tisa-web-pro-1\", \"ff-tisa-web-pro-2\", \"Lucida Grande\", \"Hiragino Sans GB\", \"Hiragino Sans GB W3\", \"Microsoft YaHei\", \"WenQuanYi Micro Hei\", sans-serif; -webkit-font-smoothing: antialiased; } ::selection { background: rgba(255, 255, 255, 0.3); } ::-moz-selection { background: rgba(255, 255, 255, 0.3); } a { color: #DF9C81; text-decoration: none; } a:hover { color: #d06c44; -webkit-transition: .5s; -moz-transition: .5s; -o-transition: .5s; -ms-transition: .5s; } h1, h2, h3, h4, h5, h5 { margin-top: 1.0em; margin-bottom: .5em; color: #333333; font-weight: lighter; font-family: \"ff-tisa-web-pro-1\", \"ff-tisa-web-pro-2\", \"Lucida Grande\", \"Hiragino Sans GB\", \"Hiragino Sans GB W3\", \"Microsoft YaHei\", \"WenQuanYi Micro Hei\", sans-serif; -webkit-font-smoothing: antialiased; } h1 { margin-top: 0; letter-spacing: .05em; font-size: 1.8em; line-height: 1.2em; } h2 { font-size: 1.6em; } h3 { font-size: 1.4em; } h4 { font-size: 1.2em; } h4 { font-size: 1.1em; } h5 { font-size: 1em; } p { margin-bottom: 1.3em; line-height: 1.7em; } em { font-style: italic; } ol, ul { margin: 0 0 .3em 1em; } ol li, ul li { margin: 0 0 .2em 0; line-height: 1.6em; } ol ol, ol ul, ul ol, ul ul { margin: .1em 0 .2em 2em; } ol { list-style-type: decimal; } ul { list-style-type: disc; } .date, .time, .author, .tags { color: #c7c7c7; font-size: .8em; } .date a, .time a, .author a, .tags a { color: #666666; } .date a:hover, .time a:hover, .author a:hover, .tags a:hover { color: #d06c44; } .footer { position: absolute; bottom: 0; left: 0; width: 100%; color: #b3b3b3; font-size: .7em; } .logo { width: 25%; border: 3px solid #FFF; border-radius: 50%; box-shadow: 0 0 1px 1px rgba(0, 0, 0, 0.3); transition: all .5s; } .logo:hover { border: 3px solid #5ba4e5; transition: all .5s; -webkit-transform: rotate(360deg); /* Safari 和 Chrome */ -moz-transform: rotate(360deg); /* Firefox */ -o-transform: rotate(350deg); /* Opera */ transform: rotate(360deg); -ms-transform: rotate(360deg); /* IE 9 */ } .Weibo_icon_logo { width: 20px; height: 20px; border-radius: 50%; background-position: -50px -25px; box-shadow: 0 0 4px rgba(0, 0, 0, 0.3); vertical-align: -2px; } .Weibo_icon { display: inline-block; background-image: url(../homepage/img/V_icon.png); background-repeat: no-repeat; } .Weibo_icon_position { position: relative; top: -12px; right: 42px; } hr { border: none; } .hidden { display: none !important; } .panel { display: table; width: 100%; height: 100%; } .panel-title { margin: 0 0 15px 0; color: #FFF; letter-spacing: 4px; font-size: 5em; } .panel-subtitle { color: #CCCCCC; letter-spacing: 3px; font-weight: lighter; font-size: 1.2em; font-family: \"ff-tisa-web-pro-1\", \"ff-tisa-web-pro-2\", \"Lucida Grande\", \"Hiragino Sans GB\", \"Hiragino Sans GB W3\", \"Microsoft YaHei\", \"WenQuanYi Micro Hei\", sans-serif; -webkit-font-smoothing: antialiased; } .panel-cover { position: fixed; z-index: 900; display: block; width: 100%; height: 100%; max-width: none; background: url(../images/background-cover.jpg) top left no-repeat #666666; background-size: cover; } .panel-cover--collapsed { width: 30%; max-width: 700px; } .panel-cover--overlay { position: absolute; top: 0; right: 0; bottom: 0; left: 0; z-index: 0; display: block; background-color: rgba(68, 68, 68, 0.6); background-image: -webkit-linear-gradient(-410deg, rgba(68, 68, 68, 0.6) 20%, rgba(0, 0, 0, 0.9)); background-image: linear-gradient(140deg, rgba(68, 68, 68, 0.6) 20%, rgba(0, 0, 0, 0.9)); } .panel-cover__logo { margin: 0px 0px 0px 20px; margin-bottom: .2em; } .panel-cover__description { margin: 0 30px; font-size: 20px; font-weight: bolder; } .panel-cover__divider { margin: 20px auto; width: 50%; border-top: 1px solid rgba(255, 255, 255, 0.14); } .panel-cover__divider--secondary { width: 15%; } .panel-main { display: table; width: 100%; height: 100%; } .panel-main__inner { position: relative; z-index: 800; display: table-cell; padding: 0 60px; vertical-align: middle; } .panel-main__content { margin: 0 auto; max-width: 800px; } .panel-main__content--fixed { width: 480px; -webkit-transition: width 1s; /* Safari */ transition: width 1s; } .panel-inverted { color: #FFF; text-align: center; text-shadow: 0 1px 1px rgba(0, 0, 0, 0.4); font-weight: 100; } .panel-inverted a { color: #FFF; } .cover-navigation { margin-top: 42px; } .cover-navigation--social { margin-left: 30px; } .cover-blue { background-color: rgba(37, 104, 163, 0.6); background-image: -webkit-linear-gradient(-410deg, rgba(37, 104, 163, 0.6) 20%, rgba(18, 51, 80, 0.8)); background-image: linear-gradient(140deg, rgba(37, 104, 163, 0.6) 20%, rgba(18, 51, 80, 0.8)); } .cover-green { background-color: rgba(21, 111, 120, 0.6); background-image: -webkit-linear-gradient(-410deg, rgba(21, 111, 120, 0.6) 20%, rgba(6, 31, 33, 0.8)); background-image: linear-gradient(140deg, rgba(21, 111, 120, 0.6) 20%, rgba(6, 31, 33, 0.8)); } .cover-purple { background-color: rgba(73, 50, 82, 0.6); background-image: -webkit-linear-gradient(-410deg, rgba(73, 50, 82, 0.6) 20%, rgba(17, 11, 19, 0.8)); background-image: linear-gradient(140deg, rgba(73, 50, 82, 0.6) 20%, rgba(17, 11, 19, 0.8)); } .cover-red { background-color: rgba(119, 31, 18, 0.6); background-image: -webkit-linear-gradient(-410deg, rgba(119, 31, 18, 0.6) 20%, rgba(30, 8, 5, 0.8)); background-image: linear-gradient(140deg, rgba(119, 31, 18, 0.6) 20%, rgba(30, 8, 5, 0.8)); } .cover-orange { background-color: rgba(174, 80, 4, 0.6); background-image: -webkit-linear-gradient(-410deg, rgba(174, 80, 4, 0.6) 20%, rgba(74, 34, 2, 0.8)); background-image: linear-gradient(140deg, rgba(174, 80, 4, 0.6) 20%, rgba(74, 34, 2, 0.8)); } .cover-slate { background-color: rgba(0, 0, 0, 0.4); background-image: -webkit-linear-gradient(-410deg, rgba(0, 0, 0, 0.2) 20%, rgba(0, 0, 0, 0.6)); background-image: linear-gradient(140deg, rgba(0, 0, 0, 0.62) 20%, rgba(0, 0, 0, 0.6)); } .cover-disabled { background: none; } .btn, .navigation__item a { padding: 10px 20px; border: 1px solid #DF9C81; border-radius: 20px; color: #DF9C81; text-shadow: none; letter-spacing: 1px; font-weight: bold; font-size: .9em; -webkit-font-smoothing: antialiased; } .btn:hover, .navigation__item a:hover { border-color: #d06c44; color: #d06c44; } .btn-border-small { margin-left: 10px; padding: 6px 8px; border: 1px solid #DF9C81; border-radius: 20px; font-size: .8em; } .btn-contribute { padding: 6px 8px; border: 1px solid #DF9C81; border-radius: 8px; background-color: #DF9C81; color: white; font-weight: bold; font-size: 1.1em; } .btn-secondary { border-color: #5BA4E5; color: #5BA4E5; } .btn-secondary:hover { border-color: #217fd2; color: #217fd2; } .btn-tertiary { border-color: #999999; color: #999999; } .btn-tertiary:hover { border-color: #737373; color: #737373; } .btn-large { padding: 10px 24px; font-size: 1.1em; } .btn-small { padding: 8px 12px; font-size: .7em; } .btn-mobile-menu { position: fixed; top: 0; right: 0; left: 0; z-index: 9999; display: none; width: 100%; height: 35px; border-bottom: 1px solid rgba(255, 255, 255, 0.1); background: rgba(51, 51, 51, 0.98); text-align: center; } .btn-mobile-menu__icon, .btn-mobile-close__icon { position: relative; top: 10px; color: #FFF; } nav { position: relative; display: inline-block; } .navigation { position: relative; float: left; display: inline-block; margin: 0; list-style-type: none; } .navigation__item { display: inline-block; margin: 5px 1px 0 0; line-height: 1em; } .navigation__item a { position: relative; display: block; border-color: #FFF; color: #FFF; opacity: .8; } .navigation__item a:hover { border-color: rgba(255, 255, 255, 0.3); background: rgba(255, 255, 255, 0.3); color: #FFF; opacity: 1; transition: all .3s; } .navigation--social a { padding: 6px 8px 6px 9px; border: 0px; } .navigation--social a .label { display: none; } .navigation--social a .icon { display: block; font-size: 1.7em; } i { font-weight: normal; font-style: normal; font-size: 18px; font-family: 'entypo'; } .social { font-size: 22px; } .icon-social { position: relative; display: block; font-size: 22px; font-family: 'entypo-social'; } *:focus { outline: none; } .wechat[data-v] { position: relative; } .qrCode[data-v] { position: absolute; bottom: 42px; left: -25px; display: none; width: 92px; height: 92px; background-color: #fff; text-align: center; } .wechat .qrCode .triangle-down[data-v] { position: absolute; bottom: -8px; left: 50%; margin-left: -6px; width: 0; height: 0; border-top: 10px solid #fff; border-right: 6px solid transparent; border-left: 6px solid transparent; } .wechat:hover .qrCode[data-v] { display: inline; } @media all and (max-width: 1100px) { .panel-title { font-size: 2em; } .panel-subtitle { font-size: 1em; } .panel-cover__description { margin: 0 10px; font-size: .9em; } .navigation--social { margin-top: 5px; margin-left: 0; } } @media all and (max-width: 960px) { .btn-mobile-menu { display: block; } .qrCode[data-v] { Margin: 0px 41%; } .panel-main { position: relative; display: table; } .panel-cover--collapsed { width: 100%; max-width: none; } .panel-main__inner { display: table-cell; padding: 60px 10%; } .panel-cover__description { display: block; margin: 0 auto; max-width: 600px; } .panel-cover { width: 100%; height: 100%; background-position: center center; } .panel-cover.panel-cover--collapsed { position: relative; display: block; padding: 0; height: auto; background-position: center center; } .panel-cover.panel-cover--collapsed .panel-main__inner { display: block; padding: 70px 0 30px 0; } .panel-cover.panel-cover--collapsed .panel-cover__logo { width: 60px; border-width: 2px; } .panel-cover.panel-cover--collapsed .panel-cover__description { display: none; } .panel-cover.panel-cover--collapsed .panel-cover__divider { display: none; margin: 1em auto; } .navigation-wrapper { position: fixed; top: 0; right: 0; left: 0; display: none; padding: 20px 0; width: 100%; border-bottom: 1px solid rgba(255, 255, 255, 0.15); background: rgba(51, 51, 51, 0.98); } .navigation-wrapper.visible { display: block; } .cover-navigation { position: relative; float: left; clear: left; display: block; width: 100%; } .cover-navigation .navigation { display: block; width: 100%; } .cover-navigation .navigation li { margin-bottom: .4em; width: 80%; } .cover-navigation.navigation--social { padding-top: 5px; } .cover-navigation.navigation--social .navigation li { display: inline-block; width: 25.8%; } .content-wrapper { margin: 0 auto; width: 80%; max-width: none; } .content-wrapper__inner { margin-right: 0; margin-left: 0; } .navigation__item { margin: 0 0 .4em 0; width: 100%; } } @media all and (max-width: 767px) { .panel-cover__logo { width: 100px; } .Weibo_icon_position { top: -6px; right: 35px; } .qrCode[data-v] { Margin: 0px 38%; } } @media all and (max-width: 480px) { .qrCode[data-v] { Margin: 0px 30%; } } @media all and (max-width: 340px) { .panel-main__inner { padding: 0 5%; } .panel-title { margin-bottom: .1em; font-size: 1.5em; } .panel-subtitle { font-size: .9em; } .btn, .navigation__item a { margin-bottom: .4em; } } 404 对不起，您要找的页面丢失了，(＞_＜；) Sorry, The page your requested can not be found, (＞_＜；) 可以向打小报告哦~ 404 © 2019 |"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2020-02-18T00:38:20.688Z","comments":false,"path":"video/index.html","permalink":"/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"主题更改记录","slug":"ThemeChange.log","date":"2050-12-11T16:00:00.000Z","updated":"2020-07-22T13:19:51.452Z","comments":true,"path":"2050/12/12/ThemeChange.log/","link":"","permalink":"/2050/12/12/ThemeChange.log/","excerpt":"","text":"记录一下改主题的东西吧目录什么的不用想了，不存在的。 CDN总有一天会换的。总有一天。 滚动条和顶部进度条这个主要修改CSS和JS的scrollbar类还有-webkit-scroll的相关样式和函数。 本身不难，就是东西都忘了，改了半天，然后发现在即蠢的一批。background: linear-gradient()的用法其实也是“偷”来的。个人感觉还可以，挺好看的。2019.12.19 backgroundcontent部分：这部分其实吧，就是加了个background-img: url()。其实一开始想做成能切换背景的样子，但是还是自己太蠢，样式调了半天也没弄出来，暂时放弃了。 top部分：就是换个url，在_config.yml里改。 index的centerpassage在figure下面加了俩div用来装passage图片，改了下sakura-app.js里的nextpassage()和prepassage()以及其初始化函数。周期性调用nextpassage()来换图。 使用Animate.css通过class进行淡入淡出（感觉好蠢的操作啊）。 由于是在顶部，position调整为absolute就好了。和contant的passage不一样，那个调成absolute就飞到顶端了。2019.12.20 aplayer部分主要就是改ID和servers，网易云私有的list似乎不能被访问。 一开始少了俩图标，重新建立个新的只改ID发现就好了，可能是之前瞎改layout的时候碰到点什么。2019.12.21 Back-to-top(cd-top)把原本的&lt;a&gt;去掉了，CSS还留着，然后“偷”了个球 是A-Obsidian的，本来想改颜色，发现咋改都有点丑。就同意了下蓝色。2333333333 最后加了个Topへ，就是像给个提示，原主题好像没有，好像。2019.12.25 nav删除了一些，这部分直接从_config.yml直接改，注意后面路径也要改，language下的zh-cn.yml也需要改，只有对应Category和tags存在才会生成文件夹。 目前不知道改怎么弄，还在调教，2333333 单页改动Archive的部分就是换了个图，改了个名字，_config.yml和language下zh-ch.yml都得改。 tags下面的似乎和WordPress的不一样，主要是Booklist，变成文章形式了。 tags要打booklist的名字，categorty不要写，不然会出现在Archive下面。2019.12.26 扒Re:stage(Re:ステージ！)官网部分一直觉得Re:stage的官网效果做的不错（其实也挺简单的动画，但由于是日本人做的，我觉得就很不错了。果然做游戏的审美都不差。哈哈哈），其实之前也偷偷扒拉过。这次完整的算是扒了一个小部分出来。就是角色介绍的那部分。艰难，他用了一个叫TweenMax的库来做动画，定义了一堆函数来回调用，找的我累死了，而且有的语法不再原页面就GG了，但是也没什么影响，可能是找不到元素吧。使用jQuery重写了一些必要的东西，本人很懒，还使用了TweenMax库，这中间真的被自己蠢爆了，名字大小写错了导致jQuery选择器选不到元素卡了半天。CSS很好搞，没什么，到时候微调一下样式就算结束。 数据部分，暂时没办法从Ejs的模板得到数据，不知道为啥，就是空。也不想一次性把所有人的信息放上来，由于整个bloc都没有用数据库，就这里用一个库感觉还不如整体重构一下。暂时卡住了呢。 目前是选择查库了，现在基本的取数据，查标签，删除标签都差不多了呢。动画也能很好的跟上。要不要在弄点其他的呢？ js失效一开始是把js都和去哪来的一样放在了footer.ejs里，但是这样一开是首页的时候就加载了，针对其他页面的js事件绑定是失败的。在到其他页面时候时间是不会触发的。似乎是因为用了Pjax进行的是局部刷新，js是不会重新被加载的。即使把js放到局部模块里。第一次是没问题，第二次访问还是失效，似乎是因为局部刷新不会加载第二次外部引用的js。于是想了个很蠢的方法就是在需要的模块前加上个&lt;script&gt;$.getScript();&lt;/script&gt;来重新加载需要的js。2020.01.01 一些细微调整主要是配置文件上的调整，然后看了看有些啥要留下，啥不留下。 之前一直忙着搞后台，自己本来的东西都忘了。现在争取每天有点进度 2020.1.19 live2D鼓捣了半天官方的SDK，一直有个属性赋值不成功。然后试了下hexo-helper-live2d，但是发现怎么也换不了模型，可能我有哪里没弄对吧。 然后又返回来鼓捣官方SDK，一步一步调试发现motion的JSON加载有问题，解包碧蓝航线的Live2D，用的perfare大佬的UnityLive2DExtractor提取的。 发现官方SDK读取motion的JSON时&quot;TotalPointCount&quot;会越界，也就是没等&quot;segments&quot;读完，顶点就用尽了，改一下顶点大小就能用官方的SDK显示了，顶点给多好像也没关系，但是现在我雪風的idle动作丢了很多，比如头发不飘了，耳朵也不动了，这些很明显。但是吸血鬼的似乎没看出来啥丢失的动作，头发也有飘，翅膀、裙子也有动。 被这个小东西卡了一天我TM也真的是蠢。 说真的，总有一日天，我会用自己的看板娘。 2020.01.21 好的，问题原因很简单，model3.json名字写错了，Idle写成了Idel，自己蠢爆了。 但是发现loop的的动画和CubismViewerForUnity的loop效果不一致，web的loop再结束一个动作后有一种快速倒放的感觉。 2020.01.25 鼓捣了一天，其实有的地方因为嫌烦没有好好看耽误了，目前loop倒放感觉依然不明，但是可以做到TapBody触发动作了model3.json中添加&quot;HitAeras&quot;字段，ID字段要和this._model._model.drawables.ids中相同意思字段吻合。具体内容需要进浏览器console里调试查看。这个可能我觉得可能和moc文件有关（我瞎说的，我什么也不知道，Editor我也只是打开过瞎鼓捣了半天）。 关于身体部位，目前只实现了Head和body，Body部分直接JSON里写就好，Head不止需要在JSON定义。lappdefine.ts中需要加入export const MotionGroupTapHead: string = &quot;TapHead&quot;;来定义一个动作控制。其次再lapplive2dmanager.ts的onTap方法里第一个判断头部哪里，原方法若点击头部是变化表情this._models.at(i).setRandomExpression();,有必要的话，换成和下面一样的this._models.at(i).startRandomMotion();，记得传参，第一个是刚刚定义的LAppDefine.MotionGroupTapHead,指定哪一个动作用的，第二个不变LAppDefine.PriorityNormal就好。 2020.01.27 放弃了，找不到调整模型的方法，看着一堆眼花缭乱的代码，还有恶心的日语注释（主要是片假名看着……）。打算还是用别人现成的东西吧。 2020.01.31 整理了下心情，好好翻了下manual，找到了放大模型显示的地方。 1、lapplive2dmanager下渲染前有个onUpdate()函数，在里面把矩阵大小放大就好。2、lappmodel下setupModel()中修改 Layout下_modelMatrix的scrale，这里如果参数是1，1的话是按照模型原本大小显示，一般会很大。做挂件的画一般在1一下。 模型的移动也可以在上回面两个地方完成，对矩阵调用translate()函数，参数仍是浮点，似乎是按照模型大小为1来计算位移。 回放问题出在动作没有loop。Sample是将你所有的动作放在了一个motion下的，然后每个动作结束后再选取动作压入队列。对于整个motion的loop没有开启的话不知道为什么就会有一个回放一样的。但是还只针对非人物的部分。你在motion里的loop设置是无效的。 妈的文档里其实说明了这个loop的问题。淦!!蠢爆了!!! 2020.02.01 整理下目前Live2D相关东西。 整个内容是用官方的Demo改的。目前整个主函数流程为： window.onload = (): void =&gt; { // create the application instance if (LAppDelegate.getInstance().initialize() == false) { return; } LAppDelegate.getInstance().run(); }; main.ts为主程序入口。首先初始化Canvas和WebGL的东西。包括Dom操作，事件函数绑定。接下来就是Live的View（用于显示的组件）和整个Cubism SDK的初始化。 View初始化就是视口大小和矩阵。 SDK包括Debug用日志、CubismFramework的初始化、Live2DManager的创建、时钟的更新和背景等其他素材的加载。比如原始Demo上面的那个话模型用的齿轮就是这个时候被加载的。 Live2DManager的构造函数包括的模型矩阵的设置，模型的创建的场景索引的更新。 更新场景时会通过LAppDefine中定义好的内容读取路径信息。调用LAppmodel的LoadAssets方法读model3.json的信息，这里用的时fetch()方法，所以是异步的。会继续先执行其他函数。文件加载完后会调用setupMpdel()函数，继续读取moc文件、和Expression、Physics、Motion等相关文件，均为异步执行。 接下来就是run()函数了。 public run(): void { // メインループ const loop = (): void =&gt; { // インスタンスの有無の確認 if (s_instance == null) { return; } // 時間更新 LAppPal.updateTime(); // 画面の初期化 gl.clearColor(0.0, 0.0, 0.0, 0.0); // 深度テストを有効化 gl.enable(gl.DEPTH_TEST); // 近くにある物体は、遠くにある物体を覆い隠す gl.depthFunc(gl.LEQUAL); // カラーバッファや深度バッファをクリアする gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); gl.clearDepth(1.0); // 透過設定 gl.enable(gl.BLEND); gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA); // 描画更新 this._view.render(); // ループのために再帰呼び出し requestAnimationFrame(loop); }; loop(); } 整体来讲定义了一个loop()函数作为主循环递归调用。 首先确定instance（实例）是否存在。然后是更新时间，画面的清空，启动深度测试，深度函数设置，清空颜色和深度Buffer，混合设置和混合函数设置，然后最最重要的画面渲染render()，最后是个递归的调用写法。（我猜） 主要说渲染，渲染包括背景和齿轮的绘制，然后用了个flush()，我猜是同步用的。然后获取Live2DManager实例然后调用Live2DManager的onUpdate()函数。 onUpdate()中依然首先整理好视口和Canvas大小以及矩阵的设置。接下来调用Model的Update()方法。这里面重要的就是模型动作的startRandomMotion().在这个方法里默认调用的是传入的是Idle的参数，所以会重复执行Idle的动作。但是此重复非循环播放。官方文档里说了。不能保证和编译器的循环一致，所以将循环设为false。这里只是因为之前loop的循环而导致一直执行这个函数，从而看起来好像有点别扭的循环Idle动作。 到这里就是一般的，很简单的说了下流程。要做挂件的话就是再矩阵、视口大小和Canvas的大小上改一改就好。 下面是点击事件，默认是supportTouch是false的，所以绑定的是click的函数。 clickBegan()没什么，重点是clickEnd()函数。这里获取了点击坐标后会调用view的onTouchesEnded()函数。在这里做了坐标变换。然后调用Live2DManager的onTap()函数。在这里对点击操作进行了hitTest()，判断击中的是那个区域。默认是对Head和Body的检测，检测是需要模型配合，似乎需要再编辑器里确定。然后根据Hit部位，调用startRandomMotion()函数确定动作或调用setRandomExpression()默认是Head调用后者，Body调用前者。 然后是自己的东西，添加了显示对话功能。通过打乱Demo的代码结构来达成自己不可告人的目的。加入了自己的事件和对话类。对话是储存在json文件里的，可以自己添加和更改。保持读文件操作一致性学习使用了fetch()来异步加载对话。事件就是简单的点击事件，因为Demo用的原生JS。所以依然保持使用基础Dom操作绑定事件。（写的时候有种回到了大一的感觉） 但是现在点击有时候不会触发动作，这个在原Demo上也有这个问题（也可能是我已经找不到原Demo误会了）。 已知问题sakura-app.js里的imgError函数突然开始报错说找不到。现在一脸懵逼中 由于CDN的问题，图片显示不完全和找不到 顶部导航栏Archive和list部分的下拉菜单突然效果变了 其实是和Animate.css的Keyframe重名了，改一下就好。 MarkDown解析有点问题，有的格式不支持 其实应该重构一下代码的，无奈我很懒，哈哈哈哈哈","categories":[{"name":"吐槽","slug":"吐槽","permalink":"/categories/吐槽/"}],"tags":[{"name":"你说这知识咋就不进脑子呢","slug":"你说这知识咋就不进脑子呢","permalink":"/tags/你说这知识咋就不进脑子呢/"},{"name":"吐槽","slug":"吐槽","permalink":"/tags/吐槽/"}],"keywords":[{"name":"吐槽","slug":"吐槽","permalink":"/categories/吐槽/"}]},{"title":"主题Admin更改记录","slug":"Admin","date":"2050-12-11T16:00:00.000Z","updated":"2020-03-29T14:08:39.795Z","comments":true,"path":"2050/12/12/Admin/","link":"","permalink":"/2050/12/12/Admin/","excerpt":"","text":"记录一下Admin的进度2020.01.05主题选择看上个Vue写的Admin，虽然当初讲Vue的时候基本没听，但也还好其实。 用的是Vue Black Dashboard - v1.1.0 MarkDown其实一开始是想自己写的，写了半天吧，发现有点烦，于是就打算用现成的了。 由于是Vue，本来想用editor.md的，无奈不懂为什么有个CSS样式一直报错，说找不到。 后来只能决定用mavon-editor，因为网上我看好多人都是用这个的。就从众了，因为默认主题颜色是白的，首先就是改颜色。 然后，呵呵，改了一天，不知道为什么第三方组件有的样式改了是不生效的。尤其是mavon-editor的textarea文字颜色，怎么改也该不出来，好家伙最后发现是mavon-editor.js里居然把Auto-text里的样式用js全重写了一遍！！！ 难过…… 2020.01.06MarkDown样式基本调好后，解决了一下图片上传的问题。目前的想法是，上传图片后先将图片送到服务器上暂时保存，删除图片时也会从服务器上删除，最后在发布文章的时候再一次性从服务器上上传到腾讯的COS。现在可以暂存图片，COS上传还在解决子账户的问题。 上传图片时发现系统权限不够无法创建文件夹。不知道为什么windows默认使用的是user用户，明明还有很多可选偏偏选这个。使用axios时出现not define的错误，这个网上一堆，类比下就出来了。有时间真的要看看文件操作这部分。 Vue路由选的主题发现没有登陆选项，因为后台是和小伙伴一起用的，所以需要区别下，背景啦，上传URL啦什么的。然后学习了下路由，由于源码就是用了一个嵌套路由，默认path是&#39;/&#39;然后redirect到一个/dashboard下面。如果把原path改成别的会导致部分组件不显示。 明发现内部组件更换和TopNavBar下compute()方法有关 routeName() { const { name } = this.$route; return this.capitalizeFirstLetter(name); } 这个值会改变vue2-transitions的key值。来控制显示组件。具体没有细看。就直接再app和layout的mounted()里加了个判断，不符合直接跳到Login页面，简单粗暴。有时间一定要看看这个具体是怎么回事。 2020.01.07Login做了个登陆界面，感觉自己相当菜鸡， 暂时作废。。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"你说这知识咋就不进脑子呢","slug":"你说这知识咋就不进脑子呢","permalink":"/tags/你说这知识咋就不进脑子呢/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"实习小“总结”：贴图尺寸检查","slug":"TextureSizeCheck","date":"2020-07-20T16:00:00.000Z","updated":"2020-07-22T13:22:17.063Z","comments":true,"path":"2020/07/21/TextureSizeCheck/","link":"","permalink":"/2020/07/21/TextureSizeCheck/","excerpt":"","text":"检查贴图大小是否符合要求Unity会自动将贴图拉伸成一定尺寸，通常为2的n次幂，所以有些原始贴图的大小不一定是Unity中显示的尺寸，目标就是判断贴图原始尺寸是否符合要求。 流程获取选定文件夹-&gt;获取文件夹下所有Texture2D-&gt;读取贴图-&gt;判断尺寸 前2个流程完全可以使用之前贴图压缩的做法。 其中获取文件夹可以使用之前用到的Selection.assetGUIDs得到资源的GUID，然后通过AssetDatabase.GUIDToAssetPath()得到文件夹的绝对路径。再使用AssetDatabase.FindAssets()，寻找文件夹下为Texture2D格式的文件。最后利用GUID的到绝对路径，转为Assets开头的相对路径。 读取贴图的时候会有几个问题，首先如果使用AssetDatabase.LoadAssetAtPath()方法获取Texture2D类型的贴图，这样得到的宽高实际上是Unity处理过后的，也就是说基本上肯定是2的n次幂。那么就只能尝试读取原始文件。 首先是可以使用System.Drawing.Image类，通过返回的对象obj，obj.width和obj.height可以得到原始大小。 但是有一点，System.Drawing.Image这个类用的是GDI+，支持的格式比较少。读到不支持的格式会出现OutOfMemoryException。像tga格式就无法读取。 另一种方法是使用Unity反射，调用TextureImporter的私有函数getWidthAndHeight。虽然官方文档里没有看见，但是确实可行，像exr、tga等疑难杂症也可以处理。不太理解反射，感觉就像是比较万能的友元函数。 MethodInfo mi = typeof(TextureImporter).GetMethod(&quot;GetWidthAndHeight&quot;, BindingFlags.NonPublic | BindingFlags.Instance); 下面的不只是可以检查是否是4的倍数，2的n次幂也可以。其实就是再加一层判断。 using System.Collections; using System.IO; using UnityEditor; using System.Drawing; using UnityEngine; using System.Reflection; public class CheckTexture : EditorWindow { [MenuItem(&quot;TextureTools/Texture Width Check&quot;)] static void TextureCheck() { string[] selected = Selection.assetGUIDs; if(selected.Length == 0) { EditorUtility.DisplayDialog(&quot;Error&quot;, &quot;Please select at least one folder&quot;, &quot;OK&quot;); return ; } ArrayList list = GetFolderList(selected); string[] folderPath = (string[])list.ToArray(typeof(string)); for(int i=0;i&lt;folderPath.Length;++i) { if (!Directory.Exists(folderPath[i])) { EditorUtility.DisplayDialog(&quot;Error&quot;, folderPath[i] + &quot;is not a folder,Please select a folder&quot;, &quot;OK&quot;); return; } } string[] assetsGuids = AssetDatabase.FindAssets(&quot;t:texture&quot;, folderPath); ArrayList notMultiple4 = new ArrayList(); ArrayList Multiple4notPow2 = new ArrayList(); for (int i=1;i&lt;= assetsGuids.Length;++i) { Bar(&quot;Executing……&quot;, &quot;Finding&quot;, i, assetsGuids.Length); string path = AssetDatabase.GUIDToAssetPath(assetsGuids[i-1]); TextureWidthCheck(path, Multiple4notPow2, notMultiple4); } if (EditorUtility.DisplayDialog(&quot;Save Log&quot;, &quot;notMultiple4:\\n&quot; + GetPathString((string[])notMultiple4.ToArray(typeof(string))) + &quot;\\n&quot; + &quot;Multiple4notPow2\\n&quot; + GetPathString((string[])Multiple4notPow2.ToArray(typeof(string))) + &quot;\\n&quot; + &quot;Do you need to save the Texture size Log?&quot;, &quot;yes&quot;, &quot;no&quot;)) WriteLog(Multiple4notPow2, notMultiple4); } public static void GetTextureOriginalSize(TextureImporter ti, out int width, out int height) { if (ti == null) { width = 0; height = 0; return; } object[] args = new object[2] { 0, 0 }; MethodInfo mi = typeof(TextureImporter).GetMethod(&quot;GetWidthAndHeight&quot;, BindingFlags.NonPublic | BindingFlags.Instance); mi.Invoke(ti, args); width = (int)args[0]; height = (int)args[1]; } static void TextureWidthCheck(string path, ArrayList Multiple4notPow2, ArrayList notMultiple4) { path = path.Substring(path.IndexOf(&quot;Assets&quot;)); TextureImporter textureImporter = AssetImporter.GetAtPath(path) as TextureImporter; int realwidth = 0; int realheight = 0; GetTextureOriginalSize(textureImporter, out realwidth, out realheight); if (MultipleOf4(realwidth,realheight)) { if (!PowOf2(realwidth, realheight)) Multiple4notPow2.Add(path); } else notMultiple4.Add(path); } static bool PowOf2(int width, int height) { return (width &amp; (width - 1))== 0 ? (height &amp; (height - 1)) == 0 ? true : false : false; } static bool MultipleOf4(int width,int height) { return width % 4 == 0 ? height % 4 == 0 ? true : false : false; } public static void Bar(string title, string message, int now, int end) { EditorUtility.DisplayProgressBar(title, message + now + &quot;/&quot; + end, (float)now / end); if (now &gt;= end) EditorUtility.ClearProgressBar(); } static ArrayList GetFolderList(string[] strs) { ArrayList list = new ArrayList(); for (int i = 1; i &lt;= strs.Length; ++i) { Bar(&quot;Executing...&quot;, &quot;confirming path&quot;, i, strs.Length); string path = AssetDatabase.GUIDToAssetPath(strs[i - 1]); list.Add(path); } return list; } static string GetPathString(string[] strs) { string allPath = &quot;&quot;; foreach (string str in strs) allPath += str + &quot;\\n&quot;; return allPath; } static void WriteLog(ArrayList Multiple4notPow2, ArrayList notMultiple4) { string path = &quot;Assets/Log/&quot;; string name = &quot;TextureSizeCheck.log&quot;; StreamWriter sw; FileInfo t = new FileInfo(path + &quot;//&quot; + name); if (!t.Exists) sw = t.CreateText(); else sw = t.AppendText(); sw.WriteLine(System.DateTime.Now); sw.WriteLine(&quot;notMultiple4:\\r\\n&quot; + GetPathString((string[])notMultiple4.ToArray(typeof(string))) + &quot;\\r\\n&quot; + &quot;Multiple4notPow2\\r\\n&quot; + GetPathString((string[])Multiple4notPow2.ToArray(typeof(string))) + &quot;\\r\\n&quot;); sw.Close(); sw.Dispose(); } }","categories":[{"name":"Unity","slug":"Unity","permalink":"/categories/Unity/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"你说这知识咋就不进脑子呢","slug":"你说这知识咋就不进脑子呢","permalink":"/tags/你说这知识咋就不进脑子呢/"},{"name":"实习总结","slug":"实习总结","permalink":"/tags/实习总结/"}],"keywords":[{"name":"Unity","slug":"Unity","permalink":"/categories/Unity/"}]},{"title":"实习小“总结”：贴图压缩格式转化","slug":"TextureCompressedFormatChange","date":"2020-07-12T16:00:00.000Z","updated":"2020-07-22T13:22:08.373Z","comments":true,"path":"2020/07/13/TextureCompressedFormatChange/","link":"","permalink":"/2020/07/13/TextureCompressedFormatChange/","excerpt":"","text":"改变贴图压缩格式ETCOpenGL ES 2.0支持，移动端GPU均支持，ETC把一个4x4的像素单元组压成一个64位的数据块。但是没有Alpha通道，需要额外补一块Alpha通道的贴图。尺寸为2的N次幂，长宽可以不相同。 ETC2OpenGL ES 3.0支持，与ETC相比增加了Alpha通道，支持更高质量的压缩。尺寸需要为4的倍数。 ASTCIOS上用的格式，IOS9开始支持，需要A8以上处理器，Android也可以使用，但是压缩的时候很慢。 流程：得到选择的文件及路径-&gt;得到文件夹下贴图路径-&gt;改变贴图压缩格式 得到选择的路径使用得到资Selection.assetGUIDs源的GUID，返回是一个string数组。然后通过AssetDatabase.GUIDToAssetPath()可以得到文件夹的绝对路径。 然后使用AssetDatabase.FindAssets()，寻找文件夹下为Texture2D格式的文件，返回的是文件GUID的string数组。 接下来利用GUID的到绝对路径后，转为Assets开头的相对路径，就可以开始转换了 改变贴图压缩格式需要使用TextureImporter的SetPlatformTextureSettings()函数。可以使用 AssetImporter.GetAtPath()方法，然后强制转换成TextureImporter，方法需要提供的是以Assets开头的相对路径，不可以使用绝对路径，否则返回为空。SetPlatformTextureSettings()参数为，平台（Android或iPhone），贴图大小，贴图格式。贴图大小通常统一为2的整次幂，PVRTC、ETC要求，ETC2要求4的倍数。贴图格式都在TextureImporterFormat这个枚举类里，按需求设置就好。同时改变完需要重新导入，使用AssetDatabase.ImportAsset()方法，重新导入后即使关闭编辑器，重新打开后依然保存。 提示框和进度条。Unity的EditorUtility已经封装好了一些工具。可以不需要调用DLL。 提示框可以使用EditorUtility.DisplayDialog(),四个参数为标题，内容，确认按钮和取消按钮，全部都为string，返回值为bool。不填写取消或确认则不显示对应按钮。 进度条可以使用不带取消的EditorUtility.DisplayProgressBar(),参数为标题，内容和进度。其中标题和内容是String类，进度是0-1范围内的浮点型。进度条的消失需要调用函数EditorUtility.ClearProgressBar();可以通过判断是否执行完来去调用。 using System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEditor; public class ChangeFormate : EditorWindow { static TextureImporterFormat textureFormatA = TextureImporterFormat.RGBA32; static TextureImporterFormat textureFormat = TextureImporterFormat.RGB24; [UnityEditor.MenuItem(&quot;TextureTools/Convert/ConvertFormatToASTC&quot;)] static void AutoSetASTC() { textureFormatA = TextureImporterFormat.ASTC_RGBA_5x5; textureFormat = TextureImporterFormat.ASTC_RGB_4x4; StartToConvert(); } [UnityEditor.MenuItem(&quot;TextureTools/Convert/ConvertFormatToETC&quot;)] static void AutoSetETC() { textureFormatA = TextureImporterFormat.ETC_RGB4; textureFormat = TextureImporterFormat.ETC_RGB4; StartToConvert(); } [UnityEditor.MenuItem(&quot;TextureTools/Convert/ConvertFormatToETC2&quot;)] static void AutoSetETC2() { textureFormatA = TextureImporterFormat.ETC2_RGBA8; textureFormat = TextureImporterFormat.ETC2_RGB4; StartToConvert(); } [UnityEditor.MenuItem(&quot;TextureTools/Convert/ConvertFormatToRGBA32&quot;)] static void AutoSetRGBA32() { textureFormatA = TextureImporterFormat.RGBA32; textureFormat = TextureImporterFormat.RGB24; StartToConvert(); } static void SetPicFormat(string path) { path = path.Substring(path.IndexOf(&quot;Assets&quot;)); TextureImporter importer = (TextureImporter)AssetImporter.GetAtPath(path); if (importer.mipmapEnabled == true) importer.mipmapEnabled = false; Texture2D texture = AssetDatabase.LoadAssetAtPath&lt;Texture2D&gt;(path); int textureSize =0; int SizeType = 0; if (!texture) { Cubemap cube = AssetDatabase.LoadAssetAtPath&lt;Cubemap&gt;(path); textureSize = Mathf.Max(cube.height, cube.width); SizeType = FitSize(textureSize); } else { textureSize = Mathf.Max(texture.height, texture.width); SizeType = FitSize(textureSize); } if (importer.DoesSourceTextureHaveAlpha()) { //importer.SetPlatformTextureSettings(&quot;iPhone&quot;, SizeType, TextureImporterFormat.ASTC_RGBA_6x6); importer.SetPlatformTextureSettings(&quot;Android&quot;, SizeType, textureFormatA); } else { //importer.SetPlatformTextureSettings(&quot;iPhone&quot;, SizeType, TextureImporterFormat.ASTC_RGB_6x6); importer.SetPlatformTextureSettings(&quot;Android&quot;, SizeType, textureFormat); } AssetDatabase.ImportAsset(AssetDatabase.GetAssetPath(texture)); } static int[] formatSize = new int[] { 32, 64, 128, 256, 512, 1024, 2048, 4096 ,8192}; static Dictionary&lt;TextureImporterFormat, string&gt; formatDict = new Dictionary&lt;TextureImporterFormat, string&gt; { { TextureImporterFormat.ASTC_RGBA_5x5, &quot;ASTC_RGBA_5x5&quot; },{ TextureImporterFormat.ASTC_RGB_4x4, &quot;ASTC_RGB_4x4&quot; }, { TextureImporterFormat.ETC_RGB4, &quot;ETC_RGB4&quot; }, { TextureImporterFormat.ETC2_RGBA8, &quot;ETC2_RGBA8&quot; },{ TextureImporterFormat.ETC2_RGB4, &quot;ETC2_RGB4&quot; }, { TextureImporterFormat.RGBA32, &quot;RGBA32&quot; },{ TextureImporterFormat.RGB24, &quot;RGB24&quot; }}; static int FitSize(int picValue) { foreach (var one in formatSize) { if (picValue &lt;= one) { return one; } } return 1024; } public static void Bar(string title, string message, int now, int end) { EditorUtility.DisplayProgressBar(title, message + now + &quot;/&quot; + end, (float)now / end); if (now &gt;= end) { EditorUtility.ClearProgressBar(); } } static string GetPathString(string[] strs) { string allPath = &quot;&quot;; foreach (string str in strs) { allPath += str + &quot;\\n&quot;; } return allPath; } static bool isDir(string[] paths) { foreach(string path in paths) if(path.IndexOf(&quot;.&quot;) != -1) return false; return true; } static ArrayList GetFolderList(string[] strs) { ArrayList list = new ArrayList(); for (int i = 1; i &lt;= strs.Length; ++i) { Bar(&quot;执行中...&quot;, &quot;正在确定路径&quot;, i, strs.Length); string path = AssetDatabase.GUIDToAssetPath(strs[i - 1]); list.Add(path); } return list; } static void StartToConvert() { string[] guid = Selection.assetGUIDs; if (guid.Length == 0) { EditorUtility.DisplayDialog(&quot;Error&quot;, &quot;请至少选择一个文件夹&quot;, &quot;确定&quot;); return; } ArrayList list = GetFolderList(guid); string[] folderpath = (string[])list.ToArray(typeof(string)); if(!isDir(folderpath)) { EditorUtility.DisplayDialog(&quot;Error&quot;, &quot;请选择文件夹&quot;, &quot;确定&quot;); return; } if (EditorUtility.DisplayDialog(&quot;tittle&quot;, &quot;是否要将\\n&quot; + GetPathString(folderpath) + &quot;转换成&quot; + formatDict[textureFormatA]+ &quot;和&quot; + formatDict[textureFormat] , &quot;确定&quot;, &quot;取消&quot;)) { string[] guids = AssetDatabase.FindAssets(&quot;t:texture&quot;, folderpath); for (int i = 1; i &lt;= guids.Length; ++i) { Bar(&quot;执行中……&quot;, &quot;正在转换&quot;, i, guids.Length); string path = AssetDatabase.GUIDToAssetPath(guids[i - 1]); SetPicFormat(path); } } } }","categories":[{"name":"Unity","slug":"Unity","permalink":"/categories/Unity/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"你说这知识咋就不进脑子呢","slug":"你说这知识咋就不进脑子呢","permalink":"/tags/你说这知识咋就不进脑子呢/"},{"name":"实习总结","slug":"实习总结","permalink":"/tags/实习总结/"}],"keywords":[{"name":"Unity","slug":"Unity","permalink":"/categories/Unity/"}]},{"title":"实习小“总结”：NGUI 滑动菜单","slug":"NGUI_ScrollView","date":"2020-07-07T16:00:00.000Z","updated":"2020-07-22T13:22:12.021Z","comments":true,"path":"2020/07/08/NGUI_ScrollView/","link":"","permalink":"/2020/07/08/NGUI_ScrollView/","excerpt":"","text":"NGUI 滑动菜单要求一个滑动菜单，总共有100个物体，显示5个，但只能用创建100个物体，只能用6个。 结构：UI Root-&gt;Camera/Scroll View-&gt;Grid-&gt;items。 Grid用来整理布局。item使用NGUI的Texture。 实现描述：搭好结构后需要在item上添加Box Collider和UI Drag ScrollView脚本。并且设置UI Drag ScrollView中的ScrollView为自身父级的那个ScrollView。同时需要注意Box Collider有没有match整个item，没有的话可以点击UI Widget下Collider的auto-adjust to match勾选框。 Box Collider用于监听触摸滑动事件，据说是NGUI的标准操作，UIDragScrollView会find ScrollView，然后直接调用ScrollView的Drag、Press、Scroll。这样就可以拖动了。 以纵向滑动为例： 需要实现向下翻将上面的元素移到下面，向上翻要把下面的移动到上面。 这个可以通过调整Grid中item的LocalPosition来完成。当顶层item消失在显示区域时，将消失的item从当前位置移动当前位置+Grid的Child数量*Grid的Cell高度，也就是设置LocalPosition为这个值。然后改变item的内容即可。 使用list来储存数据，用索引来记录当前显示数据的头和尾。 首先需要获得所有item的位置信息。接下来其更改顶层item的信息和位置，最后更新索引和阈值。如何判断元素完全消失，可以使用UIPanel的clipOffset来判断。当offset大于或小于一个item的高度时候就说明这个这个item消失了。上下移动都是一样的。 其实也可以获取Grid下的item，并且更新数据，绑定OnDrag事件。事件绑定使用UIEventListener的Get().OnDrag。这个OnDrag接受的函数参数为(GameObject，Vector2)其中vector2就是移动的向量。通过判断这个向量的y，就能知道向上还是向下滑动。 关于ScrollBar，通过UIPanel的clipOffest属性除（list中的数量*Grid一个cell的高度）就可以的到相对位置。设置ScrollBar的value就可以通过ScrollView来控制ScrollBar。 但是这个情况下不能使用ScrollBar的OnValueChange控制滑动窗口。因为对ScrollBar的Value设置一次值也会出发OnValueChange。 如果想ScrollBar对滑动窗口也进行设置的话，个人做法是选择重排列表，通过OnValueChange触发重排，通过ScrollBar的Value可以计算出应显示的是从第几个开始，然后将所有item从这个位置开始排。 有个小BUG，不知道为什么有时候调整滑块后会回弹。 回弹原因可能是ScrollView的Momentum Amount原因，导致滑动后会有个力的反应，导致item依然在滑动，这时候操作ScrollBar就会导致有参数没有及时更新而出错。把这个值设为0就好了。 总结说实话，这个有很大问题，因为实际上重排每回都被触发，在ScrollView上滑动回西安出发重排然后再移动元素，不是很好。但是效果上看是没什么没问题的。 using System; using System.Collections.Generic; using UnityEngine; public class Roll : MonoBehaviour { public UIGrid grid; public UIPanel panel; public UIScrollBar scrollBar; public List&lt;ItemProperty&gt; list = new List&lt;ItemProperty&gt;(); public int itemNum = 3; public float cellHeight = 0.0f; float nextHeight = 120.0f; float preHeight = 1.0f; int frontIndex = 0; int tailIndex = 4; int realFrontIndex = 0; int realTailIndex = 4; List&lt;string&gt; nameList = new List&lt;string&gt;(); void Start() { SetRandomName(); list = GridItemUtil.GetItems(grid.gameObject); for (int i = 0; i &lt; list.Count; ++i) { grid.gameObject.transform.GetChild(i).gameObject.transform.Find(&quot;Label&quot;).GetComponent&lt;UILabel&gt;().text = nameList[i]; UIEventListener.Get(grid.gameObject.transform.GetChild(i).gameObject).onDrag = ChangeScrollValue; } } void ChangeScrollValue(GameObject go, Vector2 deltaVector2) { if (deltaVector2.y &gt; 0) MoveToBottom(); else MoveToTop(); scrollBar.value = -(panel.clipOffset.y) / ((nameList.Count - itemNum) * cellHeight); } public void ChangeScrollView() { float offset = scrollBar.value * (nameList.Count - itemNum) * cellHeight; panel.clipOffset = new Vector2(0, -offset); panel.gameObject.transform.localPosition = new Vector3(0, offset, 0); int c = (int)(offset / cellHeight); c = c &gt; nameList.Count - list.Count ? nameList.Count - list.Count : c; for (int i = 0; i &lt; list.Count; ++i) { list[i].reName(nameList[c]); list[i].item.transform.localPosition = new Vector3(0, -c * cellHeight, 0); grid.gameObject.transform.GetChild(i).gameObject.transform.localPosition = new Vector3(0, -c * cellHeight, 0); c++; } nextHeight = (c - list.Count + 1) * cellHeight; preHeight = (c - list.Count) * cellHeight + 1.0f; realFrontIndex = c - list.Count; realTailIndex = c; frontIndex = 0; tailIndex = 4; } void SetRandomName() { for (int i = 0; i &lt; 100; ++i) { nameList.Add(&quot;No.&quot; + i); } } void MoveToBottom() { list = GridItemUtil.GetItems(grid.gameObject); list[frontIndex].reName(nameList[++realTailIndex]); list[frontIndex].item.transform.localPosition = list[frontIndex].item.transform.localPosition + new Vector3(0, -(grid.gameObject.transform.childCount) * cellHeight, 0); grid.gameObject.transform.GetChild(frontIndex).gameObject.transform.localPosition = list[frontIndex].item.transform.localPosition; nextHeight += cellHeight; preHeight += cellHeight; tailIndex = frontIndex; frontIndex++; frontIndex %= list.Count; realFrontIndex++; } void MoveToTop() { list = GridItemUtil.GetItems(grid.gameObject); list[tailIndex].reName(nameList[--realFrontIndex]); list[tailIndex].item.transform.localPosition = list[tailIndex].item.transform.localPosition + new Vector3(0, (grid.gameObject.transform.childCount) * cellHeight, 0); grid.gameObject.transform.GetChild(tailIndex).gameObject.transform.localPosition = list[tailIndex].item.transform.localPosition; nextHeight -= cellHeight; preHeight -= cellHeight; frontIndex = tailIndex; tailIndex--; tailIndex = (tailIndex + list.Count) % list.Count; realTailIndex--; } }","categories":[{"name":"Unity","slug":"Unity","permalink":"/categories/Unity/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"你说这知识咋就不进脑子呢","slug":"你说这知识咋就不进脑子呢","permalink":"/tags/你说这知识咋就不进脑子呢/"},{"name":"实习总结","slug":"实习总结","permalink":"/tags/实习总结/"}],"keywords":[{"name":"Unity","slug":"Unity","permalink":"/categories/Unity/"}]},{"title":"Unity动态加载特效","slug":"Unity_LoadFXDynamically","date":"2020-06-11T16:00:00.000Z","updated":"2020-07-15T13:57:43.714Z","comments":true,"path":"2020/06/12/Unity_LoadFXDynamically/","link":"","permalink":"/2020/06/12/Unity_LoadFXDynamically/","excerpt":"","text":"简单的动态加载特效方法准备自然就是需要的特效了。将特效做好后保存为prefab放在Resource文件夹下。 整体思路动态加载特效主要分为加载，实例化克隆体，处理效果逻辑，销毁克隆体几个步骤，至于为什么要用克隆体，有时候我们需要一个特效同时出现很多次的时候，多次的加载会浪费时间，从一个已经加载好的物体克隆的速度会相对好一些。 加载Resources.Load这个方法有个模板方法，返回值就是模板值。默认是返回Object类型。参数是string类型的路径，路径是在Resource文件夹下的。 Object Loadobj = Resources.Load(&quot;Path&quot;); 通常简单情况下保持Object类型就可以。 还有个异步方法： Resources.LoadAsync参数是参数是string类型的路径，路径同样是在Resource文件夹下的。而返回值是ResourceRequest。 ResourceRequest属性有：Properties | Desc————-|————— asset | 加载的物体 allowSceneActivation | 当场景加载完成时是否允许激活场景 isDone | 场景是否加载完 priority | 调整异步操作的顺序的优先级 progress | 加载进度 通过ResourceRequest.asset就可以获得加载的物体。 实例化克隆体Object.Instantiate就可以在场景中实例化出一个克隆体。有多个重载函数 public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); Parameters Desc original 要克隆的物体 position 克隆体的位置 rotation 克隆体的方向 parent 克隆体的父对象 instantiateInWorldSpace 当设置父对象时候，传入true则克隆体直接处于世界坐标，若为false则是父对象的相对坐标。 返回值是克隆体。 最简单的操作就是： GameObject gameObj = Object.Instantiate(Loadobj) as GameObject; 然后对gameObj做操作。 处理逻辑这个就跟据需要，在要加载的特效上面挂上特效生成后需要遵循的逻辑即可。 销毁克隆体Object.Destroy函数就可以从场景中移除物体。参数为：Parameters | Desc————-|————— obj | 要删除的物体 t | 延迟t时间删除物体，float类型如果obj是一个组件，则从将组件从GameObject移除并销毁，若obj是一个GameObject，则销毁GameObject及其左右子对象和组件。 使用也很简单，需要移除的时候调用就可以。 Object.Destroy(gameObj); 小提示如果特效允许自身重用，其实可以保留一个小的克隆体列表来避免实例化克隆体和销毁克隆体的开销，通过设置GameObject的Active来管理显示，若列表数目不够可以在实例化然后删除。 还可以建立一个统一的特效类来管理特效本身，并依据特效类型制定各自的控制类。路径方面可以用一个类专门管理路径。","categories":[{"name":"Unity","slug":"Unity","permalink":"/categories/Unity/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"你说这知识咋就不进脑子呢","slug":"你说这知识咋就不进脑子呢","permalink":"/tags/你说这知识咋就不进脑子呢/"}],"keywords":[{"name":"Unity","slug":"Unity","permalink":"/categories/Unity/"}]},{"title":"Unity异步加载场景","slug":"Unity_LoadSceneAsynchronously","date":"2020-06-10T16:00:00.000Z","updated":"2020-07-15T13:57:43.714Z","comments":true,"path":"2020/06/11/Unity_LoadSceneAsynchronously/","link":"","permalink":"/2020/06/11/Unity_LoadSceneAsynchronously/","excerpt":"","text":"这里是个简单的实现场景异步加载并显示进度（附加淡入淡出效果）场景加载同步方式还是要提一嘴加载方式哈。 SceneManager.LoadScene方法是同步加载场景。 参数简单来用就是场景名称或场景在BuildSetting下的索引。使用场景名称时，会自动从Scene文件夹下寻找场景。无返回值。 异步方式SceneManager.LoadSceneAsync方法是异步加载场景，就是文章的主角。 参数：Parameters | Desc————-|————— sceneName | 场景名称或路径 sceneBuildIndex | 场景在BuildSetting下的索引 mode | SceneManager.LoadSceneMode,默认Single，会卸载当前场景，若为Additive则会在当前场景中添加下一个场景。 parameters | 一个将各种参数储存到单独位置的结构体，除了名称和索引 返回值为AsyncOperation 这里parameter一般不会用到。使用场景名称时候函数会从Scene文件夹下寻找场景。场景加载好后会直接进入加载的场景。 显示进度UI方面使用Slider来表示进度条和Text来表示文字信息。 显示进度就需要异步加载的返回值AsyncOperation了。AsyncOperation的属性有：Properties | Desc————-|————— allowSceneActivation | 当场景加载完成时是否允许激活场景 isDone | 场景是否加载完 priority | 调整异步操作的顺序的优先级 progress | 加载进度 这里们我们需要用到的是progress。progress返回的是0-1的值，所以可以直接用来做进度条Slider的value。作为显示给人看的文字部分，直接乘100再加上%就好了。 淡入淡出淡入淡出最简单的想法就是使用一张黑色的纯色层然后调整透明度。 我们只需要个根据时间调整纯色层的透明度就好。简单来讲就是新建一个UI.Image，调整它的颜色，但是由于不能单独调整颜色的Alpha通道，所以只能直接赋值颜色。 淡入示例： public Image img; float Alpha = 1.0f; void Update() { Alpha -= Time.deltaTime; img.color = new Color(0, 0, 0, Alpha); } 总体实现整体思路一种想法是： 设我们从A场景加载到C场景。为了显示进度，添加中间场景B作为显示Loading媒介。在B场景中做UI，然后通过全局变量确定要跳转的场景。 另一种想法是： 要进行场景切换时候，在A场景中生成已经做好的Loading的UI，加载好后在跳转。 两种都可以，这里用第一种，第二种直接把场景B的UI拖出来，然后按需加载就好。 场景切换第一步，不论如何要进入Loading场景，然后再进入我们需要的场景。这时候就涉及保存要进入场景名字。我们设置全局变量来解决 public class SceneLoadProperty { public static string NextloadScene = &quot;SampleScene&quot;; } 然后就是进入Loading场景。 public void ToLoad(string nextScene) { SceneLoadProperty.NextloadScene = nextScene; SceneManager.LoadScene(&quot;Loading&quot;); } 因为的Loading场景非常简单，就是UI，所以加载很快，同步异步没有啥大区别，都可以。需要场景切换的时候就调用这个方法，进入Loading场景再说别的。 接下来进入了Loading场景。我们需要展示加载进度，正如上面所说，使用Text和Slider来实现。用上面方法也可以。但这个时候有个小事情，如果加载的场景过于简单以至于一瞬间完成，看不到加载界面。然是又想显示怎么办。这个时候就是做假进度条来实现。 为了不让场景加载好就激活，我们用到了异步加载等我返回值AsyncOperation中的allowSceneActivation属性，首先将其设置为false就可以解决问题。 AsyncOperation async; async = SceneManager.LoadSceneAsync(SceneLoadProperty.NextloadScene); async.allowSceneActivation = false; 然后等场景加载好在设置其为true就好了。但是这带来一个问，progress属性说明中提到，当allowSceneActivation为false时候progress最终会停在0.9，直到allowSceneActivation变为true。所以注意对progress处理下再使用。简单来讲就是 float fakeRate = 0.0f; fakeRate = Mathf.Lerp(fakeRate,async.progress/9*10,Time.deltaTime); 这样就是对进度进行线性插值，进度条会均匀增加到100%。然后到100%时候把allowSceneActivation设为true，就会进入下一个场景了。 淡入淡出使用UI方法，就可以。当然也可以使用协程,这样就可以使用同一个UI了。 public Image img; float Alpha = 1.0f; void Start() { StartCoroutine(FadeIn()); } void Update() { if(SceneLoadProperty.isOut) FadeOut() } IEnumerator FadeIn() { Alpha = 1.0f; while(Alpha&gt;0) { Alpha -= Time.deltaTime; img.color = new Color(0, 0, 0, Alpha); yield return null; } } IEnumerator FadeOut() { Alpha = 0.0f; while (Alpha &lt; 1) { Alpha += Time.deltaTime; img.color = new Color(0, 0, 0, Alpha); yield return null; } }","categories":[{"name":"Unity","slug":"Unity","permalink":"/categories/Unity/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"你说这知识咋就不进脑子呢","slug":"你说这知识咋就不进脑子呢","permalink":"/tags/你说这知识咋就不进脑子呢/"}],"keywords":[{"name":"Unity","slug":"Unity","permalink":"/categories/Unity/"}]},{"title":"Unity角色控制","slug":"Unity_CharacterController&Rigidbody","date":"2020-05-25T16:00:00.000Z","updated":"2020-07-15T14:28:08.910Z","comments":true,"path":"2020/05/26/Unity_CharacterController&Rigidbody/","link":"","permalink":"/2020/05/26/Unity_CharacterController&Rigidbody/","excerpt":"","text":"其实这里是实现角色移动的问题CharacterConttroller角色控制器，字面含义，就是控制器，自带碰撞检测。 属性 Property: Function: Slope Limit 角色爬坡最大角度 Step Offset 角色最大可迈上的台阶高度 Skin width 覆盖于角色表面的“皮肤”厚度 Min Move Distance 最小移动距离 Center 控制器胶囊的中心位置 Radius 控制器胶囊的半径 Height 控制器胶囊的高度，胶囊两端圆心之间距离 前面参数和角色的控制有关，后面三个主要和碰撞有关，当然ACT一般都会另外绑碰撞，来做更复杂的逻辑，如打到头和打到手伤害不一样。 CharacterController说白了就是提供了一个简单的碰撞和一些简单参数罢了，具体其他东西都需要我们自己来写。 如果使用自带的胶囊就可以的话，那么调整好胶囊大小后就可以写角色的移动的代码了。 获取输入第一个关键点便是获取输入，通过Input类可以获取。使用GetKey()方法可以获取到按下的按键，若按键一直被按着，GetKey()将会一直获取，同样还有GetKeyDown()和GetKeyUp()两个方法，分别获取按键被按下的那一下和抬起的那一下。一直按着GetKeyDown()也只会触发一次。通过这三个函数可以灵活使用达到不同的取得按键值的效果。 当然，简单来说按键就可以解决大部分的输入问题了。但是有些3D的ADV难道用手柄玩的不比键盘香吗？于是这里引入Axis（轴）。通过Input类的GetAxis()方法可以得到轴的信息。参数名称Unity默认为”Horizontal”和”Virtical”分别对应x轴和z轴。这个可以在Unity的Edit-&gt;Project Settings-&gt;Input Manager里添加和更改。 GetAxis()的返回值是float范围为[-1,1]。表示轴的正向和到负向。通过返回值配合Vector3向量类可以得到和xz平面平行的任意方向。 float h = Input.GetAxis(&quot;Horizontal&quot;); float v = Input.GetAxis(&quot;Vertical&quot;); Vector3 moveDirection = new Vector3(h,0,v); 当然这个获取的是我们的输入方向，同时也包括了一定的距离（速度）。如果想要有一种摄像机看哪里就以这个方向为基准的效果，那么方向数据就需要从摄像机取得，而GetAxis()仅仅就变成了一个速度值的含义。 float h = Input.GetAxis(&quot;Horizontal&quot;); float v = Input.GetAxis(&quot;Vertical&quot;); Vector3 moveDirection = cameras.transform.forward * v + cameras.transform.right * h; 位移得到移动的方向后就可以移动了，CharacterController提供了两种移动方法：Move()和SimpleMove()。官方对两个方法的描述为 Function Describe Move() 一个更复杂的移动函数，使用绝对$\\Delta$移动 SimpleMove() 以一个速度移动角色 说实话官方的Move描述我是看不懂。二者参数都是一个表示方向的Vector3（三维向量）。区别在于Move()将物体向方向移动，仅受碰撞约束，不应用重力。SempleMove()，以一定速度向一个方向移动，不仅受碰撞，而且会应用重力，最重要的一点，会忽略Y轴速度。个人理解是，除了自带重力效果，不能通过SempleMove()实现在Y轴的移动。 最简单的方法就是： characterController.Move(moveDirection * moveSpeed * Time.deltaTime); Time.deltaTime的含义是处理一帧所用的时间，因为画面是每帧更新，我们需要得到一帧中，物体运动的距离。$x = v_{0}t + \\frac{1}{2}at^{2}$ 旋转现在移动解决了，但是还不够。因为我们只使用移动时候会发现，角色是不会转向的，也就是我向右走时，角色还是面朝前的，所以我们还需要旋转角色来保证朝向和行动方向的一致性。 Unity使用了四元数来旋转，当然我们一开始接触的旋转都是用矩阵的，这两个会开别的坑解释的。 使用函数Quaternion类的静态函数Quaternion.LookRotation()，参数为Vector3,详细请看官方文档，这里我们只是用一个参数的版本，意思是获取Z轴转到指定方向的四元数。 用法就是将物体的transform.rotation 复制成函数的返回值就好。 transform.rotation = Quaternion.LookRotation(rotation); rotation的x、z轴和moveDirection一致，y保正为0就可以了。 跳跃下来就是有点烦的跳跃部分。 首先应该先确定自己想要的跳跃是什么样的，这里只说下只允许脚底下有碰撞物体时候才能起跳并且一下跳跃键只跳一次（一直按也只跳一下）。 首先就是跳跃是向上的一个速度，所以不能使用SempleMove()，虽然自带重力但是它忽略Y轴速度，是飞不上去的。所以只能使用Move()，其次为了保证一直按也只跳一下，获取跳跃键的方式是GetKeyDown()，最后是要判断角色是不是脚底下有东西，也就是是不是在“地上”（也可能是箱子上啊）。 要是物体向上很简单，给moveDirection的Y轴一个起跳速度值就好。但是因为Move()不适配重力，我们需要自己模拟，简单点的方法就是每帧给moveDirection的Y轴减少一个因重力因素下降的位移即可。 moveDirection -= Vector3.down * gravity * Time.deltaTime; 当然也可以按物理公式模拟更精确的。最后是判断是否可以起跳，CharacterController有一个isGrounded的属性可以用来判断脚下是不是有东西（听说有BUG，但是我还没遇到，应该是我的条件比较简单吧）。 这样，简单的起跳就完成了。 动画移动的走动，跑动动画都还简单，主要是跳跃这个动画条件，如果仅允许按一下跳一下，一直按不跳跃的逻辑来讲，只需要在离地的时候（isGrounded为假）设置jump属性为false就好了，但是要是想一直按一直跳的话，我不会，有谁会教教我。 厚脸皮贴个垃圾代码吧 using System.Collections; using System.Collections.Generic; using UnityEngine; public class UnityChanMove : MonoBehaviour { private CharacterController characterController; private Animator anime; public Camera cameras; public Chara State ; public float moveSpeed = 0.001f; public float gravity = 10.0f; public float jumpSpeed = 0.0f; Vector3 moveDirection = Vector3.zero; private void Awake() { State = new Chara(100, 0); } private void Start() { State.life = 90; characterController = this.GetComponent&lt;CharacterController&gt;(); anime = this.GetComponent&lt;Animator&gt;(); anime.SetBool(&quot;Jump&quot;, false); } // Update is called once per frame void Update() { if (characterController.isGrounded) { float h = Input.GetAxis(&quot;Horizontal&quot;); float v = Input.GetAxis(&quot;Vertical&quot;); moveDirection = cameras.transform.forward * v + cameras.transform.right * h; //moveDirection = new Vector3(h,0,v); if (Mathf.Abs(h) &gt; 0.1f || Mathf.Abs(v) &gt; 0.1f) { Vector3 rotation = moveDirection; rotation.y = 0; transform.rotation = Quaternion.LookRotation(rotation); if (Input.GetKey(KeyCode.LeftShift) || Input.GetKey(KeyCode.Joystick1Button7)) { anime.SetBool(&quot;Walk&quot;, false); anime.SetBool(&quot;Run&quot;, true); moveDirection *= moveSpeed * 2; } else { anime.SetBool(&quot;Run&quot;, false); anime.SetBool(&quot;Walk&quot;, true); moveDirection *= moveSpeed; } } else { anime.SetBool(&quot;Run&quot;, false); anime.SetBool(&quot;Walk&quot;, false); } if (Input.GetKeyDown(KeyCode.Joystick1Button1) || Input.GetKeyDown(KeyCode.Space)) { Debug.Log(&quot;No Available Anime&quot;); anime.SetBool(&quot;Jump&quot;, true); moveDirection.y = jumpSpeed; } } else { anime.SetBool(&quot;Jump&quot;, false); } moveDirection -= Vector3.down * gravity * Time.deltaTime; characterController.Move(moveDirection * moveSpeed * Time.deltaTime); } } 记得CharacterController的参数也是有用的，调一调也是可以少写一点东西的。 Rigidbody刚体，使挂载刚体的物体受物理引擎控制，可以接受力和力矩。 属性 Property: Function: Mass 质量 Drag 空气阻力 Angular Drag 扭矩空气阻力 Use Gravity 是否应用重力 Is Kinematic 是否开启运动学 Interpolate 插值，当刚体抖动时候调一下这个 Collision Detection 碰撞检测，用来防止物体运动过快而没有检测到碰撞 Constraints 约束，位移和旋转的约束，打勾表示锁定这个值 Info 详细信息 从属性上看，可见这个刚体真的很物理。当然刚体使不带碰撞，通常带刚体也会带一个碰撞组件。但是要注意，因为刚体真的很=物理，胶囊碰撞给角色的时候可能会站不稳。 获取输入和CharacterController一样就好。 位移一旦物体绑上了刚体，就不能通过普通的Transform来进行位移，需要通过刚体(Rigidbody)的transform来进行位移。 Rigidbody.transform.position; Rigidbody.transform.rotation; 而刚体还有一个方法也可以实现位移，Move Position() 参数使一个Vector3，表示要移动到的位置，如我们想从现在位置，向moveDirection移动|moveDirection|距离，则可以： Rigidbody.MovePosition(Rigidbody.position + moveDirection); 旋转旋转方向和上面CharacterController一样，还是要注意一点是要用刚体的rotation属性不是物体自己的，而且依然是个四元数。 跳跃刚体的跳跃就比CharacterController简单很多，因为刚体自身就自带个很“真实”的物理系统，而且最重要的，刚体可以接受力和力矩。这就意味这我们想一下平时怎么跳就好了。刚体有一个AddForce()的方法，参数是Vector3，表示力的方向，大小就是|Vector3|。如想要以力Force起跳，就可以 Rigidbody.AddForce(Vector3.up * Froce); 这样就能跳起来并且还受重力会自己掉下来。如果发现加力了还不动，尝试大力，不要忘记刚体第一个参数是质量。 AddForce()还有个重载方法，第一个参数还是Vector3，第二个参数是个枚举类型ForceModeForceMode | Function————-|————— Force | 给一个持续的力 Impulse| 给一个瞬时的力 VelocityChange | 给一个瞬时的加速度，忽略质量 Acceleration | 给一个持续的加速度，忽略质量 这样一来基本上的高中运动学就都可以表示了。物理方面刚体还是很好用的，但是一定要和碰撞体一起使用，这就会导致有的地形他自己就倒了，或是倾斜了，这时候锁定刚体的rotation可以解决。 当然，接下来就是落地检测了，刚体不像角色控制器那样有个落地属性来判断，所以就需要自行检测，常见方法是向下方发出一条固定长度的光线，若光线有碰撞则说明落地。使用Physics.Raycast()方法就可以。这个函数重载很多详细看RayCast的文档吧，这里说一个三个参数的例子，第一个是Vector3，表示光线的出发点，第二个也是Vector3，表示光线法向，第三个是float表示光线长度，返回值是bool表示时候碰撞到物体。简单用法为 bool isGrounded = Physics.Raycast(transform.position, Vector3.down, 0.2f); 表示物体中心位置向下方发出一条长0.2的光线。 动画和Controller一样。 不要脸的代码来了 using System.Collections; using System.Collections.Generic; using UnityEngine; public class RigidbodyMove : MonoBehaviour { public Camera cameras; private Animator anime; private Rigidbody player; public float moveSpeed = 0.1f; public float jumpForce = 0f; private CapsuleCollider capsuleCollider; private Vector3 pointBottom, pointTop; public float radius; bool isOnGround = true; // Start is called before the first frame update void Start() { anime = GetComponent&lt;Animator&gt;(); player = GetComponent&lt;Rigidbody&gt;(); capsuleCollider = GetComponent&lt;CapsuleCollider&gt;(); } // Update is called once per frame void FixedUpdate() { float h = Input.GetAxis(&quot;Horizontal&quot;); float v = Input.GetAxis(&quot;Vertical&quot;); if (Mathf.Abs(h) &gt; 0.01f || Mathf.Abs(v) &gt; 0.01f) { // Vector3 moveDirection = new Vector3(h, 0, v); Vector3 moveDirection = cameras.transform.forward * v + cameras.transform.right * h; Vector3 rotationDirection = cameras.transform.forward * v + cameras.transform.right * h; rotationDirection.y = 0; if (Input.GetKey(KeyCode.LeftShift) || Input.GetKey(KeyCode.Joystick1Button7)) { anime.SetBool(&quot;Walk&quot;, false); anime.SetBool(&quot;Run&quot;, true); player.MovePosition(player.position + moveDirection * moveSpeed * 2); player.transform.rotation = Quaternion.LookRotation(rotationDirection); } else { anime.SetBool(&quot;Run&quot;, false); anime.SetBool(&quot;Walk&quot;, true); player.MovePosition(player.position + moveDirection * moveSpeed ); player.transform.rotation = Quaternion.LookRotation(rotationDirection); } } else { anime.SetBool(&quot;Run&quot;, false); anime.SetBool(&quot;Walk&quot;, false); } bool isGrounded = Physics.Raycast(transform.position, Vector3.down, 0.2f); if (isOnGround) { if (Input.GetKey(KeyCode.Space) || Input.GetKey(KeyCode.Joystick1Button1)) { isOnGround = false; anime.SetBool(&quot;Jump&quot;, true); player.AddForce(Vector3.up * jumpForce,ForceMode.Impulse); else { anime.SetBool(&quot;Jump&quot;, false); } } } } 补充实际上不管是RayCast()还是iSGrounded都会有判断失误的情况，导致即使触地也没办法起跳。这里还有一个想法，就是使用AnimatorStateInfo，通过AnimatorStateInfo.normalizedTime 和AnimatorStateInfo.IsName来判断某个动画播放到了什么时候。通常我们都是要求动画做出落地动作角色就肯定是在地上的。那么就可以通过这点来判断角色是否在地上。 这样就可以编写isGround()函数来判断是否在地上。 bool isGround() { AnimatorStateInfo info = anime.GetCurrentAnimatorStateInfo(0); if (info.IsName(&quot;jump_medium_up@loop&quot;) || info.IsName(&quot;jump_medium_Down@loop&quot;)) return false; return true; } 这个意思就是如果播放的动画不是跳跃动画，那么就在地上。这里是没有要求角色跳起来也可以攻击的情况下。否则if的逻辑应该是其他的。 Last这里也只是简单的说明一个可用的方案，肯定还有更多更好的方案，实际项目中能用的。 下一个坑会是什么呢？","categories":[{"name":"Unity","slug":"Unity","permalink":"/categories/Unity/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"你说这知识咋就不进脑子呢","slug":"你说这知识咋就不进脑子呢","permalink":"/tags/你说这知识咋就不进脑子呢/"},{"name":"笔经面经凉凉经","slug":"笔经面经凉凉经","permalink":"/tags/笔经面经凉凉经/"}],"keywords":[{"name":"Unity","slug":"Unity","permalink":"/categories/Unity/"}]},{"title":"2020字节跳动校园招聘算法方向第三场考试 凉凉经","slug":"2020字节跳动校园招聘算法方向第三场考试 凉经","date":"2020-05-10T16:00:00.000Z","updated":"2020-05-11T06:58:27.477Z","comments":true,"path":"2020/05/11/2020字节跳动校园招聘算法方向第三场考试 凉经/","link":"","permalink":"/2020/05/11/2020字节跳动校园招聘算法方向第三场考试 凉经/","excerpt":"","text":"2020字节跳动校园招聘算法方向第三场考试 凉凉经第一题 字符串问题有个简单的编辑器，有4种命令：1 k 表示将字符串k插入到后面 2 k 表示删除后k个字符 3 k 表示输出第k个字符 4 表示撤销上次操作，指的是撤销1 2 操作。 这个其实很简单，就是字符串操作，撤销可以用个栈来维护之前1 2 的操作， 感觉数据很水所以很好过。 #include&lt;iostream&gt; #include&lt;string&gt; int main() { std::string str, laststr; int n; std::cin &gt;&gt; n; for (int i = 0; i &lt; n; ++i) { char cmd; std::cin &gt;&gt; cmd; switch (cmd) { case &#39;1&#39;: { std::string add; std::cin &gt;&gt; add; laststr = str; str += add; break; } case &#39;2&#39;: { int k; std::cin &gt;&gt; k; laststr = str; str.erase(str.end() - k, str.end()); break; } case &#39;3&#39;: { int k; std::cin &gt;&gt; k; std::cout &lt;&lt; str[k-1] &lt;&lt; std::endl; break; } case &#39;4&#39;: { str = laststr; break; } default: break; } } system(&quot;pause&quot;); return 0; } 第二题原题说给一篇文章，再给本词典，问有多少种翻译。不能翻译输出0 实际上是给一个字符串，再给个单词表，问有多少种划分能使每个部分都是单词表里的。例： &quot;abcba&quot; ab ba bc ca cb a 总共有两种划分方法 ab | cb | a a | bc |ba 说实话这个题除了暴力枚举我想不到别的做法，感觉像DP但是又不会DP 我暴力样例过了但是。。肯定超时对不对啊，不会优化了。 不要脸的贴代码了 #include&lt;iostream&gt; #include&lt;unordered_map&gt; #include&lt;string&gt; #include&lt;algorithm&gt; long long res; const long long mod = 835672545; int maxLen = 0; void find(std::string &amp;passage, std::unordered_map&lt;std::string, bool&gt; &amp;map, int index) { if (index &gt;= passage.size()) { ++res; res %= mod; return; } for (int i = index + 1; i &lt;= passage.size() &amp;&amp; (i - index) &lt;= maxLen; ++i) { std::string sub = passage.substr(index, i - index); if (map.find(sub) != map.end()) { find(passage, map, i); } } } int main() { std::string passage; std::cin &gt;&gt; passage; int n; std::cin &gt;&gt; n; std::unordered_map&lt;std::string, bool&gt; map; for (int i = 0; i &lt; n; ++i) { std::string temp; std::cin &gt;&gt; temp; map[temp] = true; maxLen = std::max(maxLen, (int)temp.size()); } find(passage, map, 0); std::cout &lt;&lt; res &lt;&lt; std::endl; system(&quot;pause&quot;); return 0; } 第三题有个人有n只袜子，每只袜子颜色为c_i，每只袜子也有编号，接下来m天要穿编号为a_i和b_i的袜子，因为两只袜子要一样颜色，所以这个人会提前染色，问接下来m天，最少染色次数。 读完题我是懵逼的，干啥呢这人。这里感觉还是DP但是又不会DP; 格式：先输入n袜子数n和天数m，然后接下来一行有n个数，第i个数代表编号为i的袜子颜色为c_i样例： 3 2 1 2 3 1 2 2 3 最少染色两次。 有个枚举思路是，一但两只袜子颜色不同那么必定要染色，那么就有两种情况，要么第一只染成第二只颜色，要么反过来，这样每天如果要染色就有两种情况，递归求解就好。 然而这里有一点，递归次数肯定不是m次，所以需要先保存每天要穿的袜子编号，然后再递归。 没错我就错在这里，哈哈哈哈哈哈哈哈哈哈，淦！ 修改后不知道能不能过，反正现在我不要脸的贴出来了。 #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; int res = 0x3f3f3f3f; void GetDown(std::vector&lt;int&gt; &amp;color, std::vector&lt;std::pair&lt;int, int&gt;&gt; &amp;day, int m, int sum) { if (m == 0) { res = std::min(res, sum); return; } int a = day[day.size() - m].first; int b = day[day.size() - m].second; if (color[a] != color[b]) { sum++; int temp = color[a]; color[a] = color[b]; GetDown(color,day, m - 1, sum); color[a] = temp; temp = color[b]; color[b] = color[a]; GetDown(color, day, m - 1, sum); color[b] = temp; } else { GetDown(color, day, m - 1, sum); } } int main() { int n, m; std::cin &gt;&gt; n &gt;&gt; m; std::vector&lt;int&gt; color(n + 1); std::vector&lt;std::pair&lt;int,int&gt;&gt; day(m); for (int i = 1; i &lt;= n; ++i) std::cin &gt;&gt; color[i]; for (int i = 0; i &lt; m; ++i) std::cin &gt;&gt; day[i].first &gt;&gt; day[i].second; int sum = 0; GetDown(color, day, m, sum); std::cout &lt;&lt; res &lt;&lt; std::endl; system(&quot;pause&quot;); return 0; } 第四题说实话看不懂忘了，找最长连续子序列并且要求序列中是完全平方数。 对我不懂完全平方数。 瞎扯经过这么多次笔试，现在感觉没有以前那种抓瞎的感觉了。（题做多了）虽然这次实习基本凉凉，但是有了方向，秋招好好准备！ 这里顺便测试下不用CDN的封面效果","categories":[{"name":"吐槽","slug":"吐槽","permalink":"/categories/吐槽/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"你说这知识咋就不进脑子呢","slug":"你说这知识咋就不进脑子呢","permalink":"/tags/你说这知识咋就不进脑子呢/"},{"name":"笔经面经凉凉经","slug":"笔经面经凉凉经","permalink":"/tags/笔经面经凉凉经/"}],"keywords":[{"name":"吐槽","slug":"吐槽","permalink":"/categories/吐槽/"}]},{"title":"光照与材质","slug":"Light&Matrial","date":"2020-05-07T16:00:00.000Z","updated":"2020-07-15T15:13:54.950Z","comments":true,"path":"2020/05/08/Light&Matrial/","link":"","permalink":"/2020/05/08/Light&Matrial/","excerpt":"","text":"就是简单记录一下比较基础的Light(光照)没有光照，我们就基本看不见物体（自发光除外），光线是表现物体最最重要的。人类视觉对世界的感知可以说就是光线和材质的交互。所以，只要模拟物理规律，构建出合适的光照模型，就可以获得许多效果更好的场景。 Matrial(材质)材质可以说是体现物体质感的性质。他是透明的，不透明的，光滑的，粗糙的，金属质感，玻璃质感。在有光的条件下，光线与材质交互形成了我们看见的物体的样子。 万物皆是数学，再了解光线作用的前提下，我们可以把材质用数学来抽象表现。 材质大致可以抽象为： 反射光的颜色 吸收光的颜色 折射率 反射率 光滑度 透明度 发光度 为了艺术感，还可以添加其他影响视觉的属性。 只要用光线和这些属性进行数学运算，就可以得到射入我们眼睛里的光线的属性，来形成我们看到的画面。 再说光照实现前，我们了解一些概念，后面到时候也会说，可以返回来再看。 光照模型光照模型分为局部光照模型和全局光照模型。 局部光照模型：使用这种模型，每个物体的光照都是独立的，也就是在处理每个物体的光照时候，只考虑光源的光线即可。 全局光照模型：这种模型不仅要考虑光源射出的光线，同时还要考虑来自场景内其他物体反射、折射来的光线。 朗伯余弦定律光也是一种辐射，具有能量。光源每秒发出的光能量成为辐射通量。我们用单位面积上的辐射通量密度来确定表面某区域接受的光量，也就是我们看见的明亮程度。 朗伯余弦定律: L \\cdot n = cos \\theta指的是一个区域内的辐射强度相当于受到垂直光照的面积的辐射强度按照比例$cos\\theta$进行缩放。$cos\\theta$就是光向量和平面法向量n的点乘。只要在使用适当的函数钳位一下，就可以保证强度在0~1范围内，当然HDR是可以超过1的。 我们设$A$为垂直入射光照面积。则夹角为$cos\\theta$入射光的面积为 A^{'} = \\frac{A} {cos\\theta} = \\frac{A} {L·n}通过这个公式我们就解决了光的反射后强度的问题。 漫反射作为最常见的反射类型，只要表面粗糙就会产生漫反射。当某个方向的光线射到一个物体上时，其中会被吸收一部分，剩下的由于各点的法线方向不一致，造成反射光线向不同的方向无规则地反射。（初中物理） 当然，为了简化模型，我们假设光在入射点处均匀反射到每个方向，所以表面上点的颜色在任何位置观察都是一样的。 为了计算漫反射，我们需要光照颜色和漫反射反照率(Diffuse Albedo)颜色，其中漫反射反照率表示的是根据表面的漫反射率反射的入射光的光量。这里就需要用向量的分量乘法。 c = a * b = (x_{a} * x_{b},y_{a} * y_{b},z_{a} * z_{b})设光照颜色为$C{i}$，漫反射颜色为$D$，$L{i}$为物体上点$Q$指向光源位置$P$的向量，计算有i个光源的场景中的物体的漫反射光颜色$C$为： C = C_{i} * D * max( L_{i}*N,0)这是就是lambert漫反射中最重要的部分。 镜面反射同样也是很常见的反射类型，冰面，水面都会发生这种反射。镜面反射发生是因为菲涅尔效应（Fresnel Effect）而产生的现象。当光线从一种介质射入另一种介质时，因为两种介质折射率不同，一部分光被反射，另一部分发生折射。（初中物理）如果折射光沿着折射向量从介质射出并进入观察者眼睛，则物体看起来就是透明的。 这里我们依然只考虑不透明物体，所以通常情况下，我们看到的物体为镜面反射和漫反射共同组成的，同时镜面反射只针对特定范围内的角度，随着观察者位置移动，镜面反射的光量也在变化。 菲涅尔效应有菲涅尔效应的出的菲涅尔方程表述了反射光的强度、折射光的强度、相位与入射光的强度的关系。简单地可以说反射光量和材质以及法线与光向量的夹角有关。当然，物理上这个公式挺复杂的，不会用于实时计算，一般简化公式替代。 书中使用了石里克近似（Schlick approximation）： R_{F}(\\theta_{i}) = R_{F}(0\\degree) + (1 - R_{F}(0\\degree))(1-cos\\theta_{i})^{5}其中$cos\\theta_{i}$由之前的朗伯余弦定律可以得出，即$L \\cdot n$，其中L是反射点和观察者眼睛之间的向量，n为平面法线。 $R{F}(\\theta)$是介质的一种属性，$R{F}(\\theta{i})$表示角度为$\\theta{i}$下材质的属性的值。$R{F}(0\\degree)$表示在光线垂直照射材质时的属性值。书中给出了几种材质的$R{F}(0\\degree)$ 介质 $R_{F}(0 \\degree)$ 水 (0.2,0.2,0.2) 玻璃 (0.08,0.08,0.08) 塑料 (0.05,0.05,0.05) 金 (1.0,0.71,0.29) 银 (0.95,0.93,0.88) 铜 (0.95,0.64,0.54)F 另一种表现 同时还有一种公式表现： $$ Fresnel = FresnelBase + FresnelScale * 1 - N \\cdot V^{FresnelIndensity} $$ 形式上来讲和第一个一模一样，但是第一个使用的$R_{F}(\\theta)$属性是一个三维向量，正好可以表示光的颜色，而第二个公式可以看出最后的答案是一个数，而不是光的颜色。所以这里还有一个插值操作，这里用HLSL语法表述。 $$ col.rgb += lerp(col.rgb, FresnelColor, Fresnel) * FresnelColor.a $$ 其中，col.rgb是纹理采样后归一化（0~1）的颜色值乘上光源颜色后的值。在这个值的基础上加上根据Fresnel在col.rgb到FresnelColor上插值的值乘上FresnelColor的alpha值后的值。（绕死啦！！！） 这样就得到了反射光线的值。 同时，对于导体，如金属，它们菲涅尔效应很小很小。 当然，还没有完，这个只计算了一部分我们需要的东西。 表面粗糙度了解了镜面反射和漫反射，就基本可以描述材质的粗糙程度了。因为现实中几乎没有绝对平整的平面。粗糙度几乎不可能为零，所以我们认为理想镜面的粗糙度是0。为了描述粗糙度，我们依然用微平面的概念来描述。（和初中还是高中一样来着？） 也就是说一个表面由无数个微平面构成，这些微平面都拥有着自己的法线，这个法线可以由入射光线L和观察向量v相加得到。即$h = normalize(L + v)$（当然法线一般都归一化）。这样我们就可以通过确定拥有这样的法线的平面占所有微平面的比例，来得到镜面反射的强度。这样的平面越多，镜面反射越强烈。 书中接下来引入了微平面法线h与宏观平面法线n的夹角$\\theta{h}$。并定义了归一化函数$\\rho(\\theta)\\in[0,1]$来表示h，n和$\\theta{h}$的分布情况。 \\rho(\\theta_{h}) = cos^{m}(\\theta_{h}) = (n \\cdot h)^{m} 这里我们期望当$\\theta$越来越小时，$\\rho$越接近最大值。所以这里选用了cos函数。其中m控制的是粗糙度,实际上m的值越大，函数值越小，也就是镜面反射强度越小（书上错了！）。 同时引入了一个归一化因子$\\frac{m+8}{8}$。,然后就有了一个新函数$S(\\theta_{h})$ S(\\theta_{h}) = \\frac{m+8}{8}cos^{m}(\\theta_{h}) = \\frac{m+8}{8}(n \\cdot h)^{m}所以这里开始可以计算我们的镜面反射了。 首先我们需要计算观察向量上的反射光量。 max(L \\cdot n , 0) * B_{L}接着因为菲涅尔效应，会有一个$R{F}(\\theta{i})$需要计算，同时还因为粗糙度原因，还需要乘上粗糙粗。也就是： R_{F}(\\theta_{i}) * \\frac{m+8}{8} * (h \\cdot n)^{m}设经漫反射光量为$c{s}$,则$c{s}$为： c_{s} = max(L \\cdot n , 0) * B_{L} * R_{F}(\\theta_{i}) * \\frac{m+8}{8} * (h \\cdot n)^{m}环境光这里讨论一个实际上也挺重要的光照但是在这里几乎被我们忽略的光照————环境光照。 环境光照就是由其他物体反射、折射后照到我们要计算的物体上的光照的集合。听描述就知道这种光照极其复杂，和场景内其他物体性质和数量均有关系，一般情况下对实时光照负担很大。于是我们选择使用一个项，来假装我们考虑了环境光照。设环境光照为$c_{a}$ c_{a} = A_{L} * m_{d}其中$A{L}$表示入射的环境光的光量，$m{d}$根据表示漫反射率而反射的入射光量。 光照模型总结也就是说，我们最后的光照模型中需要考虑的光照有3种，漫反射光照$c{d}$，镜面反射光照$c{s}$和环境光照$c_{a}$。则最后的光照C则为： C = c_{d} + c_{s} + c_{a} \\\\ = A_{L} * m_{d} + max(L \\cdot n , 0) * B_{L} * （m_{d} + R_{F}(\\theta_{i}) * \\frac{m+8}{8} * (h \\cdot n)^{m}） Column A Column B L 光源的光向量 n 宏观平面法线 h 微观平面法线 $A_{L}$ 入射光的环境光量 $B_{L}$ 入射光的直射光量 $m_{d}$ 根据表面漫反射率而反射的入射光量 $\\theta_{i}$ h和L的夹角 $R{F}(\\theta{i})$ 菲涅尔效应 m 表面粗糙度 $\\frac{m+8}{8}$ 镜面反射的归一化因子 小吐槽扯了这么多说白了就是我们看到的都是光！我们只要想办法把射入我们眼睛的光描述出来就是我们看到的画面。而现实中的物体对光有不同程度的作用，要得到看到的光我们还需要描述计算这些作用。所以有了一大堆的光学知识。 而这些影响光的属性很多都是一样的，不同材质的物体大体都是属性值不同，所以通过描述影响光的属性值就可以来描述材质。差不多就是这个意思吧。 材质实现由上文可知，材质必要的属性有，漫反射反照率（漫反射率），菲涅尔效应用到的$R_{F}(0\\degree)$属性和粗糙粗。也就是说最基本的材质应该有： struct{ XMFLOAT4 DiffuseAlbedo; //漫反射率 XMFLOAT3 FresnelR0; // int Roughness; //粗糙度 }; 当然这些是应该有的，还可以包含名字、索引，等其他属性。同时关于粗糙度，可以设置为0~1范围内，然后就可以设置一个上限值来限制。书中给出的实现例子如下： struct Material { // Unique material name for lookup. std::string Name; // Index into constant buffer corresponding to this material. int MatCBIndex = -1; // Index into SRV heap for diffuse texture. int DiffuseSrvHeapIndex = -1; // Index into SRV heap for normal texture. int NormalSrvHeapIndex = -1; // Dirty flag indicating the material has changed and we need to update the constant buffer. // Because we have a material constant buffer for each FrameResource, we have to apply the // update to each FrameResource. Thus, when we modify a material we should set // NumFramesDirty = gNumFrameResources so that each frame resource gets the update. int NumFramesDirty = gNumFrameResources; // Material constant buffer data used for shading. DirectX::XMFLOAT4 DiffuseAlbedo = { 1.0f, 1.0f, 1.0f, 1.0f }; DirectX::XMFLOAT3 FresnelR0 = { 0.01f, 0.01f, 0.01f }; float Roughness = .25f; DirectX::XMFLOAT4X4 MatTransform = MathHelper::Identity4x4(); }; 光源由于光源类型不同，表现出来的效果也有可能不同，所以为了更好的效果表现，对于不同类型的光源也需要建模。 平行光平行光又称方向光源（Directional Light）是最简单的光源，而最简单的例子就是太阳。因为每条光线彼此平行互不相交，而且一般认为光远离物体很远，不考虑能量衰减，所以我们可以直接用一个向量来描述。 点光源点光源也是最常见的光源之一，最简单的例子就是灯泡。点光源向四面八方无死角的均匀的辐射光。对于点光源的光线方向，任一点P到光源Q的方向为： L = \\frac{Q - P}{||Q - P||}但是点光源与平行光不同的是，点光源的能量是会衰减的。物理上光强(I)是和距离(d)的平方成反比的关系。 I = \\frac{I_{0}}{d^{2}} 另一种表示 这种衰减表示涉及量比较多，包含三个常量，距离衰减常量($c{d}$),一次（线性）衰减常量($c{1}$)和二次衰减常量($c_{2}$),和一个变量距离(d)。公式为： C = \\frac{1.0}{c_{d}+c_{l} * d + c_{q} * d^{2}} C_{0}&lt;/details&gt;但是由于以上公式比较复杂（又乘又除的），于是选择简化操作，使用线性衰减。 I = saturate(\\frac{d_{max}-d}{d_{max}-d_{min}})其中，saturate函数表示把值限制在[0,1]范围内，$d{max}$表示光衰减到0的最小距离（光能到达的最大距离） $d{min}$表示光开始衰减的距离，d表示要计算的点到光源的距离。 这个衰减的值是需要乘在入射光($B{L}$)上的。当然光源光强越强，$d{max}$越大，光射的越远。如果一个物体到光源的距离大于$d_{max}$，则这个物体不受光照。 聚光灯光源聚光灯的话，首先想到的可能是舞台上的那种啪的一打，一个圆光就打在了主角身上的那种。聚光灯实际上是由聚光灯光源Q向方向d发出的一个圆锥体的光线。同时，光线强度应该由中心向四周逐渐减弱，为了实现这个，设聚光灯中心射出的那条光向量为d，最大照射的角度为$\\phi_{max}$。我们需要有一个函数来根据角度控制光强衰减。和角度有关的一般都是我们万能的三角函数啦！我们希望当$\\phi$为0时，也就是中心那根光线强度最强，所以还是使用cos函数。 K_{spot} = max(cos\\phi,0)^{s} \\\\ = max(-L \\cdot d,0)^{s}这里的表示方法和表面粗糙度中的$\\rho函数如出一辙$，只不过这里的s表示光源聚合度，s越大，聚合度越小。 光源实现关于光源，由上文可知，不同光源会有不同变量需求，综合起来可以由一下结构体表示： struct Light { DirectX::XMFLOAT3 Strength = { 0.0f, 0.f, 0.0f }; float FalloffStart = 1.0f; // point/spot light only DirectX::XMFLOAT3 Direction = { 0.0f, -1.0f, 0.0f };// directional/spot light only float FalloffEnd = 10.0f; // point/spot light only DirectX::XMFLOAT3 Position = { 0.0f, 0.0f, 0.0f }; // point/spot light only float SpotPower = 64.0f; // spot light only }; 注意的是，强度肯定都要给，平行光只需要设置Direction，聚光灯下，Position和SpotPower变量也需要调整，而Direction默认即可。点光源不需要指定Direction但根据应用地点，position需要制定。至于衰减起始和结束位置按需要设置。 当然这都只是最基本的，更具实际需求还可以增加或删除变量来达到目的。 挖个坑，看什么时候总结个PBR","categories":[{"name":"渲染 图形学","slug":"渲染-图形学","permalink":"/categories/渲染-图形学/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"你说这知识咋就不进脑子呢","slug":"你说这知识咋就不进脑子呢","permalink":"/tags/你说这知识咋就不进脑子呢/"}],"keywords":[{"name":"渲染 图形学","slug":"渲染-图形学","permalink":"/categories/渲染-图形学/"}]},{"title":"腾讯暑期实习生招聘-常规批-软件开发综合凉凉经凉凉经","slug":"腾讯笔试凉经","date":"2020-04-25T16:00:00.000Z","updated":"2020-07-15T13:44:29.102Z","comments":true,"path":"2020/04/26/腾讯笔试凉经/","link":"","permalink":"/2020/04/26/腾讯笔试凉经/","excerpt":"","text":"腾讯暑期实习生招聘-常规批-软件开发综合凉凉经写在前面：这次代码有点乱，我觉得我应该是贴对了。 没错！我现在厚颜无耻的，恶心人的代码，没过的代码也不打算藏了，我就是要不要脸！！！ 第一题 实现队列要求实现“PUSH”，“POP”，“TOP”，“CLEAR”，“SIZE”。 POP不取得数据，无法POP时输出-1。TOP无数据时候输出-1，有数据输出队首。 这里看着真的是很简单，实际上也是简单。这里我一开始想着用vector的思路去写了，没注意到它的操作数最大是1000个操作。然后在另外开辟内存这里可能有点问题，导致总是过不去（看来真的需要看一眼源码了）。最后还是开了个大于操作数的数组来实现，最后过了。 这里贴一下代码吧。其实挺恶心的代码。 #include&lt;iostream&gt; #include&lt;string.h&gt; #include&lt;string&gt; struct Queue { int size; int* front; int* back; int* end; int element[2000]; //int* element; //int capicity; Queue() { this-&gt;size = 0; //capicity = 5; //element = new int[5]; back = front = element; //end = element + 5; } void push(int num) { *back=num; ++back; ++size; // if (back == end) // { // int* temp = new int[2 * capicity]; // memmove(temp, element, sizeof(int)*size); // capicity *= 2; // int* it = element; // element = temp; // front = element; // back = front + size; // *back = num; // back++; // end = element + capicity; // delete[] it; // } // else // { // *back = num; // back++; // } // size++; } void pop() { if (front == back) { std::cout &lt;&lt; -1 &lt;&lt; std::endl; return; } front++; size--; } int top() { if (front == back) return -1; return *front; } void clear() { front = back; size = 0; } int Size() { return this-&gt;size; } void distory() { delete[] element; } }; int main() { int t, n; std::cin &gt;&gt; t; while (t--) { Queue q; std::cin &gt;&gt; n; std::string s; int num; for (int i = 0; i &lt; n; ++i) { std::cin &gt;&gt; s; if (s == &quot;PUSH&quot;) { std::cin &gt;&gt; num; q.push(num); } else if (s == &quot;POP&quot;) q.pop(); else if (s == &quot;TOP&quot;) std::cout &lt;&lt; q.top() &lt;&lt; std::endl; else if (s == &quot;SIZE&quot;) std::cout &lt;&lt; q.Size() &lt;&lt; std::endl; else if (s == &quot;CLEAR&quot;) q.clear(); } q.distory(); } system(&quot;pause&quot;); return 0; } 第二题 点对间最短距离给出一个集合A，里面又坐标点（x,y），在给出一个集合B里面也有一些点。求这两个集合的点对之间的最短距离（欧式距离）。 这个题，说实话一开始想到的是平面内点对最小距离那个题，但好像思路不是很对。最后直接暴力了，但是很奇怪，暴力为什么是过0%且超时。好像应该是着急i，j写错了。 到时候再看看有没有什么好方法。 #include&lt;iostream&gt; #include&lt;cmath&gt; #include &lt;iomanip&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; int main() { std::vector&lt;std::pair&lt;int, int&gt;&gt; A; std::vector&lt;std::pair&lt;int, int&gt;&gt; B; std::vector&lt;double&gt; res; int t; std::cin &gt;&gt; t; while (t--) { int n; std::cin &gt;&gt; n; for (int i = 0; i &lt; n; ++i) { int x, y; std::cin &gt;&gt; x&gt;&gt; y; A.push_back(std::make_pair(x, y)); } for (int i = 0; i &lt; n; ++i) { int x, y; std::cin &gt;&gt; x&gt;&gt; y; B.push_back(std::make_pair(x, y)); } for (int i = 0; i &lt; A.size(); ++i) { for (int j = 0; j &lt; B.size();j++) { long long x = (A[i].first - B[j].first) * (A[i].first - B[j].first); long long y = (A[i].second - B[j].second) * (A[i].second - B[j].second); res.push_back(std::sqrt((x + y))); } } std::sort(res.begin(), res.end()); std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(3) &lt;&lt; res[0] &lt;&lt; std::endl; } return 0; } 第三题 翻牌子（DP？）给出一组纸牌，正面有ai，背面是bi，每次操作可以交换相邻两个牌，然后翻面，求是一组牌非降序排列的最少次数。 这个题吧，好像也在哪里见过，类似的一个将一个数组通过交换变成按升序排列。但是，嘿嘿嘿，我忘了。 有时间再做一下把。 第四题 两个栈实现队列这个不知道是哪里得原题吧？？？就是用两个栈实现队列操作。 思路简单，准备两个栈in和out，如果有push直接压入in，当有top和pop时，如果out为空，再将in压入out，否则直接返回out或pop out。 这个题我可能也是侥幸，因为第一次交75%超时，手抖了一下又交了一遍95%超时，再交一回，过了！ 玄学 #include&lt;iostream&gt; #include&lt;stack&gt; #include&lt;string&gt; int main() { std::stack&lt;int&gt; s1; std::stack&lt;int&gt; s2; int n; std::cin&gt;&gt;n; std::string s; for(int i=0;i&lt;n;++i) { std::cin&gt;&gt;s; if(s==&quot;add&quot;) { int num ; std::cin&gt;&gt;num; s1.push(num); } else if (s==&quot;poll&quot;) { if(!s2.empty()) s2.pop(); else { while(!s1.empty()) { s2.push(s1.top()); s1.pop(); } s2.pop(); } } else if(s==&quot;peek&quot;) { if(!s2.empty()) std::cout&lt;&lt;s2.top()&lt;&lt;std::endl; else { while(!s1.empty()) { s2.push(s1.top()); s1.pop(); } std::cout&lt;&lt;s2.top()&lt;&lt;std::endl; } } } return 0; } 第五题 二叉树给出一个无限深的满二叉树，节点标号从1开始，再给出一个节点编号x和深度k。求x在k深度的父亲节点编号，没有输出-1。 这个思路很简单，先找到x的深度d，然后比较k和d，若k小于d，向上找就行，否则就-1。 但是很神奇，牛客的样例我过了，但是交题告诉我格式不正确，再跑样例的时候就自动交卷了。（悲）！！！好像这个还要快速幂才能过。 #include&lt;iostream&gt; int main() { int t; std::cin&gt;&gt;t; long long x,k; while(t--) { std::cin&gt;&gt;x&gt;&gt;k; long long i=1,deep=1; while(i&lt;=x) { i&lt;&lt;=1; deep++; } i&gt;&gt;=1; deep--; while(deep!=k) { x&gt;&gt;=1; deep--; } std::cout&lt;&lt;x&lt;&lt;std::endl; } return 0; }","categories":[{"name":"吐槽","slug":"吐槽","permalink":"/categories/吐槽/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"你说这知识咋就不进脑子呢","slug":"你说这知识咋就不进脑子呢","permalink":"/tags/你说这知识咋就不进脑子呢/"},{"name":"笔经面经凉凉经","slug":"笔经面经凉凉经","permalink":"/tags/笔经面经凉凉经/"}],"keywords":[{"name":"吐槽","slug":"吐槽","permalink":"/categories/吐槽/"}]},{"title":"2020字节跳动校园招聘算法方向第二场考试凉凉经","slug":"字节跳动凉经","date":"2020-04-11T16:00:00.000Z","updated":"2020-04-12T14:51:53.523Z","comments":true,"path":"2020/04/12/字节跳动凉经/","link":"","permalink":"/2020/04/12/字节跳动凉经/","excerpt":"","text":"2020字节跳动校园招聘算法方向第二场考试凉凉经说到底还是自己菜，真的不行。 第一题 数组转换问题给出两个数组A，B，其中再A中找出一个区间r-l，使得这个区间的所有数都加上K后和B一样。输出A是否可以转换为B 这个挺简单的。遍历一遍，在第一个不同的地方差一下。然后用这个差去判断剩下不一致的地方差是否一样，不一样就不能，并且区间只能存在一个。出现第二个区间也不能。 这里贴一个比较菜鸡的AC代码吧，说实话代码烂的自己也看不下去。 #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;cmath&gt; int main() { int t; std::cin &gt;&gt; t; while (t--) { int n; std::cin &gt;&gt; n; std::vector&lt;int&gt; a(n); std::vector&lt;int&gt; b(n); for (int i = 0; i &lt; n; ++i) std::cin &gt;&gt; a[i]; for (int i = 0; i &lt; n; ++i) std::cin &gt;&gt; b[i]; bool flag = false, YES = true; int count = 0, diff = 0; for (int i = 0; i &lt; n; ++i) { if (a[i] != b[i]) { if (!flag) { if (count == 0) { flag = true; count++; diff = std::abs(a[i] - b[i]); } else { std::cout &lt;&lt; &quot;NO&quot; &lt;&lt; std::endl; YES = false; break; } } } if (flag) { if (a[i] == b[i]) { flag = false; continue; } if (std::abs(a[i] - b[i]) != diff) { std::cout &lt;&lt; &quot;NO&quot; &lt;&lt; std::endl; YES = false; break; } } } if (YES) std::cout &lt;&lt; &quot;YES&quot; &lt;&lt; std::endl; } system(&quot;pause&quot;); return 0; } 第二题 掰木棍 （考的二叉树？ 我也不知道，我也不理解）给出n个木棍，对于这n个木棍中，可以将任意一个掰成两半，这两半必须是整数。掰完后放回原位置，也就是说原位置左边有数，掰完后两个数都放在哪个数的右边，原位置右边有数，掰完后两个数都放在那个数的左边。求最少掰几次可以使得所有木棍不递减排列。 样例： 输入： 5 3 5 13 9 12 输出：1 因为13 可以掰成5和8，所以序列变为3 5 5 8 9 12 完成。 这个题。。说实话没啥思路。。本来想看见一个不符合升序，就把他掰成样例的格式，但是想了一下，如果有3 5 4 9 这样的序列，5变成3 2 就会成 3 3 2 4 9，就意味着2之前都要掰，然后就不知道怎么办了。有时间继续看看。 第三题 买东西（没看出来啥类型的问题）现在你有N张优惠券，当买的东西价格大于等于优惠卷面值时候可以使用，使用后不收回，还可以继续使用。问买M个东西花钱最少是多少。 这个想法就是先排序。两个都排序，从小到大。然后用买的东西去找第一个不能使用的优惠券，那么前一张优惠券就是可以使用的最大面值。如果所有优惠卷都可以用，那么久使用面值最大的优惠券来购买。 输入第一行n，m表示优惠券数和购买东西数二三行分别是优惠卷面值和购买价格（不保证排序） 样例： 输入 3 4 50 100 200 99 199 200 300 输出 248 利用这个想法实现的代码（个人写的）只过了40% 超时（我觉得我贴对代码了） 精污提醒 ```c++ #include #include #include int main() { int n, m; std::cin >> n >> m; std::deque discount(n); std::deque buy(m); for (int i = 0; i < n; ++i) std::cin >> discount[i]; for (int i = 0; i < m; ++i) std::cin >> buy[i]; std::sort(discount.begin(), discount.end()); std::sort(buy.begin(), buy.end()); long long res = 0; int i = 0 ; if (n == 0 || m == 0) { for (int i = 0; i < m; ++i) res += buy[i]; std::cout < res < std::endl; return 0; } while (!buy.empty()) { if (i >= discount.size()) { res += (buy[0] - discount[discount.size() - 1]); i = 0; buy.pop_front(); continue; } if (buy[0] >= discount[i]) i++; else { if (i == 0) res += buy[0]; else res += (buy[0] - discount[i - 1]); buy.pop_front(); i = 0; } } std::cout < res < std::endl; system(\"pause\"); return 0; } ```","categories":[{"name":"吐槽","slug":"吐槽","permalink":"/categories/吐槽/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"你说这知识咋就不进脑子呢","slug":"你说这知识咋就不进脑子呢","permalink":"/tags/你说这知识咋就不进脑子呢/"},{"name":"笔经面经凉凉经","slug":"笔经面经凉凉经","permalink":"/tags/笔经面经凉凉经/"}],"keywords":[{"name":"吐槽","slug":"吐槽","permalink":"/categories/吐槽/"}]},{"title":"网易互娱2021届实习生招聘在线笔试－游戏研发工程师 凉凉经？？","slug":"网易互娱笔试凉经","date":"2020-04-10T16:00:00.000Z","updated":"2020-05-08T08:26:09.630Z","comments":true,"path":"2020/04/11/网易互娱笔试凉经/","link":"","permalink":"/2020/04/11/网易互娱笔试凉经/","excerpt":"","text":"网易互娱2021届实习生招聘在线笔试－游戏研发工程师 凉凉经？？第一题 模拟（贪心？）题目引子是传说中的40m长刀，在一个M×M的地图上，主角手持长L的大刀，有数个道具在格子上，用刀砍掉道具可以让刀变长。主角不会移动。问游戏结束时候，主角的刀最长有多少。 输入首先是样例数T 然后是地图大小M和刀的长度L，然后是一个矩阵，矩阵中不为0的是道具，得到可以使刀加长那个数据，然后是主角坐标。样例： 6 1 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 1 0 0 0 0 0 0 0 1 0 2 1 2 答案是2 因为我在（1，2）位置，最近的是（1，3）的道具，刀为1；可以砍刀，然后刀长为2，接下来最近的是（3，3），离（1，2）有$\\sqrt{5}$的长度，大于刀长，所以最终为2. 整个题就是读入道具坐标和道具数值，然后计算道具距离主角距离。按距离从小到大排序，依次看能不能砍道就好，一个小贪心。贴出一个一般般的AC代码吧 #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; struct item { int x; int y; int distance; int weight; item() = default; item(int _x, int _y, int _weight) :x(_x), y(_y), weight(_weight) {}; }; int distance(int px, int py, int x, int y); bool distancecmp(item a, item b); int main() { int t; std::cin &gt;&gt; t; while (t--) { int m, l; std::cin &gt;&gt; m &gt;&gt; l; std::vector&lt;item&gt; v; for (int i = 0; i &lt; m; ++i) { for (int j = 0; j &lt; m; ++j) { int num; std::cin &gt;&gt; num; if (num == 0) continue; v.push_back(item(i, j, num)); } } int px, py; std::cin &gt;&gt; px &gt;&gt; py; for (int i = 0; i &lt; v.size(); ++i) { v[i].distance = distance(px, py, v[i].x, v[i].y); } std::sort(v.begin(), v.end(), distancecmp); for (int i = 0; i &lt; v.size(); ++i) { int ll = l * l; if (ll &lt; v[i].distance) { std::cout &lt;&lt; l&lt;&lt;std::endl; l = 0; break; } else l += v[i].weight; } if(l) std::cout &lt;&lt; l&lt;&lt;std::endl; } system(&quot;pause&quot;); return 0; } int distance(int px, int py, int x, int y) { int rx = px - x, ry = py - y; return rx * rx + ry * ry; } bool distancecmp(item a, item b) { return a.distance &lt; b.distance; } 第二题 并查集的问题有1——N个数，开始每个数都各自为一个集合，要求实现以下操作 给出x，y。将y并到x下面，如果两个本来就在一个集合，则什么也不做 给出x，将x拿出来单独作为一个集合，如果x本身只有一个元素，则什么也不做。 给出x，输出x所在集合元素个数。 输入首先是样例数T，然后是 数据个数n和操作数m接下来m行 第一个数OP为1时，接下来根两个数x，y。OP为2时执行操作2，OP为3时候输出元素个数。 这里其实刚做题目的时候第二个操作没看懂，如果要独立的元素时头头的话，他底下的元素是独立出N个集合？还是合并到其中一个里去？最后看样子似乎是第一种，独立出N个集合。 当时看到这个题整个人都是CNM的状态，听说7号互联网那边考了个并查集，觉得互娱不会考这个，难度应该接近雷火前两个吧。结果考了个并查集，然后我还忘了怎么压缩路径。啊！天啊！其实就是find里变了个x =find()！！！！蠢哭了自己。 这里给个垃圾的一批的70%代码吧 降智打击 ```c++ #include #include struct element { int value; std::vector next; int pre; int num; }; int find(std::vector &v, int x) { return v[x].pre == x ? x : find(v, v[x].pre); } void Union(std::vector &v, int x, int y); void cut(std::vector &v, int x); int count(std::vector &v, int x); int main() { int t; std::cin >> t; while (t--) { int n, m; std::cin >> n >> m; std::vector v(n + 1); for (int i = 1; i op; if (op == 1) { int x, y; std::cin >> x >> y; Union(v, x, y); } else if (op == 2) { int x; std::cin >> x; cut(v, x); } else if (op == 3) { int x; std::cin >> x; std::cout < count(v, x) < std::endl; } } } system(\"pause\"); return 0; } void Union(std::vector","categories":[{"name":"吐槽","slug":"吐槽","permalink":"/categories/吐槽/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"你说这知识咋就不进脑子呢","slug":"你说这知识咋就不进脑子呢","permalink":"/tags/你说这知识咋就不进脑子呢/"},{"name":"笔经面经凉凉经","slug":"笔经面经凉凉经","permalink":"/tags/笔经面经凉凉经/"}],"keywords":[{"name":"吐槽","slug":"吐槽","permalink":"/categories/吐槽/"}]},{"title":"2020米哈游春季校园招聘程序B卷凉凉经","slug":"米哈游凉经","date":"2020-04-02T16:00:00.000Z","updated":"2020-07-15T13:57:44.903Z","comments":true,"path":"2020/04/03/米哈游凉经/","link":"","permalink":"/2020/04/03/米哈游凉经/","excerpt":"","text":"2020米哈游春季校园招聘程序B卷凉凉经我草泥马自己实在是太菜了，菜死了，垃圾啊！ 第一部分 不定项选择考察下列内容 c++ 虚函数部分 操作系统 组原？ Linux fork clone exec 计算机网络 IP和一个select什么的？？？ 不了解 基本读程序 栈忘了 第二部分 正则表达式 二叉树真巧我这两个都没复习到。直接凉凉正则表达式给出一个字符串s 给出一个规则，规则包括(、)、.、,()表示必须匹配（）内字符。.表示匹配任意字符，表示匹配前面0个活多个字符。输出为s是否满足规则。 感觉好像能直接用regex？ 其实后来写了个把字符串按规则扫一遍的代码，但是。。。最后一秒也没交上去。主要他给的格式是牛客上《剑指Offer》那个格式，是个类。而个人做题还是面向过程的main函数。所以忙着看复制到哪里合适的时候，时间到了，惨 菜鸡 惨。而代码，，，不小心给覆盖掉了所以。没留底。哇，祸不单行。 二叉树一个计算机连接系统连接方式为二叉树方法，给出一个字符串，1代表有计算机，0代表没有。字符串组成只有0、1.字符串的是按BFS给出的。现在要设置监控计算机，每个监控计算机只能监控一个计算机。问，若所有计算机（监控计算机除外）都被监控，问监控计算机有多少台，若无法完成监控并没有重复监控的情况下输出0； 例：字符串为“11100111”，监控计算机为字符串位置的 1 6 7号计算机。 就是每个监控节点变成只能监控一个的监控二叉树。 说实话没啥好说的，菜的一批，啥也不会。 有时间还是返回来看。","categories":[{"name":"吐槽","slug":"吐槽","permalink":"/categories/吐槽/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"你说这知识咋就不进脑子呢","slug":"你说这知识咋就不进脑子呢","permalink":"/tags/你说这知识咋就不进脑子呢/"},{"name":"笔经面经凉凉经","slug":"笔经面经凉凉经","permalink":"/tags/笔经面经凉凉经/"}],"keywords":[{"name":"吐槽","slug":"吐槽","permalink":"/categories/吐槽/"}]},{"title":"网易游戏雷火2020春招游戏研发工程师笔试0329凉凉经","slug":"网易雷火笔试凉经","date":"2020-03-28T16:00:00.000Z","updated":"2020-04-11T14:44:20.725Z","comments":true,"path":"2020/03/29/网易雷火笔试凉经/","link":"","permalink":"/2020/03/29/网易雷火笔试凉经/","excerpt":"","text":"网易游戏雷火2020春招游戏研发工程师笔试0329凉凉经第一次笔试心里慌得很，四个小时下来膀胱快炸了也不敢离开（向夏哥看齐）。脑细一片混乱，只记得写大概。把能记得的写一下 第一题斐波那契数列问题相关。给定两个字符串F1，F2，F3=F2+F1，F4=F3+F2…………，求Fn中每个字母出现次数，F1、F2小于10；N&lt;40 这个第一眼看上去好家伙求Fn再统计嘛， string f1,f2,res; for (int i = 3; i &lt;= n; ++i) { res = f1 + f2; f1 = f2; f2 = res; } 这个会爆内存，然后就想着先统计f1,f2中个数，再用斐波那契去求。这里就用到了map。但是当时不知道怎么想的，可能觉得，呀，这么简单的怎么WA了，被吓到了，逻辑一下十分混乱。导致胡乱判断，胡乱使用函数。这里贴一下，记录下自己的SB行为。SB的地方注释见 小心污染智商 ```c++ #include #include #include #include using namespace std; int main() { int n = 0; cin >> n; string f1, f2; map mapf1; map mapf2; cin >> f1 >> f2; for(int i=0;ifirst] = it->second; else res[it->first] += it->second; } mapf1 = mapf2; mapf2 = res; temp = res; } for (auto it = temp.begin(); it != temp.end(); ++it) { cout < it->first < \":\" < it->second < endl; } return 0; } ``` m.t >> m.e; m.v = (float)m.e / m.t; monsters.push_back(m); } //注意这里。 sort(monsters.begin(), monsters.end(), cmp); int exp = 0; while (monsters.size() != 0) { // 重点来了，这里一定少点啥。 exp += monsters[0].e; monsters.erase(monsters.begin()); value(monsters, t); //对没错，少再排序，不说了，我是蠢死的 } cout < exp < endl; return 0; } ```","categories":[{"name":"吐槽","slug":"吐槽","permalink":"/categories/吐槽/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"你说这知识咋就不进脑子呢","slug":"你说这知识咋就不进脑子呢","permalink":"/tags/你说这知识咋就不进脑子呢/"},{"name":"笔经面经凉凉经","slug":"笔经面经凉凉经","permalink":"/tags/笔经面经凉凉经/"}],"keywords":[{"name":"吐槽","slug":"吐槽","permalink":"/categories/吐槽/"}]},{"title":"D3D渲染管线和Shader的一些事","slug":"Shader&HLSL","date":"2020-03-23T16:00:00.000Z","updated":"2020-04-11T14:44:27.090Z","comments":true,"path":"2020/03/24/Shader&HLSL/","link":"","permalink":"/2020/03/24/Shader&HLSL/","excerpt":"","text":"index？ Input Assembler Stage 输入装配阶段 Vertex Shader Stage 顶点着色器阶段 Tessellating Gometry Stage 镶嵌处理阶段 Hull Shader Stage 外壳着色器阶段 Tessellator Stage 曲面细分阶段 Domain shader Stage 域着色器阶段 Geometry Shader Stage 几何着色器阶段 Stream Output Stage 流输出阶段 Rasterizer Stage 光栅化阶段 Pixel Shader Stage 像素着色器阶段 Output Merger Stage 合并输出阶段 1 Input Assembler Stage 输入装配阶段这个阶段其实就是读取显存中我们存储的顶点和索引数据。按照所设置好的图元拓扑根据索引装配顶点。装配结果会被送VS（Vertex Shader） 这里从顶点的创建开始说明。 首先需要先定义顶点的结构体比如 struct Vertex { DirectX::XMFLOAT3 Pos; DirectX::XMFLOAT3 Normal; DirectX::XMFLOAT2 TexC; }; 接下来，为了让Direct3D知道怎么对待我们的数据，需要填写输入布局描述（Input Layout Description） typedef struct D3D12_INPUT_LAYOUT_DESC { const D3D12_INPUT_ELEMENT_DESC *pInputElementDescs; UINT NumElements; } D3D12_INPUT_LAYOUT_DESC; 而实际上描述布局的是其中的D3D12_INPUT_ELEMENT_DESC typedef struct D3D11_INPUT_ELEMENT_DESC { LPCSTR SemanticName; UINT SemanticIndex; DXGI_FORMAT Format; UINT InputSlot; UINT AlignedByteOffset D3D11_INPUT_CLASSIFICATION InputSlotClass; UINT InstanceDataStepRate; } D3D11_INPUT_ELEMENT_DESC; LPCSTR SemanticName：关于shader输入参数的HLSL的语义。 UINT SemanticIndex：语义的索引，用于给相同语义的变量，比如一个顶点由两组Texture，可以再不引入新语义的情况下区分他们。未指定默认为1。 DXGI_FORMAT Format：通过DXGI_FORMAT的变量来指定元素的类型。 UINT InputSlot：指定元素传入的输入槽，Direct3D支持16个（0~15）输入槽。可以通过输入槽来向输入装配阶段传递顶点数据。 UINT AlignedByteOffset：输入槽中数据的偏移量，一个结构体元素中会有多个变量，需要确定偏移量才能正确找到变量。 D3D11_INPUT_CLASSIFICATION InputSlotClass：单个输入槽的表示类。具体参照D3D12_INPUT_CLASSIFICATION UINT InstanceDataStepRate：与实例化技术有关，置为1意味着要是用实例化技术。 针对上述顶点，D3D11_INPUT_ELEMENT_DESC可填写为 { { &quot;POSITION&quot;, 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 }, { &quot;NORMAL&quot;, 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 12, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 }, { &quot;TEXCOORD&quot;, 0, DXGI_FORMAT_R32G32_FLOAT, 0, 24, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 }, }; 接下来就要准备顶点数据了。为了让GPU能得到数据，需要把顶点数据放到GPU资源（显存）中。DirectX12中使用ID3D12Resource来管理。 要创建ID3D12Resource首先需要填写D3D12_RESOURCE_DESC typedef struct D3D12_RESOURCE_DESC { D3D12_RESOURCE_DIMENSION Dimension; UINT64 Alignment; UINT64 Width; UINT Height; UINT16 DepthOrArraySize; UINT16 MipLevels; DXGI_FORMAT Format; DXGI_SAMPLE_DESC SampleDesc; D3D12_TEXTURE_LAYOUT Layout; D3D12_RESOURCE_FLAGS Flags; } D3D12_RESOURCE_DESC; D3D12_RESOURCE_DIMENSION Dimension：资源维度，使用D3D12_RESOURCE_DIMENSION 填写。 UINT64 Alignment;：没查到，一般为0。 UINT64 Width;：资源的宽度，对于缓冲区资源则是缓冲占用字节数。 UINT Height;：资源的高度。 UINT16 DepthOrArraySize;：资源深度（对于3DTexture），对于1D、2DTexture则表示数组大小。 UINT16 MipLevels：minmap的层数。 DXGI_FORMAT Format;：资源格式，使用DXGI_FORMAT填写 DXGI_SAMPLE_DESC SampleDesc;：采样器描述，使用DXGI_SAMPLE_DESC填写，实际上和多重采样（MSAA）有关，描述中设置了采样质量级别和采样次数。 D3D12_TEXTURE_LAYOUT Layout;：资源的layout，使用D3D12_TEXTURE_LAYOUT填写。 D3D12_RESOURCE_FLAGS Flags;：与资源有关的杂项标志位，使用D3D12_RESOURCE_FLAGS填写。 这里其实Direct3D 12提供了个包装类CD3DX12_RESOURCE_DESC，他派生自D3D12_RESOURCE_DESC，可以简化我们的创建过程。 填写完描述后就可以用它来再现存上开辟一块适合的空间了。创建该堆使用的是ID3D12Device::CreateCommittedResource方法 HRESULT CreateCommittedResource( const D3D12_HEAP_PROPERTIES *pHeapProperties, D3D12_HEAP_FLAGS HeapFlags, const D3D12_RESOURCE_DESC *pDesc, D3D12_RESOURCE_STATES InitialResourceState, const D3D12_CLEAR_VALUE *pOptimizedClearValue, REFIID riidResource, void **ppvResource ); const D3D12_HEAP_PROPERTIES *pHeapProperties：一个指向堆所具有的属性的指针，这里可以使用CD3DX12_HEAP_PROPERTIES 类来创建，所以一般情况只用关注D3D12_HEAP_TYPE就可以，这个类型稍后说明。 D3D12_HEAP_FLAGS HeapFlags：和堆有关的额外标志选项，参照D3D12_HEAP_FLAGS，通常使用D3D12_HEAP_FLAG_NONE/ const D3D12_RESOURCE_DESC *pDesc：一个指向D3D12_RESOURCE_DESC的指针，藐视待创建的资源。 D3D12_RESOURCE_STATES InitialResourceState：资源的初始状态。 const D3D12_CLEAR_VALUE *pOptimizedClearValue：描述一个用于清除资源的优化值，可以为NULL。 REFIID riidResource：希望获得的ID3D12Resource的接口的COM ID。 void **ppvResource：新建的资源的指针。 这里其实还有一种创建资源堆的方式ID3D12Device :: CreatePlacedResource有机会会说。 关于显存上堆的资源类型 typedef enum D3D12_HEAP_TYPE { D3D12_HEAP_TYPE_DEFAULT, D3D12_HEAP_TYPE_UPLOAD, D3D12_HEAP_TYPE_READBACK, D3D12_HEAP_TYPE_CUSTOM } ; D3D12_HEAP_TYPE_DEFAULT：默认堆，只允许GPU访问，所以速度最快。D3D12_HEAP_TYPE_UPLOAD：上传堆，向这里提交的都是要CPU上传到GPU的资源。D3D12_HEAP_TYPE_READBACK：回传堆，向这里提交的资源是需要CPU读取的资源。D3D12_HEAP_TYPE_CUSTOM：应用于高级特性。 显然，我们需要让GPU读取顶点资源，放在默认堆是比较合适的。但是CPU又不能直接访问，于是需要使用上传堆来完成顶点资源向显存的移动。这就需要创建两个堆，一个使用D3D12_HEAP_TYPE_DEFAULT一个使用D3D12_HEAP_TYPE_UPLOAD。 然后为了告诉Direct3D我们要提交什么样的数据，需要填写一个描述D3D12_SUBRESOURCE_DATA typedef struct D3D12_SUBRESOURCE_DATA { const void *pData; LONG_PTR RowPitch; LONG_PTR SlicePitch; } D3D12_SUBRESOURCE_DATA; 然后就可以使用UpdateSubresources函数来上传顶点资源了。 当然这里是CPU和GPU“一起工作”，这自然就遇到同步问题。对于D3D12，我们用资源屏障D3D12_RESOURCE_BARRIER来同步资源状态。 typedef struct D3D12_RESOURCE_BARRIER { D3D12_RESOURCE_BARRIER_TYPE Type; D3D12_RESOURCE_BARRIER_FLAGS Flags; union { D3D12_RESOURCE_TRANSITION_BARRIER Transition; D3D12_RESOURCE_ALIASING_BARRIER Aliasing; D3D12_RESOURCE_UAV_BARRIER UAV; }; } D3D12_RESOURCE_BARRIER; 然后就可以使用ID3D12GraphicsCommandList::ResourceBarrier方法来设置资源屏障。在使用资源之前和使用后都要记得同步资源属性。同样，依然有一个包装类CD3DX12_RESOURCE_BARRIER可以帮助我们简化创建操作。 当然，不是所有的顶点都会被送到默认堆上，一些需要频繁改动的对象的顶点这么操作就不合适，所以这类顶点可以就放在上传堆上。 到这里我们的数据才算是准备好了，接下在就是真正的输入装配阶段。我们需要调用三个方法来完成这个阶段 ID3D12GraphicsCommandList::IASetVertexBuffers ID3D12GraphicsCommandList::IASetIndexBuffer ID3D12GraphicsCommandList::IASetPrimitiveTopology 首先第一个方法是向渲染管线提供顶点，接下来分别是提供顶点索引和设置图元拓扑(primitive topology)。 为什么要提供顶点索引和图元拓扑，因为一堆顶点可以有许多种连接方式，而我们想要的只是其中的一种。图元拓扑就是说明顶点之间应该以什么方式进行连接。而图元拓扑从D3D_PRIMITIVE_TOPOLOGY选择。 2 Vertex Shader Stage 顶点着色器阶段图元被装配完毕后，顶点就会被送入VS(Vertex Shader)。这时候就需要使用着色器语言(Shader Language)来编写VS。VS可以实现很多东西，例如变换，光照，位移贴图等。而最多应用的就是顶点的变换处理。 我们知道3D模型的顶点都是按照局部空间的方式储存的。所以我们需要将局部空间坐标变换为世界空间坐标。而要做的只是仅仅需要给顶点坐标乘上以个世界坐标矩阵就可以了。但是这其实还不算完，我们只是将局部坐标变成了世界坐标。为了构建场景的2D图形，还需要一台摄像机，对世界坐标做取景变换(view transform)，取景变换使用的矩阵成为变换矩阵(view matrix)。最后我们需要做的就是把坐标投影到齐次剪裁空间中，就是我们得到的画面坐标。投影要做的被称为透视投影变换(perspective projection transformation)。 所以,基本的VS写法应该为:以顶点下列顶点为例 struct Vertex { DirectX::XMFLOAT3 Pos; DirectX::XMFLOAT3 Normal; ...... }; 则顶点着色器可以写成下列形式 // 定义输入顶点,应与c++文件中定义一致 struct VertexIn { // 冒号后为语义，和之前填写的输入布局描述的语义相同 float3 PosL : POSITION; float4 Color : COLOR; ...... }; // 定义输出顶点,可根据需要增加变量 struct VertexOut { float4 PosH : SV_POSITION; float4 Color : COLOR; ...... }; // 定义顶点着色器 VertexOut VS(VertexIn vin) { // 定义输出顶点 VertexOut vout; // 顶点坐标与世界矩阵相乘,局部坐标变换为世界坐标 float4 posW = mul(float4(vin.PosL, 1.0f), gWorld); // 世界坐标与观察矩阵和投影矩阵相乘,投影到齐次剪裁空间中 vout.PosH = mul(posW, gViewProj); // 顶点的颜色处理后和处理前保持一致 vout.Color = vin.Color; ...... ...... // 返回变换后顶点 return vout; } 顶点着色器会对每个顶点调用一次，但是是在GPU中进行，会并行计算，速度还是很快的。 接下来如果没有其他需求,就可以直接送入像素着色器了 3 Tessellating Gometry Stage 镶嵌处理阶段作为一个可选阶段，曲面细分阶段是渲染管线中对几何图形进行向前处理的三个阶段————外壳着色器阶段，镶嵌器阶段和域着色器阶段。这里所做的工作就是把几何体细分成更小的三角形，并以某种方式，把生成的顶点偏移到合适的位置。说白了就是在这个阶段通过几个着色器把低模变高模。 那为什么不直接使用高模？ 考虑如果一个物体距离摄像机很远，那么这个时候对于这种物体人们一般很少注意，所以，使用高模就很浪费空间，也为后面计算增加负担。在这里就可以通过距离摄像机判断是否进行和进行什么程度的镶嵌化处理。 在考虑如果一个物体根本不在视锥体（摄像机所看到的范围）内，那么就可以删除掉这部分的片面。如果是高模，这部分计算也会比较庞大，低模通过较小的代价，可以减少后续的一些计算，而且还省内存。 如果要进行曲面细分，我就不向输入装配阶段提交三角形。而是提交具有若干控制点的面片。图元类型使用D3D_PRIMITIVE_TOPOLOGY中的类型。当然三角形可以看作具有三个控制点的面片，所以依然可以提交普通的三角形网络。 3.1 Hull Shader Stage 外壳着色器阶段首先，外壳着色器（HS）实际上由两种着色器组成： 常量外壳着色器(constant hull shader) 控制点外壳着色器(control point hull shader)3.1.1 常量外壳着色器(constant hull shader) 常量外壳着色器将每一个面片的控制点作为输入（即一次只输入一个面片中的控制点），每处理一个面片就会调用一次。其工作是输出网格的曲面细分因子(Tessellation factor)。曲面细分因子指的是面片将要在曲面细分阶段中镶嵌处理后的份数。现在说一个将一个具有四个控制点的四边形面片从各方面分成三份的例子： // 首先要定义每个片面需要的信息作为常量外壳着色器的输出 struct PatchTess { // SV_TessFactor语义表示几何图形边缘细分份数 float EdgeTess[4] : SV_TessFactor; // SV_InsideTessFactor语义表示几何图形内部细分份数 float InsideTess[2] : SV_InsideTessFactor; ...... }; // 然后可以正式定义常量着色器 // 外壳着色器在顶点着色器之后，自然使用顶点着色器的输出作为输入。在这里就用InputPatch&lt;&gt;模板定义，VertexOut是VS的输出结构体，4代表我们的面片具有4个控制点。SV_PrimitiveID语义提供了面片的位标识。 PatchTess ConstantHS(InputPatch&lt;VertexOut, 4&gt; patch, uint patchID : SV_PrimitiveID) { // 声明输出变量。 PatchTess pt; pt.EdgeTess[0] = 3; // 面片左边缘份数 pt.EdgeTess[1] = 3; // 面片上边缘份数 pt.EdgeTess[2] = 3; // 面片右边缘份数 pt.EdgeTess[3] = 3; // 面片下边缘份数 pt.InsideTess[0] = 3; // 面片内部细分列数 pt.InsideTess[1] = 3; // 面片内部细分行数 ...... return pt; } 对于四边形，镶嵌化处理有两个部分， 4个边缘曲面细分因子对应边缘细分份数 两个内部曲面细分因子说明了如何对内部进行镶嵌化处理。 对于三角形来说，镶嵌化也是两个部分， 3个边缘曲面细分因子对应边缘细分份数 一个内部曲面细分因子表示三角形面片的镶嵌份数。 3.1.2 控制点外壳着色器(control point hull shader)控制点外壳着色器将控制点作为输入和输出，对每个控制点都会调用一次控制点外壳着色器。其应用之一是改变曲面的表示方式，如将一个普通的三角形转换成三次贝塞尔三角形面片（一个具有10个控制点的面片）一个简单的例子： // 定义HS的输出 struct HullOut { float3 PosL : POSITION; }; [domain(&quot;quad&quot;)] [partitioning(&quot;integer&quot;)] [outputtopology(&quot;triangle_cw&quot;)] [outputcontrolpoints(4)] [patchconstantfunc(&quot;ConstantHS&quot;)] [maxtessfactor(64.0f)] HullOut HS(InputPatch&lt;VertexOut, 4&gt; p, uint i : SV_OutputControlPointID, uint patchId : SV_PrimitiveID) { // 声明输出变量 HullOut hout; // 这里的HS其实是就是个传递的作用，没有改变什么值 hout.PosL = p[i].PosL; return hout; } 我们可以看到HS的前面多了很多[]括起来的内容，和C#的Attribute相似。没错，这个是Shader Model中的东西。更多可以看看Shader Model 5 Attributes这里就解释一下上面提到的 domain():定义了HS中使用的面片类型。可选参数为”tri”、”quad”、”isoline” partitioning()：定义了HS使用的镶嵌方案(tesselation scheme,不知道翻译好没)，可选参数为”integer”、”fractional_even”、”fractional_odd”、” pow2”。 3.2 Tessellator Stage 曲面细分（镶嵌器）阶段这个阶段由硬件自动完成，程序员无法干预。对于镶嵌化处理的结果，emmmmmmm，放两张图吧。 3.3 Domain shader Stage 域着色器阶段镶嵌器阶段会输出新生成的顶点与三角形。对于此阶段所创建的所有顶点都会依次调用域着色器(DS)。所以DS实际上和顶点着色器类似，是对已镶嵌完成的顶点进行处理的着色器。DS以曲面细分因子、控制点以及镶嵌画处理后的定点位置参数坐标(u,v)作为输入。这里的定点位置参数不是实际位置，而是位于面片域空间(patch domain space)的参数坐标。可以利用控制点和这些坐标来求出真正的坐标。下面使用双线性插值来求。（其他也可以，只是书中例子是这个） struct DomainOut { float4 PosH : SV_POSITION; }; [domain(&quot;quad&quot;)] DomainOut DS(PatchTess patchTess, float2 uv : SV_DomainLocation, const OutputPatch&lt;HullOut, 4&gt; quad) { // 声明输出变量 DomainOut dout; // 这里就是双线性插值 //lerp(u,v,t)是基于t∈[0，1]，在u，v之间进行线性插值 float3 v1 = lerp(quad[0].PosL, quad[1].PosL, uv.x); float3 v2 = lerp(quad[2].PosL, quad[3].PosL, uv.x); float3 p = lerp(v1, v2, uv.y); // 转换为世界坐标 float4 posW = mul(float4(p, 1.0f), gWorld); // 投影到齐次剪裁矩阵中 dout.PosH = mul(posW, gViewProj); return dout; } 4 Geometry Shader Stage 几何着色器阶段由于曲面细分阶段是一个可选阶段，几何着色器（GS）输入数据是一组完整的图元（其实也就是一组顶点？？），输出为几何着色器一大特点就是可以创建和销毁几何图形。利用GS可以做到点精灵的拓展、动态粒子系统、皮毛的申城、阴影体积的生成等效果。比较巧的是GS有一个简单的模板可以套用： // 输出顶点的最大数量 [maxvertexcount(N)] void Name (PrimitiveType InputVertexType InputNmae[NumElements],inout StreamOutputObject&lt;OutputVertexType&gt; OutputName) { ...... } GS每次调用前必须先制定可输出的定点最大数量，这里用属性[maxvertexcount()]来指定。 对于参数，第一个参数的构成为 图元类型 输入定点类型 数据名字，图元类型可用”point”（点）、”line”（线）、”triangle”（三角形）、”lineadj”（线列表及其邻接图元或线条带及其临界图元）、”triangleadj（三角型列表及其邻接图元或三角形带及其邻接图元）”，第二个参数首先是inout关键字，这个一定要有，而且他使用了一个模板类型流类型。流类型存有一系列顶点，定义了几何着色器输出的几何图形。几何着色器可以通过内置方法Append()向输出流添加顶点。void StreamOutputObject&lt;OutputVertexType&gt;::Append(OutputVertexType v); 对于流类型，其模板参数用指定输出顶点的类型，并且有三种类型。 PointStream&lt;OutPutVertexType&gt; // 一系列顶点所定义的点列表 LineStream&lt;OutPutVertexType&gt; // 一系列顶点所定义线条带 TriangleStream&lt;OutPutVertexType&gt; // 一系列顶点所定义三角形带 几何着色器输出的顶点会构成由流类型指定的图元，但是流类型未包括线条列表和三角形列表。其实可以使用内置函数RestartStrip()来实现线条列表和三角形列表。void StreamOutputObject&lt;OutputVertexType&gt;::RestartStript();想要实现三角形列表，需要在每次向流输出追加三个顶点后调用一次RestartStript()。线条列表则是没追加两个顶点后调用RestartStript()。这里给出一个将一个点拓展成一个四边形的例子，也就是“公告牌技术” // 这里假设不进行曲面镶嵌阶段，所以直接使用VS的输出 struct VertexOut { float3 CenterW : POSITION; float2 SizeW : SIZE; }; // 定义几何着色器的输出 struct GeoOut { float4 PosH : SV_POSITION; float3 PosW : POSITION; float3 NormalW : NORMAL; float2 TexC : TEXCOORD; uint PrimID : SV_PrimitiveID; }; // 指定GS输出顶点数最多为4个 [maxvertexcount(4)] void GS(point VertexOut gin[1], uint primID : SV_PrimitiveID, inout TriangleStream&lt;GeoOut&gt; triStream) { //这里计算精灵(Sprite)的局部坐标系与世界空间的相对关系。使得之后的四边形与和y轴对齐并面向观察者 float3 up = float3(0.0f, 1.0f, 0.0f); float3 look = gEyePosW - gin[0].CenterW; look.y = 0.0f; // 对齐y轴，使四边形立在xz平面上 look = normalize(look); float3 right = cross(up, look); // 计算四边形的宽和高，用来计算顶点坐标 float halfWidth = 0.5f*gin[0].SizeW.x; float halfHeight = 0.5f*gin[0].SizeW.y; // 开始计算顶点坐标 float4 v[4]; v[0] = float4(gin[0].CenterW + halfWidth*right - halfHeight*up, 1.0f); v[1] = float4(gin[0].CenterW + halfWidth*right + halfHeight*up, 1.0f); v[2] = float4(gin[0].CenterW - halfWidth*right - halfHeight*up, 1.0f); v[3] = float4(gin[0].CenterW - halfWidth*right + halfHeight*up, 1.0f); // 纹理坐标的操作 float2 texC[4] = { float2(0.0f, 1.0f), float2(0.0f, 0.0f), float2(1.0f, 1.0f), float2(1.0f, 0.0f) }; // 将四边形的顶点变化为世界坐标，并且以三角形带形式输出。 GeoOut gout; // for循环属性 unroll指的是展开循环，直到停止执行。 [unroll] for(int i = 0; i &lt; 4; ++i) { gout.PosH = mul(v[i], gViewProj); gout.PosW = v[i].xyz; gout.NormalW = look; gout.TexC = texC[i]; gout.PrimID = primID; triStream.Append(gout); } } 关于for循环的属性可以看这里 SV_PrimitiveID语义是一个无符号的整形参数，指定了这个语义，输入装配阶段就会自动为每个图元生成一个ID，每个ID的都是唯一的。尽管这里没有使用，但是GS将ID写入顶点中，下面的像色着色器中可以使用。 Stream Output Stage 流输出阶段流输出阶段就是将集合着色器的顶点数据连续输出到一个或多个缓冲区中，和几何着色器紧密联系在一起的。 6 Rasterizer Stage 光栅化阶段其实在光栅化之前还有一个阶段叫裁剪，在这个阶段会将完全位于视锥体之外的几何体全部丢弃，而对于一部分在外面的几何体也会被实施裁剪(clip)的操作。 光栅化阶段实际也是一个不可编程阶段，其功能是为投影在主屏幕上的3D三角形计算出对应的像素颜色。光栅化阶段中主要干了以下事情 视口变换 背面剔除 顶点属性插值6.1 视口变换 裁剪完成后硬件会通过透视除法，将物体从齐次裁剪空间变化为规格化设备坐(NDC)。一旦物体顶点坐标在NDC空间内，构成2D图像的2D顶点x，y坐标就会被变换到后台缓冲区中被称为视口(view port)的矩形中。变换完成后顶点坐标都是以像素为单位的。视口变换不会影响深度值（z坐标）。 6.2 背面剔除这里我们需要先了解什么是正面,什么是背面。 对于一个顶点为V0、V1、V2的三角形 $e_0 = V_1 - V_0$ $e_1 = V_2 - V_0$ 法向量为 n = \\tfrac{e_0 \\times e_1}{e_0 \\times e_2}法向量从正面射出,则另一面为背面。 若观察者看到的是正面,则称三角形是正面朝向(front-facing)的否则称三角形为背面朝向(back-facing)的。 对于大多数物体而言,背面朝向的三角形都被正面朝向的所遮挡,绘制他们是没用的,所以背面剔除就是除去这些没用三角形. 6.3 顶点属性插值顶点中不止可以存放位置信息,还可以存放像颜色、法向量、纹理坐标等属性。视口变换后需要为三角形的每个像素所附有的属性进行插值。这部分使用的插值方法为透视矫正插值(perspective correct interpolation)，这个计算由硬件完成。 7 Pixel Shader Stage 像素着色器阶段像素着色器(PS)的输入是光栅化阶段期间输出的对顶点属性的插值。PS会对每一个像素片段进行处理,并根据顶点的插值属性作为输入来计算出对应的所以像素颜色,PS既可以返回一种单一恒定颜色,以实现逐像素光照(per-pixel linghting)、反射(reflection)、阴影(shadow)等效果。 像素片段并不一定是最后写入后台缓冲区中，有时候会有多个像素片段。需要通过一些规则来确定最后写入后台缓冲区的像素片段是哪一个。也就是说，像素着色器所做的工作就是为了计算颜色。最简单的像素着色器可以写成下列形式 // 定义输入顶点,应与c++文件中定义一致 struct VertexIn { // 冒号后为语义，和之前填写的输入布局描述的语义相同 float3 PosL : POSITION; float4 Color : COLOR; ...... }; // 定义输出顶点,可根据需要增加变量 struct VertexOut { float4 PosH : SV_POSITION; float4 Color : COLOR; ...... }; // 这里假设只存在VS和PS，所以VS输出就是PS输入 // SV_Target语义表示返回值类型应当与目标格式（render targer format）相匹配 // 而着色器本身只是输出了颜色插值 float4 PS(VertexOut pin) : SV_Target { return pin.Color; }; 关于像素着色器其实有很多很多有用的地方，值得好好弄弄，之后有机会也会说说。 8 Output Merger Stage 合并输出阶段也是一个不可编程阶段像素着色器生成的像素片段会会被送到合并输出阶段(OM)，该阶段中一些像素片段就会被丢弃。剩下的将会写入后台缓冲中。其中混合(Blend)操作也是在这个阶段实现的。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"你说这知识咋就不进脑子呢","slug":"你说这知识咋就不进脑子呢","permalink":"/tags/你说这知识咋就不进脑子呢/"},{"name":"DirectX","slug":"DirectX","permalink":"/tags/DirectX/"},{"name":"Shader","slug":"Shader","permalink":"/tags/Shader/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"NLP_EmotionClassfied","slug":"NLP_EmotionClassfied","date":"2020-02-11T16:00:00.000Z","updated":"2020-03-24T12:43:20.941Z","comments":true,"path":"2020/02/12/NLP_EmotionClassfied/","link":"","permalink":"/2020/02/12/NLP_EmotionClassfied/","excerpt":"","text":"不谈理论，不谈公式，就说用啥能实现！1. 整体过程 读取训练数据，调整数据格式。 对数据进行分词（字），可以按词，也可以按字。 统计词（字）频，建立词典（字典）。 对每个词（字）建立索引。 将之前分好词（字）的每个句子用索引替换。 调整句子长度，多的截取，少的补0。 建立模型 训练。 2. 详细说明2.0 导包其实这是句废话，不导包怎写代码？ import numpy as np; import tensorflow as tf; import jieba; # 用于分词 import re; # 用于删除特殊字符 import pandas as pd; # 用于统计词频，其实也可以用Tensorflow自己的Tokenizer 2.1 读取训练数据由于任何人的训练数据不一样，格式千奇百怪，整理方式也不尽相同，先说一下最终的样子吧。 简单来讲需要分成两个list，一个label用来存放标情感标记。一个sentencesList用于存放句子。 这里用自己的txt来举例子。 首先数据格式如下 1,&quot;距离川沙公路较近,但是公交指示不对,如果是&quot;&quot;蔡陆线&quot;&quot;的话,会非常麻烦.建议用别的路线.房间较为简单.&quot; ··· ··· 0,说实在的我很失望，之前看了其他人的点评后觉得还可以才去的，结果让我们大跌眼镜。我想这家酒店以后无论如何我都不会再去了。 第一个为label,1表示积极，0表示消极，之后为语句。我们只需要按行读取，先存标记，然后出去标点等特殊符号，接着将语句存入list就好。 在这个部分其实就可以使用jieba进行分词操作。这里就加上了。 lineList = []; lable = []; with open(&quot;ChnSentiCorp_htl_all.txt&quot;,encoding=&quot;utf-8&quot;) as file: for line in file: if(line[0]==&quot;1&quot;): lable.append(1); else: lable.append(0); line = re.sub(&#39;[’!&quot;#$%&amp;\\&#39;()*+,-./:;&lt;=&gt;?@[\\\\]^_`{|}，。（）/《》！~#￥%……&amp;*？：；”“‘’【】、\\n|]+&#39;,&#39;&#39;,line); lineList.append(list(jieba.cut(line[1:]))); 插一句题外话，这里肯定有人要问Python还打分号？不好意思，个人习惯，C++和JAVA写多了，习惯性打的，甚至还习惯性补分号，反正Python也不算错，还请见谅。 好的我们来看，首先with open()常规操作打开文件。对每一行进行读取，并判断第一行的label，接下来使用re进行特殊符号的删除。然后使用jieba对从第二个字符开始之后的字符串进行分词操作，因为第一个是label不需要他。 2.2 分词操作上面确实做了，如果没错可以在这里做。当然暂时我为了求快没有按字分。可能以后会写吧。 2.3 统计词（字）频，建立字典建立字典是为了其实是为了下一步的索引，索引是为了方便计算，数字的计算和查找要比字符串方便而且快得多。所以最后训练数据是很多条索引组成的句子。 这里使用的pandas来统计。 word_dictionary =[]; for line in lineList: for word in line: word_dictionary.append(word); print(word_dictionary); wordNum = pd.Series(word_dictionary).value_counts(); wordNum = wordNum[wordNum&gt;=5]; 首先是个笨办法，遍历每一个单词，然后添加进一个list（因为list不去重）。接着就是建立一个pandas.Series对象调用value_counts()方法统计词频。返回值是一个Series对象。里面储存了词和次出现的次数。 2.4 对每个词（字）建立索引。这里做的很简单，就是把频率换成索引就好。但是要注意，索引要从1开始，0用于填充补齐。还有就是，我们选择出现频率比较高的词，因为计算速度。但实际上低频词也未必不起到关键作用，滑稽保命之类的对吧？ wordNum = wordNum[wordNum&gt;=5]; # 保留词频大于等于5的词 wordNum[:] = list(range(1,len(wordNum)+1)); # 依照频率高低将频率换成索引， wordNum[&#39;&#39;] = 0; # 添加空的索引为0 首先是提取词频大于5的词，然后将频率换成索引，然后添加0索引。 2.5 用索引替换句子sentencesi = []; for line in lineList: sentenceindex = []; for word in line: if word in wordSet: sentenceindex.append(wordNum[word]); sentencesi.append(sentenceindex); 就是个替换，我觉得没啥可说的，就是遍历一遍所有单词，如果词再字典里那么久转换成索引添加进来，没有就放弃。 2.6 调整句子长度，多的截取，少的补0。为了计算速度，这里同时使用固定长度的句子，因此就要多截少补。 X =list(tf.keras.preprocessing.sequence.pad_sequences(sentencesi,maxlen=50)); 这里选取最大长度为50。当然好一点的方法是先统计一下句子长度，找一个能包含大多数完整句子的长度。 2.7 建立模型和训练。模型这里很简单的随便建立了一个，层数，损失函数和优化函数都可以看情况换，我是看有篇文章这么做了，我就这么写了。 x_train = np.array(X); y_train = np.array(lable); model = tf.keras.Sequential(); model.add(tf.keras.layers.Embedding(input_dim=len(wordSet),output_dim=200,input_length=50)); model.add(tf.keras.layers.LSTM(128)); model.add(tf.keras.layers.Dropout(0.5)); model.add(tf.keras.layers.Dense(1,activation=&quot;sigmoid&quot;)); model.compile(loss=&#39;binary_crossentropy&#39;, optimizer=&#39;rmsprop&#39;, metrics=[&#39;accuracy&#39;]); print(model.summary()); model.fit(x_train, y_train, batch_size=16, epochs=250); 这里因为是2分类所以就用sigmoid了，多分类要用softmax，将来会做一个多分类的。 补充3.1 程序说明整个程序习惯性的面向过程了。所以上面代码全部按顺序crtl+c、crtl+v下来差不多就能用了。为了流程叙述方便所以这么写了。而且为了快，很多地方没有优化，速度肯定还可以再快，再者为了维护，实际上最终要用的话最好面向对象一下。 其中需很多多西想重复用的话其实可以保存一下。像是模型，字典什么的。而且要生产开发用还需要预测，个人认为同样还需要字典等数据，所以保存下来会好一些？ 3.2 tf.keras.layers.Embedding()的一些小说明这个是个嵌入层，用于将索引转换为向量。参数如下 input_dim: int &gt; 0。词汇表大小， 即，最大整数 index + 1。 output_dim: int &gt;= 0。词向量的维度。 embeddings_initializer: embeddings 矩阵的初始化方法 (详见 initializers)。 embeddings_regularizer: embeddings matrix 的正则化方法 (详见 regularizer)。 embeddings_constraint: embeddings matrix 的约束函数 (详见 constraints)。 mask_zero: 是否把 0 看作为一个应该被遮蔽的特殊的 “padding” 值。 这对于可变长的 循环神经网络层 十分有用。 如果设定为 True，那么接下来的所有层都必须支持 masking，否则就会抛出异常。 如果 mask_zero 为 True，作为结果，索引 0 就不能被用于词汇表中 （input_dim 应该与 vocabulary + 1 大小相同）。 input_length: 输入序列的长度，当它是固定的时。 如果你需要连接 Flatten 和 Dense 层，则这个参数是必须的 （没有它，dense 层的输出尺寸就无法计算）。其实还可以指定一个weights=，这个是指定自己训练的词向量用的。默认他会通过initializer随机初始化一个，当然这个initializer你也可以指定。 3.3 词向量通常我们想让字典尽可能贴近我们的需求，所以需要自己训练词向量，这个时候就需要Word2Vec了。 3.2.1 词向量训练前准备首先是导包！ import gensim.models.word2vec; 然后自然是准备词（了），我们可以直接利用上面分完词还未转化为索引的句子，当然有的这里会使用字，有的也会追加停用词。不论怎样，我们最后得到一个字符串组成的列表就可以了。 3.2.2 词向量训练vecModel = gensim.models.Word2Vec(); 这里参数很多，说几个这里一般简单用的： sentences : 可迭代的对象 size : 词向量的维数。 window : 句子中当前词和预测词之间的最大距离。window越大，则与中心词较远的词也会产生上下文关系。 min_count :最小词频，忽略所有总频率低于此频率的单词 差不多就这些，剩下可以看API。（英文注意！中文百度） 对于语料库很大的情况，训练词向量需要通过从磁盘加载sentences。循环训练。 3.2.3 加载现有词向量可以通过加载现有词向量来使用。这个方法各不相同，至少Word2vec训练出来可的一通过gensim.models.KeyedVectors.load()来加载，具体参数见API。（英文注意！中文百度） 加载完后需要依据你的字典把对应的词的向量添加进来。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"你说这知识咋就不进脑子呢","slug":"你说这知识咋就不进脑子呢","permalink":"/tags/你说这知识咋就不进脑子呢/"},{"name":"AI","slug":"AI","permalink":"/tags/AI/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"DirectX12 Study log (仮)","slug":"DirectX12.log","date":"2019-12-29T16:00:00.000Z","updated":"2020-03-25T08:08:36.973Z","comments":true,"path":"2019/12/30/DirectX12.log/","link":"","permalink":"/2019/12/30/DirectX12.log/","excerpt":"","text":"DirectX12 Study log (仮)主要内容基于《3D GAMEPROGRAMMING WITH DIRECTX 12》内容学习。原文使用面向对象编程，个人强行改为“面向过程”。而且还是非常SB的。垃圾一枚。主要记录书里大致有些什么东西，干了些什么。学习的时候没有记录会有些很多缺漏。 关于具体的实现的东西想在新开个地方慢慢解释。关于HLSL和Shader也会新开一个文章慢慢说。 数学基础说白了，看了也记不住，记住了也不懂，懂了也不会用。2333333 Direct3dD initialize Direct3D的初始化DirectX10（9？）之后的变化其实个人只知道DirectX7，就是那本“超经典”的《Windows游戏大师编程技巧》。这本书用的很老。里面最主要的Surface的概念似乎从DirectX11开始就没了（或是极少被提到）。10似乎是最后使用这个概念的。（可能也是9，我什么也不知道，23333），之前大多数的操作是针对Surface的，DrawLine、Bitmap等操作都是基于Surface的。之前似乎没有涉及到Shader。还有Factory，7似乎所有东西基本都从这里创建。 初始化内容顺序就按照书上的了,其实不是特别有必要.比如就可以先创建交换链在创建命令队列. Devices 设备这个不论那个版本都是需要先初始化的东西，目的在于选择当前机器上显示适配器（显卡？）。获取所支持的DirectX的版本并设置需要使用的版本。而且接下来所有与Direct3D直接相关的东西由Devices创建. Fance 围栏Fance主要作用是标记命令执行的位置,用于同步CPU和GPU.防止CPU速度太快而GPU没执行完命令就把命令队列给刷新了. MASS 多重采样其实不开也可以,就是画面不好看而已.想恶心人可以不开.当然书上开的是4x的,也可以开8x,前提你渲染的东西不多,并且显卡得撑得住啊. CommandQueue and CommandList 命令队列和命令列表命令队列用于向GPU提交要执行的命令,相当于Windows的消息队列.命令列表用于记录队列需要执行的命令,然后将列表提交到队列中.至于为什么不直接加入到队列里.实际答案我也不机密.我猜可能是因为我们的目标是呈现一张完整的Frame.GPU又是并行计算,提交成批操作一可以更好利用GPU效率,二不至于因为一些错误导致可以看见画面生成过程. 而创建CommandList还需要先创建CommandAllocator(命令分配器),负责记录命令并自动写到List中.具体原理我也不懂,反正到时候直接获取然后Execute就行了.233333 Swap Chain 交换链用于切换用户能看到的是哪一块缓冲块(之间叫Surface来着?).通常有两块后台缓冲区,一块给用户看,一块用来绘制下一帧.绘制好了就交换一下,让用户看到下一帧并重绘前一帧.两块缓冲话技术又叫双缓冲,三块就是三缓冲,似乎再多就没啥用了.目的是为了让用户就看到以绘制好的画面.而不知道画面是怎么生成的. DescriptorHeap And Descriptor 描述符堆和描述符描述符就是资源视图,由于Rendering Pipeline不能直接绑定资源,所以使用视图来获取资源情况.描述符堆用来保存他们. 描述符最重要的两个,RTV(Render Target View)和DTV(Depth Target Viet). RTV相当于用于渲染的画面,在Draw任何东西先都应先清空并设置,创建时为每个后台缓冲区创建一个RTV. DTV用于深度模板. 之后还有SRV(Shader Resource View),用于保存着色器使用的资源,如纹理,贴图.SRV似乎应该在加载贴图的时候再创建,最基本的初始化阶段不是必须的.CBV(Constant Buffer View)和UAV(Unordered Access View)bulabulabula 在所有描述符堆前应使用GetDescriptorHandleIncrementSize();获取描述符大小,在创建多个描述符时需要用offset();进行偏移. ViewPort 视口视口就是描述你窗口大小的东西,DirectX只能在Windows上运行,通常视口大小与Windows窗口大小一致,同时视口还可以设置深度,但通常最小为0.0f最大为1.0f. Scissor Rectangle 裁剪矩形裁剪矩形是将矩形外的像素全部剔除,通常和视口大小保持一致. 计时器不管咋样最好有一个,高性能计时器对控制帧率有很好的帮助. 书中给出的GameTimer利用了Windows自带的计时器函数QueryPerformanceCounter();返回一个int64的整数,配合QueryPerformanceFrequency();返回计时器的频率一个int64的整数. 通过调用两次QueryPerformanceCounter();做差再乘上QueryPerformanceFrequency();即可得到两次调用之间经过的时间. Rendering Pipeline 渲染流水线(渲染管线)Profile 概述graph TD A(Input Assembler Stage 输入装配阶段) --&gt; B(Vertex Shader Stage 顶点着色器阶段) --&gt; C(Hull Shader Stage 外壳着色器阶段)--&gt;D(Tessellator Stage 曲面细分阶段)--&gt;E(Domain shader Stage 域着色器阶段)--&gt;F(Geometry Shader Stage 几何着色器阶段)--&gt;G(Stream Output Stage 流输出阶段)--&gt;H(Rasterizer Stage 光栅化阶段)--&gt;I(Pixel Shader Stage 像素着色器阶段)--&gt;J(Output Merger Stage 合并输出阶段) Input Assembler Stage 输入装配阶段 (IA)简单来讲就是从显存中模型的顶点坐标和面索引.注意这里是显存,这就意味之我们在此之前就应该把数据从内存中拷贝到显存里来. 然后需要设置图元拓扑,就是指定顶点之间的结构,读文件的一般不需要注意索引的绕序,想obj和m3d都是可以直接用的. Vertex Shader 顶点着色器阶段(VS)涉及一大堆一大堆数学东西.简而言之就是把相对坐标变成绝对坐标,把局部空间坐标系上的点,表示成世界空间坐标系的点.然后归一化深度值. Hull Shader 外壳着色器阶段(HS) 不是H Sence！其实是曲面细分阶段的一部分,但实际上工作量差不多,我就拿HS说了 Hull Shader包括两种SHader: 1.Constant Hull Shader 常量外壳着色器 2.Control Hull Shader 控制外壳着色器 Constant Hull Shader 常量外壳着色器常量外壳着色器的任务是输出网格的曲面细分因子(tessellation factor).曲面细分因子指示了曲面细分阶段中将面片镶嵌处理后份数. 说白了就是增加定点数量.简单操作就是将直线等分 等分分为两部分，对于四边面，一个是对每条边的细分，另一个是对内部空间几行几列的细分，对于三边面，一个是对每条边的细分，另一个是对内部空间的细分，三边面只有一个内部空间细分参数，可以理解成n行n列的细分。（嗯，应该吧。） Control Hull Shader 控制外壳着色器控制外壳着色器以大量控制顶点作为输入与输出,每输出一个控制点就调用一次.应用之一是改变曲面的表示方式.比如三次贝塞尔曲线.可以带来更丰富的细节. 说白了HS就是可以把低模变成高模 镶嵌器阶段这个是硬件自动完成的，这个环节会根据常量外壳着色器输出的曲面细分因子对面片进行镶嵌画处理，当然四边面和三边面的处理方式是不同的。 Domain Shader域着色器镶嵌器阶段会输出新建的所有顶点与三角形，在此阶段创建的顶点会逐一调用域着色器.其本质就是“对已经经过镶嵌化的面片进行处理的顶点着色器”。对镶嵌花化后的点进行做坐标变换。 Geometry Shader 几何着色器(GS)记得某个群的入群问题就是GS在PS前还是VS后？（还是VS前PS后来着）。总之书上说的是：“再不启用曲面细分这一环节，GS这个可选阶段便会位于VS与PS之间”。 GS的输入必须是完整的图元，如构成一条线的两个顶点，构成三角形的三个顶点。书中提到的一个常见应用是将一点拓展成为一个四边形（俩三角形）。并以此介绍了公告牌技术，用来显示远处的一些小东西。 GS其实就是把顶点来回折腾的一个东西，并且还可以改变图元拓扑（其实我想说的是变成不同的图元），一些小的细节变化和粒子效果似乎可以用这个实现。 Pixel Shader像素着色器(PS)PS会对每一个像素采样点进行计算，根据顶点的插值属性作为输入来计算对应为的像素的颜色。PS可以返回单一恒定的颜色，也可是实现逐像素光照，反射，和阴影等其他效果。 Output Marger 合并输出简单来讲就是去掉不符合要求的像素，如没通过深度缓冲区测试或模板缓冲区测试的像素。剩下的就写入后台缓冲区中，“Blend 混合”也是在这个阶段实现的。 Shader 着色器的写法和一些东西会专门找地方说。 Lighting 光照这个，要在这里面说嘛？就是很多很多的数学和物理知识，在Shader里实现就好了。 Texture Mapping 纹理贴图纹理其实就是一种资源，D3D12中几乎所有资源统一用ID3D12Resource来管理。 纹理具有特定的数据格式，不支持除这些格式之外的格式，并且纹理可以具有多个层级的mipmap（给我感觉的意思当相当于人工智能里的池化操作，就是具有多个大小的同一图，但他们都还在同一个“图”里）。 有一种技术叫“渲染到纹理”，是指即将纹理作用于渲染目标，有能将纹理作为着色器的资源（在着色器里对纹理采样）使用。 DirectX中纹理用DDS(DirectDraw Suaface Format)格式的文件。PS需要装插件才能导出和编辑（忙活了我半天）。 Blend 混合做了个和啥呢，就是把已经光栅化的像素（目标像素）和现在要光栅化的像素（源像素）进行融合的操作。常见操作就是半透明物体的运用，配合纹理贴图会有很多意想不到的效果，有种用代码玩AE的感觉。 Stencli 模板在这里我纳闷过模板为啥子不是Template，一般见到模板都是Template。查字典哇Stencli也是模板的意思。但就是Stencli的模板指的是印刷文字或图案的那个模板。Template有模框，样板的意思。 所以顾名思义，这里的模板是指根据某种规则来写入像素的。书中给的应用就是镜子。当然是平面镜。阴影书中也用了模板缓冲来防止双重混合。 第一人称视角摄像机在书中15章之前的内容中，视角都是通过一个DirectX::XMFLOAT3类型的EyePos变量，传到着色器中gEyePos，通过取景变换转换坐标。 第一人称摄像机就是把这个东西封装成类，添加一些方便计算的属性和方法。同时可以不仅仅“旋转”改变坐标，还可以移动摄像机坐标。每次角度和位置不同更新内部向量，供着色器使用。 动态索引说白了就是让着色器用索引访问资源。据说配合实例化有意想不到的效果。动态索引可以让所有纹理资源一次绑定后，让着色器自己选择适合的纹理。索引要求使用系统ID。如SV_InstanceID、SV_VertexID。 实例化","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"DirectX","slug":"DirectX","permalink":"/tags/DirectX/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Hexo-Theme-Sakura","slug":"Hexo-Theme-Sakura","date":"2018-12-12T14:16:01.000Z","updated":"2020-02-18T00:38:20.675Z","comments":true,"path":"2018/12/12/Hexo-Theme-Sakura/","link":"","permalink":"/2018/12/12/Hexo-Theme-Sakura/","excerpt":"","text":"hexo-theme-sakura主题 English document 基于WordPress主题Sakura修改成Hexo的主题。 demo预览 正在开发中…… 交流群若你是使用者，加群QQ: 801511924 若你是创作者，加群QQ: 194472590 主题特性 首页大屏视频 首页随机封面 图片懒加载 valine评论 fancy-box相册 pjax支持，音乐不间断 aplayer音乐播放器 多级导航菜单（按现在大部分hexo主题来说，这也算是个特性了） 赞赏作者如果喜欢hexo-theme-sakura主题，可以考虑资助一下哦~非常感激！ paypal | Alipay 支付宝 | WeChat Pay 微信支付 未完善的使用教程那啥？老实说我目前也不是很有条理233333333~ 1、主题下载安装hexo-theme-sakura建议下载压缩包格式，因为除了主题内容还有些source的配置对新手来说比较太麻烦，直接下载解压就省去这些麻烦咯。 下载好后解压到博客根目录（不是主题目录哦，重复的选择替换）。接着在命令行（cmd、bash）运行npm i安装依赖。 2、主题配置博客根目录下的_config配置站点 # Site title: 你的站点名 subtitle: description: 站点简介 keywords: author: 作者名 language: zh-cn timezone: 部署 deploy: type: git repo: github: 你的github仓库地址 # coding: 你的coding仓库地址 branch: master 备份 （使用hexo b发布备份到远程仓库） backup: type: git message: backup my blog of https://honjun.github.io/ repository: # 你的github仓库地址,备份分支名 （建议新建backup分支） github: https://github.com/honjun/honjun.github.io.git,backup # coding: https://git.coding.net/hojun/hojun.git,backup 主题目录下的_config配置其中标明【改】的是需要修改部门，标明【选】是可改可不改，标明【非】是不用改的部分 # site name # 站点名 【改】 prefixName: さくら荘その siteName: hojun # favicon and site master avatar # 站点的favicon和头像 输入图片路径（下面的配置是都是cdn的相对路径，没有cdn请填写完整路径，建议使用jsdeliver搭建一个cdn啦，先去下载我的cdn替换下图片就行了，简单方便~）【改】 favicon: /images/favicon.ico avatar: /img/custom/avatar.jpg # 站点url 【改】 url: https://sakura.hojun.cn # 站点介绍（或者说是个人签名）【改】 description: Live your life with passion! With some drive! # 站点cdn，没有就为空 【改】 若是cdn为空，一些图片地址就要填完整地址了，比如之前avatar就要填https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/custom/avatar.jpg cdn: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6 # 开启pjax 【选】 pjax: 1 # 站点首页的公告信息 【改】 notice: hexo-Sakura主题已经开源，目前正在开发中... # 懒加载的加载中图片 【选】 lazyloadImg: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/loader/orange.progress-bar-stripe-loader.svg # 站点菜单配置 【选】 menus: 首页: { path: /, fa: fa-fort-awesome faa-shake } 归档: { path: /archives, fa: fa-archive faa-shake, submenus: { 技术: {path: /categories/技术/, fa: fa-code }, 生活: {path: /categories/生活/, fa: fa-file-text-o }, 资源: {path: /categories/资源/, fa: fa-cloud-download }, 随想: {path: /categories/随想/, fa: fa-commenting-o }, 转载: {path: /categories/转载/, fa: fa-book } } } 清单: { path: javascript:;, fa: fa-list-ul faa-vertical, submenus: { 书单: {path: /tags/悦读/, fa: fa-th-list faa-bounce }, 番组: {path: /bangumi/, fa: fa-film faa-vertical }, 歌单: {path: /music/, fa: fa-headphones }, 图集: {path: /tags/图集/, fa: fa-photo } } } 留言板: { path: /comment/, fa: fa-pencil-square-o faa-tada } 友人帐: { path: /links/, fa: fa-link faa-shake } 赞赏: { path: /donate/, fa: fa-heart faa-pulse } 关于: { path: /, fa: fa-leaf faa-wrench , submenus: { 我？: {path: /about/, fa: fa-meetup}, 主题: {path: /theme-sakura/, fa: iconfont icon-sakura }, Lab: {path: /lab/, fa: fa-cogs }, } } 客户端: { path: /client/, fa: fa-android faa-vertical } RSS: { path: /atom.xml, fa: fa-rss faa-pulse } # Home page sort type: -1: newer first，1: older first. 【非】 homePageSortType: -1 # Home page article shown number) 【非】 homeArticleShown: 10 # 背景图片 【选】 bgn: 8 # startdash面板 url, title, desc img 【改】 startdash: - {url: /theme-sakura/, title: Sakura, desc: 本站 hexo 主题, img: /img/startdash/sakura.md.png} - {url: http://space.bilibili.com/271849279, title: Bilibili, desc: 博主的b站视频, img: /img/startdash/bilibili.jpg} - {url: /, title: hojun的万事屋, desc: 技术服务, img: /img/startdash/wangshiwu.jpg} # your site build time or founded date # 你的站点建立日期 【改】 siteBuildingTime: 07/17/2018 # 社交按钮(social) url, img PC端配置 【改】 social: github: {url: http://github.com/honjun, img: /img/social/github.png} sina: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/sina.png} wangyiyun: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/wangyiyun.png} zhihu: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/zhihu.png} email: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/email.svg} wechat: {url: /#, qrcode: /img/custom/wechat.jpg, img: /img/social/wechat.png} # 社交按钮(msocial) url, img 移动端配置 【改】 msocial: github: {url: http://github.com/honjun, fa: fa-github, color: 333} weibo: {url: http://weibo.com/mashirozx?is_all=1, fa: fa-weibo, color: dd4b39} qq: {url: https://wpa.qq.com/msgrd?v=3&amp;uin=954655431&amp;site=qq&amp;menu=yes, fa: fa-qq, color: 25c6fe} # 赞赏二维码（其中wechatSQ是赞赏单页面的赞赏码图片）【改】 donate: alipay: /img/custom/donate/AliPayQR.jpg wechat: /img/custom/donate/WeChanQR.jpg wechatSQ: /img/custom/donate/WeChanSQ.jpg # 首页视频地址为https://cdn.jsdelivr.net/gh/honjun/hojun@1.2/Unbroken.mp4，配置如下 【改】 movies: url: https://cdn.jsdelivr.net/gh/honjun/hojun@1.2 # 多个视频用逗号隔开，随机获取。支持的格式目前已知MP4,Flv。其他的可以试下，不保证有用 name: Unbroken.mp4 # 左下角aplayer播放器配置 主要改id和server这两项，修改详见[aplayer文档] 【改】 aplayer: id: 2660651585 server: netease type: playlist fixed: true mini: false autoplay: false loop: all order: random preload: auto volume: 0.7 mutex: true # Valine评论配置【改】 valine: true v_appId: GyC3NzMvd0hT9Yyd2hYIC0MN-gzGzoHsz v_appKey: mgOpfzbkHYqU92CV4IDlAUHQ 分类页和标签页配置分类页 标签页 配置项在\\themes\\Sakura\\languages\\zh-cn.yml里。新增一个分类或标签最好加下哦，当然嫌麻烦可以直接使用一张默认图片（可以改主题或者直接把404图片替换下，征求下意见要不要给这个在配置文件中加个开关，可以issue或群里提出来），现在是没设置的话会使用那种倒立小狗404哦。 #category # 按分类名创建 技术: #中文标题 zh: 野生技术协会 # 英文标题 en: Geek – Only for Love # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/coding.jpg 生活: zh: 生活 en: live img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/writing.jpg #tag # 标签名即是标题 悦读: # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/reading.jpg 单页面封面配置如留言板页面页面，位于source下的comment下，打开index.md如下： --- title: comment date: 2018-12-20 23:13:48 keywords: 留言板 description: comments: true # 在这里配置单页面头部图片，自定义替换哦~ photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/comment.jpg --- 单页面配置番组计划页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: bangumi title: bangumi comments: false date: 2019-02-10 21:32:48 keywords: description: bangumis: # 番组图片 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg # 番组名 title: 朝花夕誓——于离别之朝束起约定之花 # 追番状态 （追番ing/已追完） status: 已追完 # 追番进度 progress: 100 # 番剧日文名称 jp: さよならの朝に約束の花をかざろう # 放送时间 time: 放送时间: 2018-02-24 SUN. # 番剧介绍 desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg title: 朝花夕誓——于离别之朝束起约定之花 status: 已追完 progress: 50 jp: さよならの朝に約束の花をかざろう time: 放送时间: 2018-02-24 SUN. desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 --- 友链页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: links title: links # 创建日期，可以改下 date: 2018-12-19 23:11:06 # 图片上的标题，自定义修改 keywords: 友人帐 description: # true/false 开启/关闭评论 comments: true # 页面头部图片，自定义修改 photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/links.jpg # 友链配置 links: # 类型分组 - group: 个人项目 # 类型简介 desc: 充分说明这家伙是条咸鱼 &lt; (￣︶￣)&gt; items: # 友链链接 - url: https://shino.cc/fgvf # 友链头像 img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg # 友链站点名 name: Google # 友链介绍 下面雷同 desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 # 类型分组... - group: 小伙伴们 desc: 欢迎交换友链 ꉂ(ˊᗜˋ) items: - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 --- 写文章配置主题集成了个人插件hexo-tag-bili和hexo-tag-fancybox_img。其中hexo-tag-bili用来在文章或单页面中插入B站外链视频，使用语法如下： {% bili video_id [page] %} 详细使用教程详见hexo-tag-bili。 hexo-tag-fancybox_img用来在文章或单页面中图片，使用语法如下： {% fb_img src [caption] %} 详细使用教程详见hexo-tag-fancybox_img 还有啥，一时想不起来……To be continued…","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"/tags/悦读/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]}]}