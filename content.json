{"meta":{"title":"CloverYuki","subtitle":null,"description":"论一只菜鸡如何毁掉一个好主题","author":"yuuki","url":""},"pages":[{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2020-02-18T00:38:20.679Z","comments":false,"path":"bangumi/index.html","permalink":"/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"books","date":"2019-02-10T13:32:48.000Z","updated":"2020-02-18T00:38:20.680Z","comments":false,"path":"books/index.html","permalink":"/books/index.html","excerpt":"","text":""},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2020-02-18T00:38:20.680Z","comments":false,"path":"client/index.html","permalink":"/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2020-02-18T16:54:14.441Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"有啥就说 不要含糊。 不明白为啥改不了","keywords":"留言板"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2020-02-18T00:38:20.683Z","comments":false,"path":"lab/index.html","permalink":"/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2020-02-18T00:38:20.682Z","comments":false,"path":"donate/index.html","permalink":"/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2020-02-18T00:38:20.684Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2020-02-18T00:38:20.685Z","comments":true,"path":"rss/index.html","permalink":"/rss/index.html","excerpt":"","text":""},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2020-02-18T00:38:20.685Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2020-02-18T00:38:20.686Z","comments":false,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":"","keywords":null},{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2020-04-12T14:58:11.969Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"[白い世界から]] 与&nbsp; Yukina&nbsp; （ 雪(yuki)凪(na)） ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2020-02-18T00:38:20.687Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"","date":"2020-02-18T00:38:20.672Z","updated":"2020-02-18T00:38:20.672Z","comments":true,"path":"404/404.html","permalink":"/404/404.html","excerpt":"","text":"404 html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video { margin: 0; padding: 0; border: 0; vertical-align: baseline; font: inherit; font-size: 100%; } tbody, tfoot, thead, tr, th, td { margin: 0; padding: 0; border: 0; font: inherit; font-size: 100%; } /* HTML5 display-role reset for older browsers */ article, aside, details, figcaption, figure, footer, header, hgroup, menu, nav, section { display: block; } body { line-height: 1; } ol, ul { list-style: none; } q:before, q:after { content: ''; content: none; } body { width: 100%; *zoom: 1; } body:before, body:after { display: table; content: \"\"; } body:after { clear: both; } html, body { height: 100%; } html { height: 100%; max-height: 100%; } body { color: #333333; font-size: 1em; font-family: \"ff-tisa-web-pro-1\", \"ff-tisa-web-pro-2\", \"Lucida Grande\", \"Hiragino Sans GB\", \"Hiragino Sans GB W3\", \"Microsoft YaHei\", \"WenQuanYi Micro Hei\", sans-serif; -webkit-font-smoothing: antialiased; } ::selection { background: rgba(255, 255, 255, 0.3); } ::-moz-selection { background: rgba(255, 255, 255, 0.3); } a { color: #DF9C81; text-decoration: none; } a:hover { color: #d06c44; -webkit-transition: .5s; -moz-transition: .5s; -o-transition: .5s; -ms-transition: .5s; } h1, h2, h3, h4, h5, h5 { margin-top: 1.0em; margin-bottom: .5em; color: #333333; font-weight: lighter; font-family: \"ff-tisa-web-pro-1\", \"ff-tisa-web-pro-2\", \"Lucida Grande\", \"Hiragino Sans GB\", \"Hiragino Sans GB W3\", \"Microsoft YaHei\", \"WenQuanYi Micro Hei\", sans-serif; -webkit-font-smoothing: antialiased; } h1 { margin-top: 0; letter-spacing: .05em; font-size: 1.8em; line-height: 1.2em; } h2 { font-size: 1.6em; } h3 { font-size: 1.4em; } h4 { font-size: 1.2em; } h4 { font-size: 1.1em; } h5 { font-size: 1em; } p { margin-bottom: 1.3em; line-height: 1.7em; } em { font-style: italic; } ol, ul { margin: 0 0 .3em 1em; } ol li, ul li { margin: 0 0 .2em 0; line-height: 1.6em; } ol ol, ol ul, ul ol, ul ul { margin: .1em 0 .2em 2em; } ol { list-style-type: decimal; } ul { list-style-type: disc; } .date, .time, .author, .tags { color: #c7c7c7; font-size: .8em; } .date a, .time a, .author a, .tags a { color: #666666; } .date a:hover, .time a:hover, .author a:hover, .tags a:hover { color: #d06c44; } .footer { position: absolute; bottom: 0; left: 0; width: 100%; color: #b3b3b3; font-size: .7em; } .logo { width: 25%; border: 3px solid #FFF; border-radius: 50%; box-shadow: 0 0 1px 1px rgba(0, 0, 0, 0.3); transition: all .5s; } .logo:hover { border: 3px solid #5ba4e5; transition: all .5s; -webkit-transform: rotate(360deg); /* Safari 和 Chrome */ -moz-transform: rotate(360deg); /* Firefox */ -o-transform: rotate(350deg); /* Opera */ transform: rotate(360deg); -ms-transform: rotate(360deg); /* IE 9 */ } .Weibo_icon_logo { width: 20px; height: 20px; border-radius: 50%; background-position: -50px -25px; box-shadow: 0 0 4px rgba(0, 0, 0, 0.3); vertical-align: -2px; } .Weibo_icon { display: inline-block; background-image: url(../homepage/img/V_icon.png); background-repeat: no-repeat; } .Weibo_icon_position { position: relative; top: -12px; right: 42px; } hr { border: none; } .hidden { display: none !important; } .panel { display: table; width: 100%; height: 100%; } .panel-title { margin: 0 0 15px 0; color: #FFF; letter-spacing: 4px; font-size: 5em; } .panel-subtitle { color: #CCCCCC; letter-spacing: 3px; font-weight: lighter; font-size: 1.2em; font-family: \"ff-tisa-web-pro-1\", \"ff-tisa-web-pro-2\", \"Lucida Grande\", \"Hiragino Sans GB\", \"Hiragino Sans GB W3\", \"Microsoft YaHei\", \"WenQuanYi Micro Hei\", sans-serif; -webkit-font-smoothing: antialiased; } .panel-cover { position: fixed; z-index: 900; display: block; width: 100%; height: 100%; max-width: none; background: url(../images/background-cover.jpg) top left no-repeat #666666; background-size: cover; } .panel-cover--collapsed { width: 30%; max-width: 700px; } .panel-cover--overlay { position: absolute; top: 0; right: 0; bottom: 0; left: 0; z-index: 0; display: block; background-color: rgba(68, 68, 68, 0.6); background-image: -webkit-linear-gradient(-410deg, rgba(68, 68, 68, 0.6) 20%, rgba(0, 0, 0, 0.9)); background-image: linear-gradient(140deg, rgba(68, 68, 68, 0.6) 20%, rgba(0, 0, 0, 0.9)); } .panel-cover__logo { margin: 0px 0px 0px 20px; margin-bottom: .2em; } .panel-cover__description { margin: 0 30px; font-size: 20px; font-weight: bolder; } .panel-cover__divider { margin: 20px auto; width: 50%; border-top: 1px solid rgba(255, 255, 255, 0.14); } .panel-cover__divider--secondary { width: 15%; } .panel-main { display: table; width: 100%; height: 100%; } .panel-main__inner { position: relative; z-index: 800; display: table-cell; padding: 0 60px; vertical-align: middle; } .panel-main__content { margin: 0 auto; max-width: 800px; } .panel-main__content--fixed { width: 480px; -webkit-transition: width 1s; /* Safari */ transition: width 1s; } .panel-inverted { color: #FFF; text-align: center; text-shadow: 0 1px 1px rgba(0, 0, 0, 0.4); font-weight: 100; } .panel-inverted a { color: #FFF; } .cover-navigation { margin-top: 42px; } .cover-navigation--social { margin-left: 30px; } .cover-blue { background-color: rgba(37, 104, 163, 0.6); background-image: -webkit-linear-gradient(-410deg, rgba(37, 104, 163, 0.6) 20%, rgba(18, 51, 80, 0.8)); background-image: linear-gradient(140deg, rgba(37, 104, 163, 0.6) 20%, rgba(18, 51, 80, 0.8)); } .cover-green { background-color: rgba(21, 111, 120, 0.6); background-image: -webkit-linear-gradient(-410deg, rgba(21, 111, 120, 0.6) 20%, rgba(6, 31, 33, 0.8)); background-image: linear-gradient(140deg, rgba(21, 111, 120, 0.6) 20%, rgba(6, 31, 33, 0.8)); } .cover-purple { background-color: rgba(73, 50, 82, 0.6); background-image: -webkit-linear-gradient(-410deg, rgba(73, 50, 82, 0.6) 20%, rgba(17, 11, 19, 0.8)); background-image: linear-gradient(140deg, rgba(73, 50, 82, 0.6) 20%, rgba(17, 11, 19, 0.8)); } .cover-red { background-color: rgba(119, 31, 18, 0.6); background-image: -webkit-linear-gradient(-410deg, rgba(119, 31, 18, 0.6) 20%, rgba(30, 8, 5, 0.8)); background-image: linear-gradient(140deg, rgba(119, 31, 18, 0.6) 20%, rgba(30, 8, 5, 0.8)); } .cover-orange { background-color: rgba(174, 80, 4, 0.6); background-image: -webkit-linear-gradient(-410deg, rgba(174, 80, 4, 0.6) 20%, rgba(74, 34, 2, 0.8)); background-image: linear-gradient(140deg, rgba(174, 80, 4, 0.6) 20%, rgba(74, 34, 2, 0.8)); } .cover-slate { background-color: rgba(0, 0, 0, 0.4); background-image: -webkit-linear-gradient(-410deg, rgba(0, 0, 0, 0.2) 20%, rgba(0, 0, 0, 0.6)); background-image: linear-gradient(140deg, rgba(0, 0, 0, 0.62) 20%, rgba(0, 0, 0, 0.6)); } .cover-disabled { background: none; } .btn, .navigation__item a { padding: 10px 20px; border: 1px solid #DF9C81; border-radius: 20px; color: #DF9C81; text-shadow: none; letter-spacing: 1px; font-weight: bold; font-size: .9em; -webkit-font-smoothing: antialiased; } .btn:hover, .navigation__item a:hover { border-color: #d06c44; color: #d06c44; } .btn-border-small { margin-left: 10px; padding: 6px 8px; border: 1px solid #DF9C81; border-radius: 20px; font-size: .8em; } .btn-contribute { padding: 6px 8px; border: 1px solid #DF9C81; border-radius: 8px; background-color: #DF9C81; color: white; font-weight: bold; font-size: 1.1em; } .btn-secondary { border-color: #5BA4E5; color: #5BA4E5; } .btn-secondary:hover { border-color: #217fd2; color: #217fd2; } .btn-tertiary { border-color: #999999; color: #999999; } .btn-tertiary:hover { border-color: #737373; color: #737373; } .btn-large { padding: 10px 24px; font-size: 1.1em; } .btn-small { padding: 8px 12px; font-size: .7em; } .btn-mobile-menu { position: fixed; top: 0; right: 0; left: 0; z-index: 9999; display: none; width: 100%; height: 35px; border-bottom: 1px solid rgba(255, 255, 255, 0.1); background: rgba(51, 51, 51, 0.98); text-align: center; } .btn-mobile-menu__icon, .btn-mobile-close__icon { position: relative; top: 10px; color: #FFF; } nav { position: relative; display: inline-block; } .navigation { position: relative; float: left; display: inline-block; margin: 0; list-style-type: none; } .navigation__item { display: inline-block; margin: 5px 1px 0 0; line-height: 1em; } .navigation__item a { position: relative; display: block; border-color: #FFF; color: #FFF; opacity: .8; } .navigation__item a:hover { border-color: rgba(255, 255, 255, 0.3); background: rgba(255, 255, 255, 0.3); color: #FFF; opacity: 1; transition: all .3s; } .navigation--social a { padding: 6px 8px 6px 9px; border: 0px; } .navigation--social a .label { display: none; } .navigation--social a .icon { display: block; font-size: 1.7em; } i { font-weight: normal; font-style: normal; font-size: 18px; font-family: 'entypo'; } .social { font-size: 22px; } .icon-social { position: relative; display: block; font-size: 22px; font-family: 'entypo-social'; } *:focus { outline: none; } .wechat[data-v] { position: relative; } .qrCode[data-v] { position: absolute; bottom: 42px; left: -25px; display: none; width: 92px; height: 92px; background-color: #fff; text-align: center; } .wechat .qrCode .triangle-down[data-v] { position: absolute; bottom: -8px; left: 50%; margin-left: -6px; width: 0; height: 0; border-top: 10px solid #fff; border-right: 6px solid transparent; border-left: 6px solid transparent; } .wechat:hover .qrCode[data-v] { display: inline; } @media all and (max-width: 1100px) { .panel-title { font-size: 2em; } .panel-subtitle { font-size: 1em; } .panel-cover__description { margin: 0 10px; font-size: .9em; } .navigation--social { margin-top: 5px; margin-left: 0; } } @media all and (max-width: 960px) { .btn-mobile-menu { display: block; } .qrCode[data-v] { Margin: 0px 41%; } .panel-main { position: relative; display: table; } .panel-cover--collapsed { width: 100%; max-width: none; } .panel-main__inner { display: table-cell; padding: 60px 10%; } .panel-cover__description { display: block; margin: 0 auto; max-width: 600px; } .panel-cover { width: 100%; height: 100%; background-position: center center; } .panel-cover.panel-cover--collapsed { position: relative; display: block; padding: 0; height: auto; background-position: center center; } .panel-cover.panel-cover--collapsed .panel-main__inner { display: block; padding: 70px 0 30px 0; } .panel-cover.panel-cover--collapsed .panel-cover__logo { width: 60px; border-width: 2px; } .panel-cover.panel-cover--collapsed .panel-cover__description { display: none; } .panel-cover.panel-cover--collapsed .panel-cover__divider { display: none; margin: 1em auto; } .navigation-wrapper { position: fixed; top: 0; right: 0; left: 0; display: none; padding: 20px 0; width: 100%; border-bottom: 1px solid rgba(255, 255, 255, 0.15); background: rgba(51, 51, 51, 0.98); } .navigation-wrapper.visible { display: block; } .cover-navigation { position: relative; float: left; clear: left; display: block; width: 100%; } .cover-navigation .navigation { display: block; width: 100%; } .cover-navigation .navigation li { margin-bottom: .4em; width: 80%; } .cover-navigation.navigation--social { padding-top: 5px; } .cover-navigation.navigation--social .navigation li { display: inline-block; width: 25.8%; } .content-wrapper { margin: 0 auto; width: 80%; max-width: none; } .content-wrapper__inner { margin-right: 0; margin-left: 0; } .navigation__item { margin: 0 0 .4em 0; width: 100%; } } @media all and (max-width: 767px) { .panel-cover__logo { width: 100px; } .Weibo_icon_position { top: -6px; right: 35px; } .qrCode[data-v] { Margin: 0px 38%; } } @media all and (max-width: 480px) { .qrCode[data-v] { Margin: 0px 30%; } } @media all and (max-width: 340px) { .panel-main__inner { padding: 0 5%; } .panel-title { margin-bottom: .1em; font-size: 1.5em; } .panel-subtitle { font-size: .9em; } .btn, .navigation__item a { margin-bottom: .4em; } } 404 对不起，您要找的页面丢失了，(＞_＜；) Sorry, The page your requested can not be found, (＞_＜；) 可以向打小报告哦~ 404 © 2019 |"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2020-02-18T00:38:20.688Z","comments":false,"path":"video/index.html","permalink":"/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"主题Admin更改记录","slug":"Admin","date":"2050-12-11T16:00:00.000Z","updated":"2020-03-29T14:08:39.795Z","comments":true,"path":"2050/12/12/Admin/","link":"","permalink":"/2050/12/12/Admin/","excerpt":"","text":"记录一下Admin的进度2020.01.05主题选择看上个Vue写的Admin，虽然当初讲Vue的时候基本没听，但也还好其实。 用的是Vue Black Dashboard - v1.1.0 MarkDown其实一开始是想自己写的，写了半天吧，发现有点烦，于是就打算用现成的了。 由于是Vue，本来想用editor.md的，无奈不懂为什么有个CSS样式一直报错，说找不到。 后来只能决定用mavon-editor，因为网上我看好多人都是用这个的。就从众了，因为默认主题颜色是白的，首先就是改颜色。 然后，呵呵，改了一天，不知道为什么第三方组件有的样式改了是不生效的。尤其是mavon-editor的textarea文字颜色，怎么改也该不出来，好家伙最后发现是mavon-editor.js里居然把Auto-text里的样式用js全重写了一遍！！！ 难过…… 2020.01.06MarkDown样式基本调好后，解决了一下图片上传的问题。目前的想法是，上传图片后先将图片送到服务器上暂时保存，删除图片时也会从服务器上删除，最后在发布文章的时候再一次性从服务器上上传到腾讯的COS。现在可以暂存图片，COS上传还在解决子账户的问题。 上传图片时发现系统权限不够无法创建文件夹。不知道为什么windows默认使用的是user用户，明明还有很多可选偏偏选这个。使用axios时出现not define的错误，这个网上一堆，类比下就出来了。有时间真的要看看文件操作这部分。 Vue路由选的主题发现没有登陆选项，因为后台是和小伙伴一起用的，所以需要区别下，背景啦，上传URL啦什么的。然后学习了下路由，由于源码就是用了一个嵌套路由，默认path是&#39;/&#39;然后redirect到一个/dashboard下面。如果把原path改成别的会导致部分组件不显示。 明发现内部组件更换和TopNavBar下compute()方法有关 routeName() { const { name } = this.$route; return this.capitalizeFirstLetter(name); } 这个值会改变vue2-transitions的key值。来控制显示组件。具体没有细看。就直接再app和layout的mounted()里加了个判断，不符合直接跳到Login页面，简单粗暴。有时间一定要看看这个具体是怎么回事。 2020.01.07Login做了个登陆界面，感觉自己相当菜鸡， 暂时作废。。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"你说这知识咋就不进脑子呢","slug":"你说这知识咋就不进脑子呢","permalink":"/tags/你说这知识咋就不进脑子呢/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"主题更改记录","slug":"ThemeChange.log","date":"2050-12-11T16:00:00.000Z","updated":"2020-04-12T14:53:14.596Z","comments":true,"path":"2050/12/12/ThemeChange.log/","link":"","permalink":"/2050/12/12/ThemeChange.log/","excerpt":"","text":"记录一下改主题的东西吧目录什么的不用想了，不存在的。 CDN总有一天会换的。总有一天。 滚动条和顶部进度条这个主要修改CSS和JS的scrollbar类还有-webkit-scroll的相关样式和函数。 本身不难，就是东西都忘了，改了半天，然后发现在即蠢的一批。background: linear-gradient()的用法其实也是“偷”来的。个人感觉还可以，挺好看的。2019.12.19 backgroundcontent部分：这部分其实吧，就是加了个background-img: url()。其实一开始想做成能切换背景的样子，但是还是自己太蠢，样式调了半天也没弄出来，暂时放弃了。 top部分：就是换个url，在_config.yml里改。 index的centerpassage在figure下面加了俩div用来装passage图片，改了下sakura-app.js里的nextpassage()和prepassage()以及其初始化函数。周期性调用nextpassage()来换图。 使用Animate.css通过class进行淡入淡出（感觉好蠢的操作啊）。 由于是在顶部，position调整为absolute就好了。和contant的passage不一样，那个调成absolute就飞到顶端了。2019.12.20 aplayer部分主要就是改ID和servers，网易云私有的list似乎不能被访问。 一开始少了俩图标，重新建立个新的只改ID发现就好了，可能是之前瞎改layout的时候碰到点什么。2019.12.21 Back-to-top(cd-top)把原本的&lt;a&gt;去掉了，CSS还留着，然后“偷”了个球 是A-Obsidian的，本来想改颜色，发现咋改都有点丑。就同意了下蓝色。2333333333 最后加了个Topへ，就是像给个提示，原主题好像没有，好像。2019.12.25 nav删除了一些，这部分直接从_config.yml直接改，注意后面路径也要改，language下的zh-cn.yml也需要改，只有对应Category和tags存在才会生成文件夹。 目前不知道改怎么弄，还在调教，2333333 单页改动Archive的部分就是换了个图，改了个名字，_config.yml和language下zh-ch.yml都得改。 tags下面的似乎和WordPress的不一样，主要是Booklist，变成文章形式了。 tags要打booklist的名字，categorty不要写，不然会出现在Archive下面。2019.12.26 扒Re:stage(Re:ステージ！)官网部分一直觉得Re:stage的官网效果做的不错（其实也挺简单的动画，但由于是日本人做的，我觉得就很不错了。果然做游戏的审美都不差。哈哈哈），其实之前也偷偷扒拉过。这次完整的算是扒了一个小部分出来。就是角色介绍的那部分。艰难，他用了一个叫TweenMax的库来做动画，定义了一堆函数来回调用，找的我累死了，而且有的语法不再原页面就GG了，但是也没什么影响，可能是找不到元素吧。使用jQuery重写了一些必要的东西，本人很懒，还使用了TweenMax库，这中间真的被自己蠢爆了，名字大小写错了导致jQuery选择器选不到元素卡了半天。CSS很好搞，没什么，到时候微调一下样式就算结束。 数据部分，暂时没办法从Ejs的模板得到数据，不知道为啥，就是空。也不想一次性把所有人的信息放上来，由于整个bloc都没有用数据库，就这里用一个库感觉还不如整体重构一下。暂时卡住了呢。 目前是选择查库了，现在基本的取数据，查标签，删除标签都差不多了呢。动画也能很好的跟上。要不要在弄点其他的呢？ js失效一开始是把js都和去哪来的一样放在了footer.ejs里，但是这样一开是首页的时候就加载了，针对其他页面的js事件绑定是失败的。在到其他页面时候时间是不会触发的。似乎是因为用了Pjax进行的是局部刷新，js是不会重新被加载的。即使把js放到局部模块里。第一次是没问题，第二次访问还是失效，似乎是因为局部刷新不会加载第二次外部引用的js。于是想了个很蠢的方法就是在需要的模块前加上个&lt;script&gt;$.getScript();&lt;/script&gt;来重新加载需要的js。2020.01.01 一些细微调整主要是配置文件上的调整，然后看了看有些啥要留下，啥不留下。 之前一直忙着搞后台，自己本来的东西都忘了。现在争取每天有点进度 2020.1.19 live2D鼓捣了半天官方的SDK，一直有个属性赋值不成功。然后试了下hexo-helper-live2d，但是发现怎么也换不了模型，可能我有哪里没弄对吧。 然后又返回来鼓捣官方SDK，一步一步调试发现motion的JSON加载有问题，解包碧蓝航线的Live2D，用的perfare大佬的UnityLive2DExtractor提取的。 发现官方SDK读取motion的JSON时&quot;TotalPointCount&quot;会越界，也就是没等&quot;segments&quot;读完，顶点就用尽了，改一下顶点大小就能用官方的SDK显示了，顶点给多好像也没关系，但是现在我雪風的idle动作丢了很多，比如头发不飘了，耳朵也不动了，这些很明显。但是吸血鬼的似乎没看出来啥丢失的动作，头发也有飘，翅膀、裙子也有动。 被这个小东西卡了一天我TM也真的是蠢。 说真的，总有一日天，我会用自己的看板娘。 2020.01.21 好的，问题原因很简单，model3.json名字写错了，Idle写成了Idel，自己蠢爆了。 但是发现loop的的动画和CubismViewerForUnity的loop效果不一致，web的loop再结束一个动作后有一种快速倒放的感觉。 2020.01.25 鼓捣了一天，其实有的地方因为嫌烦没有好好看耽误了，目前loop倒放感觉依然不明，但是可以做到TapBody触发动作了model3.json中添加&quot;HitAeras&quot;字段，ID字段要和this._model._model.drawables.ids中相同意思字段吻合。具体内容需要进浏览器console里调试查看。这个可能我觉得可能和moc文件有关（我瞎说的，我什么也不知道，Editor我也只是打开过瞎鼓捣了半天）。 关于身体部位，目前只实现了Head和body，Body部分直接JSON里写就好，Head不止需要在JSON定义。lappdefine.ts中需要加入export const MotionGroupTapHead: string = &quot;TapHead&quot;;来定义一个动作控制。其次再lapplive2dmanager.ts的onTap方法里第一个判断头部哪里，原方法若点击头部是变化表情this._models.at(i).setRandomExpression();,有必要的话，换成和下面一样的this._models.at(i).startRandomMotion();，记得传参，第一个是刚刚定义的LAppDefine.MotionGroupTapHead,指定哪一个动作用的，第二个不变LAppDefine.PriorityNormal就好。 2020.01.27 放弃了，找不到调整模型的方法，看着一堆眼花缭乱的代码，还有恶心的日语注释（主要是片假名看着……）。打算还是用别人现成的东西吧。 2020.01.31 整理了下心情，好好翻了下manual，找到了放大模型显示的地方。 1、lapplive2dmanager下渲染前有个onUpdate()函数，在里面把矩阵大小放大就好。2、lappmodel下setupModel()中修改 Layout下_modelMatrix的scrale，这里如果参数是1，1的话是按照模型原本大小显示，一般会很大。做挂件的画一般在1一下。 模型的移动也可以在上回面两个地方完成，对矩阵调用translate()函数，参数仍是浮点，似乎是按照模型大小为1来计算位移。 回放问题出在动作没有loop。Sample是将你所有的动作放在了一个motion下的，然后每个动作结束后再选取动作压入队列。对于整个motion的loop没有开启的话不知道为什么就会有一个回放一样的。但是还只针对非人物的部分。你在motion里的loop设置是无效的。 妈的文档里其实说明了这个loop的问题。淦!!蠢爆了!!! 2020.02.01 整理下目前Live2D相关东西。 整个内容是用官方的Demo改的。目前整个主函数流程为： window.onload = (): void =&gt; { // create the application instance if (LAppDelegate.getInstance().initialize() == false) { return; } LAppDelegate.getInstance().run(); }; main.ts为主程序入口。首先初始化Canvas和WebGL的东西。包括Dom操作，事件函数绑定。接下来就是Live的View（用于显示的组件）和整个Cubism SDK的初始化。 View初始化就是视口大小和矩阵。 SDK包括Debug用日志、CubismFramework的初始化、Live2DManager的创建、时钟的更新和背景等其他素材的加载。比如原始Demo上面的那个话模型用的齿轮就是这个时候被加载的。 Live2DManager的构造函数包括的模型矩阵的设置，模型的创建的场景索引的更新。 更新场景时会通过LAppDefine中定义好的内容读取路径信息。调用LAppmodel的LoadAssets方法读model3.json的信息，这里用的时fetch()方法，所以是异步的。会继续先执行其他函数。文件加载完后会调用setupMpdel()函数，继续读取moc文件、和Expression、Physics、Motion等相关文件，均为异步执行。 接下来就是run()函数了。 public run(): void { // メインループ const loop = (): void =&gt; { // インスタンスの有無の確認 if (s_instance == null) { return; } // 時間更新 LAppPal.updateTime(); // 画面の初期化 gl.clearColor(0.0, 0.0, 0.0, 0.0); // 深度テストを有効化 gl.enable(gl.DEPTH_TEST); // 近くにある物体は、遠くにある物体を覆い隠す gl.depthFunc(gl.LEQUAL); // カラーバッファや深度バッファをクリアする gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); gl.clearDepth(1.0); // 透過設定 gl.enable(gl.BLEND); gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA); // 描画更新 this._view.render(); // ループのために再帰呼び出し requestAnimationFrame(loop); }; loop(); } 整体来讲定义了一个loop()函数作为主循环递归调用。 首先确定instance（实例）是否存在。然后是更新时间，画面的清空，启动深度测试，深度函数设置，清空颜色和深度Buffer，混合设置和混合函数设置，然后最最重要的画面渲染render()，最后是个递归的调用写法。（我猜） 主要说渲染，渲染包括背景和齿轮的绘制，然后用了个flush()，我猜是同步用的。然后获取Live2DManager实例然后调用Live2DManager的onUpdate()函数。 onUpdate()中依然首先整理好视口和Canvas大小以及矩阵的设置。接下来调用Model的Update()方法。这里面重要的就是模型动作的startRandomMotion().在这个方法里默认调用的是传入的是Idle的参数，所以会重复执行Idle的动作。但是此重复非循环播放。官方文档里说了。不能保证和编译器的循环一致，所以将循环设为false。这里只是因为之前loop的循环而导致一直执行这个函数，从而看起来好像有点别扭的循环Idle动作。 到这里就是一般的，很简单的说了下流程。要做挂件的话就是再矩阵、视口大小和Canvas的大小上改一改就好。 下面是点击事件，默认是supportTouch是false的，所以绑定的是click的函数。 clickBegan()没什么，重点是clickEnd()函数。这里获取了点击坐标后会调用view的onTouchesEnded()函数。在这里做了坐标变换。然后调用Live2DManager的onTap()函数。在这里对点击操作进行了hitTest()，判断击中的是那个区域。默认是对Head和Body的检测，检测是需要模型配合，似乎需要再编辑器里确定。然后根据Hit部位，调用startRandomMotion()函数确定动作或调用setRandomExpression()默认是Head调用后者，Body调用前者。 然后是自己的东西，添加了显示对话功能。通过打乱Demo的代码结构来达成自己不可告人的目的。加入了自己的事件和对话类。对话是储存在json文件里的，可以自己添加和更改。保持读文件操作一致性学习使用了fetch()来异步加载对话。事件就是简单的点击事件，因为Demo用的原生JS。所以依然保持使用基础Dom操作绑定事件。（写的时候有种回到了大一的感觉） 但是现在点击有时候不会触发动作，这个在原Demo上也有这个问题（也可能是我已经找不到原Demo误会了）。 已知问题sakura-app.js里的imgError函数突然开始报错说找不到。现在一脸懵逼中 由于CDN的问题，图片显示不完全和找不到 顶部导航栏Archive和list部分的下拉菜单突然效果变了 其实是和Animate.css的Keyframe重名了，改一下就好。 MarkDown解析有点问题，有的格式不支持 其实应该重构一下代码的，无奈我很懒，哈哈哈哈哈","categories":[{"name":"吐槽","slug":"吐槽","permalink":"/categories/吐槽/"}],"tags":[{"name":"你说这知识咋就不进脑子呢","slug":"你说这知识咋就不进脑子呢","permalink":"/tags/你说这知识咋就不进脑子呢/"},{"name":"吐槽","slug":"吐槽","permalink":"/tags/吐槽/"}],"keywords":[{"name":"吐槽","slug":"吐槽","permalink":"/categories/吐槽/"}]},{"title":"2020字节跳动校园招聘算法方向第三场考试 凉凉经","slug":"2020字节跳动校园招聘算法方向第三场考试 凉经","date":"2020-05-10T16:00:00.000Z","updated":"2020-05-11T06:58:27.477Z","comments":true,"path":"2020/05/11/2020字节跳动校园招聘算法方向第三场考试 凉经/","link":"","permalink":"/2020/05/11/2020字节跳动校园招聘算法方向第三场考试 凉经/","excerpt":"","text":"2020字节跳动校园招聘算法方向第三场考试 凉凉经第一题 字符串问题有个简单的编辑器，有4种命令：1 k 表示将字符串k插入到后面 2 k 表示删除后k个字符 3 k 表示输出第k个字符 4 表示撤销上次操作，指的是撤销1 2 操作。 这个其实很简单，就是字符串操作，撤销可以用个栈来维护之前1 2 的操作， 感觉数据很水所以很好过。 #include&lt;iostream&gt; #include&lt;string&gt; int main() { std::string str, laststr; int n; std::cin &gt;&gt; n; for (int i = 0; i &lt; n; ++i) { char cmd; std::cin &gt;&gt; cmd; switch (cmd) { case &#39;1&#39;: { std::string add; std::cin &gt;&gt; add; laststr = str; str += add; break; } case &#39;2&#39;: { int k; std::cin &gt;&gt; k; laststr = str; str.erase(str.end() - k, str.end()); break; } case &#39;3&#39;: { int k; std::cin &gt;&gt; k; std::cout &lt;&lt; str[k-1] &lt;&lt; std::endl; break; } case &#39;4&#39;: { str = laststr; break; } default: break; } } system(&quot;pause&quot;); return 0; } 第二题原题说给一篇文章，再给本词典，问有多少种翻译。不能翻译输出0 实际上是给一个字符串，再给个单词表，问有多少种划分能使每个部分都是单词表里的。例： &quot;abcba&quot; ab ba bc ca cb a 总共有两种划分方法 ab | cb | a a | bc |ba 说实话这个题除了暴力枚举我想不到别的做法，感觉像DP但是又不会DP 我暴力样例过了但是。。肯定超时对不对啊，不会优化了。 不要脸的贴代码了 #include&lt;iostream&gt; #include&lt;unordered_map&gt; #include&lt;string&gt; #include&lt;algorithm&gt; long long res; const long long mod = 835672545; int maxLen = 0; void find(std::string &amp;passage, std::unordered_map&lt;std::string, bool&gt; &amp;map, int index) { if (index &gt;= passage.size()) { ++res; res %= mod; return; } for (int i = index + 1; i &lt;= passage.size() &amp;&amp; (i - index) &lt;= maxLen; ++i) { std::string sub = passage.substr(index, i - index); if (map.find(sub) != map.end()) { find(passage, map, i); } } } int main() { std::string passage; std::cin &gt;&gt; passage; int n; std::cin &gt;&gt; n; std::unordered_map&lt;std::string, bool&gt; map; for (int i = 0; i &lt; n; ++i) { std::string temp; std::cin &gt;&gt; temp; map[temp] = true; maxLen = std::max(maxLen, (int)temp.size()); } find(passage, map, 0); std::cout &lt;&lt; res &lt;&lt; std::endl; system(&quot;pause&quot;); return 0; } 第三题有个人有n只袜子，每只袜子颜色为c_i，每只袜子也有编号，接下来m天要穿编号为a_i和b_i的袜子，因为两只袜子要一样颜色，所以这个人会提前染色，问接下来m天，最少染色次数。 读完题我是懵逼的，干啥呢这人。这里感觉还是DP但是又不会DP; 格式：先输入n袜子数n和天数m，然后接下来一行有n个数，第i个数代表编号为i的袜子颜色为c_i样例： 3 2 1 2 3 1 2 2 3 最少染色两次。 有个枚举思路是，一但两只袜子颜色不同那么必定要染色，那么就有两种情况，要么第一只染成第二只颜色，要么反过来，这样每天如果要染色就有两种情况，递归求解就好。 然而这里有一点，递归次数肯定不是m次，所以需要先保存每天要穿的袜子编号，然后再递归。 没错我就错在这里，哈哈哈哈哈哈哈哈哈哈，淦！ 修改后不知道能不能过，反正现在我不要脸的贴出来了。 #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; int res = 0x3f3f3f3f; void GetDown(std::vector&lt;int&gt; &amp;color, std::vector&lt;std::pair&lt;int, int&gt;&gt; &amp;day, int m, int sum) { if (m == 0) { res = std::min(res, sum); return; } int a = day[day.size() - m].first; int b = day[day.size() - m].second; if (color[a] != color[b]) { sum++; int temp = color[a]; color[a] = color[b]; GetDown(color,day, m - 1, sum); color[a] = temp; temp = color[b]; color[b] = color[a]; GetDown(color, day, m - 1, sum); color[b] = temp; } else { GetDown(color, day, m - 1, sum); } } int main() { int n, m; std::cin &gt;&gt; n &gt;&gt; m; std::vector&lt;int&gt; color(n + 1); std::vector&lt;std::pair&lt;int,int&gt;&gt; day(m); for (int i = 1; i &lt;= n; ++i) std::cin &gt;&gt; color[i]; for (int i = 0; i &lt; m; ++i) std::cin &gt;&gt; day[i].first &gt;&gt; day[i].second; int sum = 0; GetDown(color, day, m, sum); std::cout &lt;&lt; res &lt;&lt; std::endl; system(&quot;pause&quot;); return 0; } 第四题说实话看不懂忘了，找最长连续子序列并且要求序列中是完全平方数。 对我不懂完全平方数。 瞎扯经过这么多次笔试，现在感觉没有以前那种抓瞎的感觉了。（题做多了）虽然这次实习基本凉凉，但是有了方向，秋招好好准备！ 这里顺便测试下不用CDN的封面效果","categories":[{"name":"吐槽","slug":"吐槽","permalink":"/categories/吐槽/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"你说这知识咋就不进脑子呢","slug":"你说这知识咋就不进脑子呢","permalink":"/tags/你说这知识咋就不进脑子呢/"},{"name":"笔经面经凉凉经","slug":"笔经面经凉凉经","permalink":"/tags/笔经面经凉凉经/"}],"keywords":[{"name":"吐槽","slug":"吐槽","permalink":"/categories/吐槽/"}]},{"title":"腾讯暑期实习生招聘-常规批-软件开发综合凉凉经凉凉经","slug":"腾讯笔试凉经","date":"2020-04-25T16:00:00.000Z","updated":"2020-04-26T16:12:03.775Z","comments":true,"path":"2020/04/26/腾讯笔试凉经/","link":"","permalink":"/2020/04/26/腾讯笔试凉经/","excerpt":"","text":"腾讯暑期实习生招聘-常规批-软件开发综合凉凉经写在前面：这次代码有点乱，我觉得我应该是贴对了。 没错！我现在厚颜无耻的，恶心人的代码，没过的代码也不打算藏了，我就是要不要脸！！！ 第一题 实现队列要求实现“PUSH”，“POP”，“TOP”，“CLEAR”，“SIZE”。 POP不取得数据，无法POP时输出-1。TOP无数据时候输出-1，有数据输出队首。 这里看着真的是很简单，实际上也是简单。这里我一开始想着用vector的思路去写了，没注意到它的操作数最大是1000个操作。然后在另外开辟内存这里可能有点问题，导致总是过不去（看来真的需要看一眼源码了）。最后还是开了个大于操作数的数组来实现，最后过了。 这里贴一下代码吧。其实挺恶心的代码。 #include&lt;iostream&gt; #include&lt;string.h&gt; #include&lt;string&gt; struct Queue { int size; int* front; int* back; int* end; int element[2000]; //int* element; //int capicity; Queue() { this-&gt;size = 0; //capicity = 5; //element = new int[5]; back = front = element; //end = element + 5; } void push(int num) { *back=num; ++back; ++size; // if (back == end) // { // int* temp = new int[2 * capicity]; // memmove(temp, element, sizeof(int)*size); // capicity *= 2; // int* it = element; // element = temp; // front = element; // back = front + size; // *back = num; // back++; // end = element + capicity; // delete[] it; // } // else // { // *back = num; // back++; // } // size++; } void pop() { if (front == back) { std::cout &lt;&lt; -1 &lt;&lt; std::endl; return; } front++; size--; } int top() { if (front == back) return -1; return *front; } void clear() { front = back; size = 0; } int Size() { return this-&gt;size; } void distory() { delete[] element; } }; int main() { int t, n; std::cin &gt;&gt; t; while (t--) { Queue q; std::cin &gt;&gt; n; std::string s; int num; for (int i = 0; i &lt; n; ++i) { std::cin &gt;&gt; s; if (s == &quot;PUSH&quot;) { std::cin &gt;&gt; num; q.push(num); } else if (s == &quot;POP&quot;) q.pop(); else if (s == &quot;TOP&quot;) std::cout &lt;&lt; q.top() &lt;&lt; std::endl; else if (s == &quot;SIZE&quot;) std::cout &lt;&lt; q.Size() &lt;&lt; std::endl; else if (s == &quot;CLEAR&quot;) q.clear(); } q.distory(); } system(&quot;pause&quot;); return 0; } 第二题 点对间最短距离给出一个集合A，里面又坐标点（x,y），在给出一个集合B里面也有一些点。求这两个集合的点对之间的最短距离（欧式距离）。 这个题，说实话一开始想到的是平面内点对最小距离那个题，但好像思路不是很对。最后直接暴力了，但是很奇怪，暴力为什么是过0%且超时。好像应该是着急i，j写错了。 到时候再看看有没有什么好方法。 #include&lt;iostream&gt; #include&lt;cmath&gt; #include &lt;iomanip&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; int main() { std::vector&lt;std::pair&lt;int, int&gt;&gt; A; std::vector&lt;std::pair&lt;int, int&gt;&gt; B; std::vector&lt;double&gt; res; int t; std::cin &gt;&gt; t; while (t--) { int n; std::cin &gt;&gt; n; for (int i = 0; i &lt; n; ++i) { int x, y; std::cin &gt;&gt; x&gt;&gt; y; A.push_back(std::make_pair(x, y)); } for (int i = 0; i &lt; n; ++i) { int x, y; std::cin &gt;&gt; x&gt;&gt; y; B.push_back(std::make_pair(x, y)); } for (int i = 0; i &lt; A.size(); ++i) { for (int j = 0; j &lt; B.size();j++) { long long x = (A[i].first - B[j].first) * (A[i].first - B[j].first); long long y = (A[i].second - B[j].second) * (A[i].second - B[j].second); res.push_back(std::sqrt((x + y))); } } std::sort(res.begin(), res.end()); std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(3) &lt;&lt; res[0] &lt;&lt; std::endl; } return 0; } 第三题 翻牌子（DP？）给出一组纸牌，正面有ai，背面是bi，每次操作可以交换相邻两个牌，然后翻面，求是一组牌非降序排列的最少次数。 这个题吧，好像也在哪里见过，类似的一个将一个数组通过交换变成按升序排列。但是，嘿嘿嘿，我忘了。 有时间再做一下把。 第四题 两个栈实现队列这个不知道是哪里得原题吧？？？就是用两个栈实现队列操作。 思路简单，准备两个栈in和out，如果有push直接压入in，当有top和pop时，如果out为空，再将in压入out，否则直接返回out或pop out。 这个题我可能也是侥幸，因为第一次交75%超时，手抖了一下又交了一遍95%超时，再交一回，过了！ 玄学 #include&lt;iostream&gt; #include&lt;stack&gt; #include&lt;string&gt; int main() { std::stack&lt;int&gt; s1; std::stack&lt;int&gt; s2; int n; std::cin&gt;&gt;n; std::string s; for(int i=0;i&lt;n;++i) { std::cin&gt;&gt;s; if(s==&quot;add&quot;) { int num ; std::cin&gt;&gt;num; s1.push(num); } else if (s==&quot;poll&quot;) { if(!s2.empty()) s2.pop(); else { while(!s1.empty()) { s2.push(s1.top()); s1.pop(); } s2.pop(); } } else if(s==&quot;peek&quot;) { if(!s2.empty()) std::cout&lt;&lt;s2.top()&lt;&lt;std::endl; else { while(!s1.empty()) { s2.push(s1.top()); s1.pop(); } std::cout&lt;&lt;s2.top()&lt;&lt;std::endl; } } } return 0; } 第五题 二叉树给出一个无限深的满二叉树，节点标号从1开始，再给出一个节点编号x和深度k。求x在k深度的父亲节点编号，没有输出-1。 这个思路很简单，先找到x的深度d，然后比较k和d，若k小于d，向上找就行，否则就-1。 但是很神奇，牛客的样例我过了，但是交题告诉我格式不正确，再跑样例的时候就自动交卷了。（悲）！！！好像这个还要快速幂才能过。 #include&lt;iostream&gt; int main() { int t; std::cin&gt;&gt;t; long long x,k; while(t--) { std::cin&gt;&gt;x&gt;&gt;k; long long i=1,deep=1; while(i&lt;=x) { i&lt;&lt;=1; deep++; } i&gt;&gt;=1; deep--; while(deep!=k) { x&gt;&gt;=1; deep--; } std::cout&lt;&lt;x&lt;&lt;std::endl; } return 0; }","categories":[{"name":"吐槽","slug":"吐槽","permalink":"/categories/吐槽/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"你说这知识咋就不进脑子呢","slug":"你说这知识咋就不进脑子呢","permalink":"/tags/你说这知识咋就不进脑子呢/"},{"name":"笔经面经凉凉经","slug":"笔经面经凉凉经","permalink":"/tags/笔经面经凉凉经/"}],"keywords":[{"name":"吐槽","slug":"吐槽","permalink":"/categories/吐槽/"}]},{"title":"2020字节跳动校园招聘算法方向第二场考试凉凉经","slug":"字节跳动凉经","date":"2020-04-11T16:00:00.000Z","updated":"2020-04-12T14:51:53.523Z","comments":true,"path":"2020/04/12/字节跳动凉经/","link":"","permalink":"/2020/04/12/字节跳动凉经/","excerpt":"","text":"2020字节跳动校园招聘算法方向第二场考试凉凉经说到底还是自己菜，真的不行。 第一题 数组转换问题给出两个数组A，B，其中再A中找出一个区间r-l，使得这个区间的所有数都加上K后和B一样。输出A是否可以转换为B 这个挺简单的。遍历一遍，在第一个不同的地方差一下。然后用这个差去判断剩下不一致的地方差是否一样，不一样就不能，并且区间只能存在一个。出现第二个区间也不能。 这里贴一个比较菜鸡的AC代码吧，说实话代码烂的自己也看不下去。 #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;cmath&gt; int main() { int t; std::cin &gt;&gt; t; while (t--) { int n; std::cin &gt;&gt; n; std::vector&lt;int&gt; a(n); std::vector&lt;int&gt; b(n); for (int i = 0; i &lt; n; ++i) std::cin &gt;&gt; a[i]; for (int i = 0; i &lt; n; ++i) std::cin &gt;&gt; b[i]; bool flag = false, YES = true; int count = 0, diff = 0; for (int i = 0; i &lt; n; ++i) { if (a[i] != b[i]) { if (!flag) { if (count == 0) { flag = true; count++; diff = std::abs(a[i] - b[i]); } else { std::cout &lt;&lt; &quot;NO&quot; &lt;&lt; std::endl; YES = false; break; } } } if (flag) { if (a[i] == b[i]) { flag = false; continue; } if (std::abs(a[i] - b[i]) != diff) { std::cout &lt;&lt; &quot;NO&quot; &lt;&lt; std::endl; YES = false; break; } } } if (YES) std::cout &lt;&lt; &quot;YES&quot; &lt;&lt; std::endl; } system(&quot;pause&quot;); return 0; } 第二题 掰木棍 （考的二叉树？ 我也不知道，我也不理解）给出n个木棍，对于这n个木棍中，可以将任意一个掰成两半，这两半必须是整数。掰完后放回原位置，也就是说原位置左边有数，掰完后两个数都放在哪个数的右边，原位置右边有数，掰完后两个数都放在那个数的左边。求最少掰几次可以使得所有木棍不递减排列。 样例： 输入： 5 3 5 13 9 12 输出：1 因为13 可以掰成5和8，所以序列变为3 5 5 8 9 12 完成。 这个题。。说实话没啥思路。。本来想看见一个不符合升序，就把他掰成样例的格式，但是想了一下，如果有3 5 4 9 这样的序列，5变成3 2 就会成 3 3 2 4 9，就意味着2之前都要掰，然后就不知道怎么办了。有时间继续看看。 第三题 买东西（没看出来啥类型的问题）现在你有N张优惠券，当买的东西价格大于等于优惠卷面值时候可以使用，使用后不收回，还可以继续使用。问买M个东西花钱最少是多少。 这个想法就是先排序。两个都排序，从小到大。然后用买的东西去找第一个不能使用的优惠券，那么前一张优惠券就是可以使用的最大面值。如果所有优惠卷都可以用，那么久使用面值最大的优惠券来购买。 输入第一行n，m表示优惠券数和购买东西数二三行分别是优惠卷面值和购买价格（不保证排序） 样例： 输入 3 4 50 100 200 99 199 200 300 输出 248 利用这个想法实现的代码（个人写的）只过了40% 超时（我觉得我贴对代码了） 精污提醒c++ #include&lt;iostream&gt; #include&lt;deque&gt; #include&lt;algorithm&gt; int main() { int n, m; std::cin &gt;&gt; n &gt;&gt; m; std::deque&lt;int&gt; discount(n); std::deque&lt;int&gt; buy(m); for (int i = 0; i &lt; n; ++i) std::cin &gt;&gt; discount[i]; for (int i = 0; i &lt; m; ++i) std::cin &gt;&gt; buy[i]; std::sort(discount.begin(), discount.end()); std::sort(buy.begin(), buy.end()); long long res = 0; int i = 0 ; if (n == 0 || m == 0) { for (int i = 0; i &lt; m; ++i) res += buy[i]; std::cout &lt;&lt; res &lt;&lt; std::endl; return 0; } while (!buy.empty()) { if (i &gt;= discount.size()) { res += (buy[0] - discount[discount.size() - 1]); i = 0; buy.pop_front(); continue; } if (buy[0] &gt;= discount[i]) i++; else { if (i == 0) res += buy[0]; else res += (buy[0] - discount[i - 1]); buy.pop_front(); i = 0; } } std::cout &lt;&lt; res &lt;&lt; std::endl; system(&quot;pause&quot;); return 0; } 这里我觉得优化的放在于优惠券。应该在一个时间点删除一定量优惠券。我觉得可以如果用的优惠券是第二张就删除第一张。 为什么没写呢？因为其实这里是第一次使用deque，对他不是很熟悉。尤其是pop_front()复杂度是O(1)还是O(n)。也就是他要不要把所有元素前移。事实是，不需要移动。但是当时以为是O(n)，就换用优先队列，其实也行，但是有一点。STL优先队列是大顶堆。笔试时候忘了这一点，浪费了半个多小时。最后2min才想起来。然后改小顶堆时候格式还忘了需要指定容器类型。哇。悲惨。看源码他默认是vector以为一直就按默认走了。没想到指定比较规则后需要显示直指定容器类型。priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt;就是一个小顶堆了，记住啊！！！！！ 其实感觉写了应该也过不了，我觉得应该有其他方法，比如，二分查找。可以deque排序后调用std::lower_bound()找第一个大于等的优惠券。这样就是O(nlogn)，我觉得才能过。 为什么笔试时候没想到。。。因为笔试时候没人说话，也不敢对着小黄鸭说。。。 小黄鸭调试大法好！！！！ 不过还是自己菜。这是最大的实话。 第四题 地铁换乘（图论？）你再1号地铁站，公司再n号地铁站。你要去上班，但是换乘很麻烦，你拥有地铁的所有信息，信息格式为（u,v,w）意思是从U号站到V号站的线路属于w线路。求少换成次数。输入第一行是n，m公司再n号地铁站，接下来m行为地铁信息。样例： 输入:3 3 1 2 2 2 3 2 1 3 1 输出 1 因为可以从一号直接坐2号线到3，所以做一次。 这里的想法是，先找出n号站有哪些line，1号站有哪些line，同时找出1号站没有的line。看n号站有的line，1号站有没有，有就输出1，因为直达。没有就找n站有的line和1号没有的line的差集，这些line就是目标line。找出这些line的from。找出1号站有的line的to，再找出1号线没有的from。每找出一个连起来到目标line的线，记录最小换线次数就好。 这里没写完，感觉写完了也过不了没甚至思路我感觉后面都有点迷糊。等看看有没有OJ吧。 总结起来还是那句话，自己太菜，还得多多巩固基础，多多刷题。","categories":[{"name":"吐槽","slug":"吐槽","permalink":"/categories/吐槽/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"你说这知识咋就不进脑子呢","slug":"你说这知识咋就不进脑子呢","permalink":"/tags/你说这知识咋就不进脑子呢/"},{"name":"笔经面经凉凉经","slug":"笔经面经凉凉经","permalink":"/tags/笔经面经凉凉经/"}],"keywords":[{"name":"吐槽","slug":"吐槽","permalink":"/categories/吐槽/"}]},{"title":"网易互娱2021届实习生招聘在线笔试－游戏研发工程师 凉凉经？？","slug":"网易互娱笔试凉经","date":"2020-04-10T16:00:00.000Z","updated":"2020-05-08T08:26:09.630Z","comments":true,"path":"2020/04/11/网易互娱笔试凉经/","link":"","permalink":"/2020/04/11/网易互娱笔试凉经/","excerpt":"","text":"网易互娱2021届实习生招聘在线笔试－游戏研发工程师 凉凉经？？第一题 模拟（贪心？）题目引子是传说中的40m长刀，在一个M×M的地图上，主角手持长L的大刀，有数个道具在格子上，用刀砍掉道具可以让刀变长。主角不会移动。问游戏结束时候，主角的刀最长有多少。 输入首先是样例数T 然后是地图大小M和刀的长度L，然后是一个矩阵，矩阵中不为0的是道具，得到可以使刀加长那个数据，然后是主角坐标。样例： 6 1 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 1 0 0 0 0 0 0 0 1 0 2 1 2 答案是2 因为我在（1，2）位置，最近的是（1，3）的道具，刀为1；可以砍刀，然后刀长为2，接下来最近的是（3，3），离（1，2）有$\\sqrt{5}$的长度，大于刀长，所以最终为2. 整个题就是读入道具坐标和道具数值，然后计算道具距离主角距离。按距离从小到大排序，依次看能不能砍道就好，一个小贪心。贴出一个一般般的AC代码吧 #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; struct item { int x; int y; int distance; int weight; item() = default; item(int _x, int _y, int _weight) :x(_x), y(_y), weight(_weight) {}; }; int distance(int px, int py, int x, int y); bool distancecmp(item a, item b); int main() { int t; std::cin &gt;&gt; t; while (t--) { int m, l; std::cin &gt;&gt; m &gt;&gt; l; std::vector&lt;item&gt; v; for (int i = 0; i &lt; m; ++i) { for (int j = 0; j &lt; m; ++j) { int num; std::cin &gt;&gt; num; if (num == 0) continue; v.push_back(item(i, j, num)); } } int px, py; std::cin &gt;&gt; px &gt;&gt; py; for (int i = 0; i &lt; v.size(); ++i) { v[i].distance = distance(px, py, v[i].x, v[i].y); } std::sort(v.begin(), v.end(), distancecmp); for (int i = 0; i &lt; v.size(); ++i) { int ll = l * l; if (ll &lt; v[i].distance) { std::cout &lt;&lt; l&lt;&lt;std::endl; l = 0; break; } else l += v[i].weight; } if(l) std::cout &lt;&lt; l&lt;&lt;std::endl; } system(&quot;pause&quot;); return 0; } int distance(int px, int py, int x, int y) { int rx = px - x, ry = py - y; return rx * rx + ry * ry; } bool distancecmp(item a, item b) { return a.distance &lt; b.distance; } 第二题 并查集的问题有1——N个数，开始每个数都各自为一个集合，要求实现以下操作 给出x，y。将y并到x下面，如果两个本来就在一个集合，则什么也不做 给出x，将x拿出来单独作为一个集合，如果x本身只有一个元素，则什么也不做。 给出x，输出x所在集合元素个数。 输入首先是样例数T，然后是 数据个数n和操作数m接下来m行 第一个数OP为1时，接下来根两个数x，y。OP为2时执行操作2，OP为3时候输出元素个数。 这里其实刚做题目的时候第二个操作没看懂，如果要独立的元素时头头的话，他底下的元素是独立出N个集合？还是合并到其中一个里去？最后看样子似乎是第一种，独立出N个集合。 当时看到这个题整个人都是CNM的状态，听说7号互联网那边考了个并查集，觉得互娱不会考这个，难度应该接近雷火前两个吧。结果考了个并查集，然后我还忘了怎么压缩路径。啊！天啊！其实就是find里变了个x =find()！！！！蠢哭了自己。 这里给个垃圾的一批的70%代码吧 降智打击c++ #include&lt;iostream&gt; #include&lt;vector&gt; struct element { int value; std::vector&lt;int&gt; next; int pre; int num; }; int find(std::vector&lt;element&gt; &amp;v, int x) { return v[x].pre == x ? x : find(v, v[x].pre); } void Union(std::vector&lt;element&gt; &amp;v, int x, int y); void cut(std::vector&lt;element&gt; &amp;v, int x); int count(std::vector&lt;element&gt; &amp;v, int x); int main() { int t; std::cin &gt;&gt; t; while (t--) { int n, m; std::cin &gt;&gt; n &gt;&gt; m; std::vector&lt;element&gt; v(n + 1); for (int i = 1; i &lt;= n; ++i) { v[i].value = i; v[i].pre = i; v[i].num = 1; } for (int i = 0; i &lt; m; ++i) { int op; std::cin &gt;&gt; op; if (op == 1) { int x, y; std::cin &gt;&gt; x &gt;&gt; y; Union(v, x, y); } else if (op == 2) { int x; std::cin &gt;&gt; x; cut(v, x); } else if (op == 3) { int x; std::cin &gt;&gt; x; std::cout &lt;&lt; count(v, x) &lt;&lt; std::endl; } } } system(&quot;pause&quot;); return 0; } void Union(std::vector&lt;element&gt; &amp;v, int x, int y) { x = find(v, x); y = find(v, y); if (x == y) return; v[find(v, x)].num += v[find(v, y)].num; v[y].pre = x; v[x].next.push_back(y); } void cut(std::vector&lt;element&gt; &amp;v, int x) { if (v[x].next.size() == 0 &amp;&amp; v[x].pre != v[x].value) { v[find(v, x)].num--; int y = v[x].pre; v[x].pre = v[x].value; v[y].next.pop_back(); return; } if (v[x].pre == x &amp;&amp; v[x].next.size() == 0) return; if (v[x].pre == x) { for (int i = 0; i &lt; v[x].next.size();++i) { v[v[x].next[i]].pre = v[x].next[i]; } v[x].next.clear(); v[x].num = 1; } else { v[find(v, x)].num--; int z = v[x].pre; for (int i = 0; i &lt; v[x].next.size(); ++i) { v[z].next.push_back(v[x].next[i]); v[v[x].next[i]].pre = z; } v[x].pre = v[x].value; v[x].next.clear(); v[x].num = 1; } } int count(std::vector&lt;element&gt; &amp;v, int x) { return v[find(v,x)].num; } 加入路径压缩代码应该不用贴了。。就改一个地方，当然不知道能不能过。但是应该比70%要再高一点。 第三题 数学？个人感觉是个数学问题。题目引子是组合问题中的错排问题。就是简单看了一下题，没看懂就。。。。简单说一下吧 错排就是与原排列每个位置上的数都不一样的排列比如1 2 3 的一个错排就是 2 3 1。而 3 2 1不是，因为2的位置是一样的。 给出一个排列A，让你找一个错排B然后定义了一个距离$$ Distance(A,B)=V_1|Pos_{A1} - Pos_{B1}| + V_2|Pos_{A2} - Pos_{B2}| + \\cdots + V_n|Pos_{An} - Pos_{Bn}| $$求这个距离的最小值。 个人就是这个距离怎么也没看懂。 样例： 输入 123 123 输出 7 输入 4321 1111 输出 4 有时间鼓捣一下，这个，现在还得看看之前的。 这次笔试算是目前感觉最好的一次了。但还是要加强学习！！继续努力！！！","categories":[{"name":"吐槽","slug":"吐槽","permalink":"/categories/吐槽/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"你说这知识咋就不进脑子呢","slug":"你说这知识咋就不进脑子呢","permalink":"/tags/你说这知识咋就不进脑子呢/"},{"name":"笔经面经凉凉经","slug":"笔经面经凉凉经","permalink":"/tags/笔经面经凉凉经/"}],"keywords":[{"name":"吐槽","slug":"吐槽","permalink":"/categories/吐槽/"}]},{"title":"2020米哈游春季校园招聘程序B卷凉凉经","slug":"米哈游凉经","date":"2020-04-02T16:00:00.000Z","updated":"2020-04-11T14:44:07.650Z","comments":true,"path":"2020/04/03/米哈游凉经/","link":"","permalink":"/2020/04/03/米哈游凉经/","excerpt":"","text":"2020米哈游春季校园招聘程序B卷凉凉经我草泥马自己实在是太菜了，菜死了，垃圾啊！ 第一部分 不定项选择考察下列内容 c++ 虚函数部分 操作系统 组原？ Linux fork clone exec 计算机网络 IP和一个select什么的？？？ 不了解 基本读程序 栈忘了 第二部分 正则表达式 二叉树真巧我这两个都没复习到。直接凉凉正则表达式给出一个字符串s 给出一个规则，规则包括(、)、.、,()表示必须匹配（）内字符。.表示匹配任意字符，表示匹配前面0个活多个字符。输出为s是否满足规则。 感觉好像能直接用regex？ 其实后来写了个把字符串按规则扫一遍的代码，但是。。。最后一秒也没交上去。主要他给的格式是牛客上《剑指Offer》那个格式，是个类。而个人做题还是面向过程的main函数。所以忙着看复制到哪里合适的时候，时间到了，惨 菜鸡 惨。而代码，，，不小心给覆盖掉了所以。没留底。哇，祸不单行。 二叉树一个计算机连接系统连接方式为二叉树方法，给出一个字符串，1代表有计算机，0代表没有。字符串组成只有0、1.字符串的是按BFS给出的。现在要设置监控计算机，每个监控计算机只能监控一个计算机。问，若所有计算机（监控计算机除外）都被监控，问监控计算机有多少台，若无法完成监控并没有重复监控的情况下输出0； 例：字符串为“11100111”，监控计算机为字符串位置的 1 6 7号计算机。 就是每个监控节点变成只能监控一个的监控二叉树。 说实话没啥好说的，菜的一批，啥也不会。 有时间还是返回来看。","categories":[{"name":"吐槽","slug":"吐槽","permalink":"/categories/吐槽/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"你说这知识咋就不进脑子呢","slug":"你说这知识咋就不进脑子呢","permalink":"/tags/你说这知识咋就不进脑子呢/"},{"name":"笔经面经凉凉经","slug":"笔经面经凉凉经","permalink":"/tags/笔经面经凉凉经/"}],"keywords":[{"name":"吐槽","slug":"吐槽","permalink":"/categories/吐槽/"}]},{"title":"网易游戏雷火2020春招游戏研发工程师笔试0329凉凉经","slug":"网易雷火笔试凉经","date":"2020-03-28T16:00:00.000Z","updated":"2020-04-11T14:44:20.725Z","comments":true,"path":"2020/03/29/网易雷火笔试凉经/","link":"","permalink":"/2020/03/29/网易雷火笔试凉经/","excerpt":"","text":"网易游戏雷火2020春招游戏研发工程师笔试0329凉凉经第一次笔试心里慌得很，四个小时下来膀胱快炸了也不敢离开（向夏哥看齐）。脑细一片混乱，只记得写大概。把能记得的写一下 第一题斐波那契数列问题相关。给定两个字符串F1，F2，F3=F2+F1，F4=F3+F2…………，求Fn中每个字母出现次数，F1、F2小于10；N&lt;40 这个第一眼看上去好家伙求Fn再统计嘛， string f1,f2,res; for (int i = 3; i &lt;= n; ++i) { res = f1 + f2; f1 = f2; f2 = res; } 这个会爆内存，然后就想着先统计f1,f2中个数，再用斐波那契去求。这里就用到了map。但是当时不知道怎么想的，可能觉得，呀，这么简单的怎么WA了，被吓到了，逻辑一下十分混乱。导致胡乱判断，胡乱使用函数。这里贴一下，记录下自己的SB行为。SB的地方注释见 小心污染智商c++ #include&lt;iostream&gt; #include&lt;string&gt; #include&lt;map&gt; #include&lt;algorithm&gt; using namespace std; int main() { int n = 0; cin &gt;&gt; n; string f1, f2; map&lt;char, int&gt; mapf1; map&lt;char, int&gt; mapf2; cin &gt;&gt; f1 &gt;&gt; f2; for(int i=0;i&lt;f1.size();++i) { int counter = count(f1.begin(),f1.end(),f1[i]); //这里本来统计出出现次数了，相同情况下应直接等或不做处理，但是当时混乱的莫名其妙就+=了。要是有aaa这样的字符串，第一步就错了。 if(mapf1.find(f1[i])==mapf1.end()) mapf1[f1[i]] = counter; else mapf1[f1[i]] += counter; } for(int i=0;i&lt;f2.size();++i) { int counter = count(f2.begin(),f2.end(),f2[i]); //和上面一样。 if(mapf2.find(f2[i])==mapf2.end()) mapf2[f2[i]] = counter; else mapf2[f2[i]] += counter; } // 这里，这里是不熟悉map导致的，明明不可能却满脑子想的map怎么直接对位加，还怕中间声明个temp结束循环数据会丢。后来试了一下发现好像不会丢。所以res和temp字面意义与实际用途相反了。 map&lt;char, int&gt; temp(mapf1); for (int i = 3; i &lt;= n; ++i) { map&lt;char, int&gt; res(mapf1); // 这里好像也有点问题，但是具体在哪里呢？ for (auto it = mapf2.begin(); it != mapf2.end(); ++it) { if (res.find(it-&gt;first) == res.end()) res[it-&gt;first] = it-&gt;second; else res[it-&gt;first] += it-&gt;second; } mapf1 = mapf2; mapf2 = res; temp = res; } for (auto it = temp.begin(); it != temp.end(); ++it) { cout &lt;&lt; it-&gt;first &lt;&lt; &quot;:&quot; &lt;&lt; it-&gt;second &lt;&lt; endl; } return 0; } 这里再各贴一个事后稍微冷静下的，由于没有合适的OJ判断，我也不知道能不能过，但是我觉得应该差不多了 #include&lt;iostream&gt; #include&lt;map&gt; #include&lt;string&gt; int main() { int n; std::cin&gt;&gt;n; std::string f1,f2; std::map&lt;char,int&gt; mapf1; std::map&lt;char,int&gt; mapf2; std::map&lt;char,int&gt; mapres; std::cin&gt;&gt;f1&gt;&gt;f2; for(int i=0;i&lt;f1.size();++i) { mapf1[f1[i]]++; } for(int i=0;i&lt;f2.size();++i) { mapf2[f2[i]]++; } if(n==1) mapres=mapf1; if(n==2) mapres=mapf2; for(int i=3;i&lt;=n;++i) { for(auto it = mapf2.begin();it!=mapf2.end();++it) { mapf1[it-&gt;first]+=it-&gt;second; } mapres = mapf1; mapf1 = mapf2; mapf2 = mapres; } for(auto it = mapres.begin();it!=mapres.end();++it) { std::cout&lt;&lt;it-&gt;first&lt;&lt;&quot;:&quot;&lt;&lt;it-&gt;second&lt;&lt;std::endl; } system(&quot;pause&quot;); return 0; } 第二题打怪的有N个怪物，击杀每只怪物用Tmin，每只怪物经过Lmin后逃走，战斗中怪物不会逃跑。击杀后获得经验值E求最多可获得多少经验。 这个题一开始吓到我了，给的样例一开始也没看懂，瞬间失去思路，然后跑去看第三题，结果大脑变得更加混乱不堪了。 这个题最后想法是，按照逻辑走一遍。也就是贪心。每次挑单位时间内获取经验值最多的怪来打。直到所有怪逃走。这里再次贴出精神污染，其中有一个超级超级蠢的错误，导致贪心都没贪对 严重精污c++ #include&lt;iostream&gt; #include&lt;string&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; using namespace std; const int N = 1000000; struct Monster { int t; int e; float v; }; bool cmp(const Monster a, const Monster b) { return a.v &gt; b.v; } void value(vector&lt;Monster&gt; &amp;monsters, const int t) { // 说老实话，这个函数我自己看着都恶心 for (int i = 0; i &lt; monsters.size(); ++i) { monsters[i].t -= t; if (monsters[i].t &lt;= 0) { monsters.erase(monsters.begin() + i); i--; continue; } else monsters[i].v = (float)monsters[i].e / monsters[i].t; } } int main() { int n, t; cin &gt;&gt; n &gt;&gt; t; vector&lt;Monster&gt; monsters; for (int i = 0; i &lt; n; ++i) { Monster m; cin &gt;&gt; m.t &gt;&gt; m.e; m.v = (float)m.e / m.t; monsters.push_back(m); } //注意这里。 sort(monsters.begin(), monsters.end(), cmp); int exp = 0; while (monsters.size() != 0) { // 重点来了，这里一定少点啥。 exp += monsters[0].e; monsters.erase(monsters.begin()); value(monsters, t); //对没错，少再排序，不说了，我是蠢死的 } cout &lt;&lt; exp &lt;&lt; endl; return 0; } 但是就算加上排序我觉得应该还是过不了，所有又有个想法。计算出每只怪物能撑我几个T，这个数暂时设为x，然后再x相同的怪物中选出经验最多的哪个来打。然后累加这些最大的经验。 这里还是贴一下这个想法的代码，当然不知道能不能过，我觉得比我上面那个靠谱。 #include&lt;iostream&gt; #include&lt;vector&gt; struct Monster{ int leave; int exp; }; int main() { int n,t; std::cin&gt;&gt;n&gt;&gt;t; std::vector&lt;Monster&gt; vec(n); std::vector&lt;int&gt; exps(n); for(int i=0;i&lt;n;++i) { std::cin&gt;&gt;vec[i].leave; std::cin&gt;&gt;vec[i].exp; } for(int i=0;i&lt;n;++i) { exps[vec[i].leave/t+(vec[i].leave%t==0?0:1)] =std::max(exps[i],vec[i].exp); } int exp=0; for(int i=0;i&lt;n;++i) { exp+=exps[i]; } std::cout&lt;&lt;exp&lt;&lt;std::endl; return 0; } 第三题这个题很长很长，第四题更长，文字有点多，加上心乱了。说句实话没读好题，可能连最简单的部分都理解错了。下面是我回想起的逻辑和题意。 在一个空节点下面有一些组件。组件类型有文字和图片，文字属性有中心坐标x，y，宽和高w，h，和实例ID，图片属性有中心坐标x，y，宽和高w，h，实例ID和贴图名称。贴图有名字和ID，字体有ID，字体的ID就文字的ID，贴图的ID就是图片的ID。 再一个节点下，组件依靠深度值排列， 深度值计算，若一个组件不和任何组件重合，depth=1 若有重合，看能不能batch（贴图相同或字体类型相同） 若能batch则深度相同， 若不能则取深度最大？还是+1来着？ 若深度相同看实例id若有多个可取，取不能batch的哪个 然后依照depth排序。 计算DrawCall的数量。能Batch的算一次。 具体真的记不清了，等能拿到题的话再做一遍。 关键就是要注意坐标问题，长宽记得要除2，y坐标是负的。（然而这些下来才反应过来的呢）接下来就是判断物体间是否重合（碰撞检测？？），然后是深度计算。读清楚题应该是没问题的。被引擎惯坏的，看着很亲切，实则很混乱。现在反应过来自己连题都没看懂就死磕了2个多小时。连考试都不会了。 第四题简单看了一下，和动画有关系，坐标的旋转问题。彻底没动。也是，能拿到题的话好好看看。 总结 心态还是不稳，不如说越来越不稳了，容易慌，得想想办法了。 看懂题是真的重要，仔细读题，要沉下心来。 基础东西基本忘光了，现在开始要捡起来，先不要再纠结其他的了，这次看来基础是相当重要的。 想到什么大胆尝试一下，不要畏畏缩缩，就算WA再换方法嘛。","categories":[{"name":"吐槽","slug":"吐槽","permalink":"/categories/吐槽/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"你说这知识咋就不进脑子呢","slug":"你说这知识咋就不进脑子呢","permalink":"/tags/你说这知识咋就不进脑子呢/"},{"name":"笔经面经凉凉经","slug":"笔经面经凉凉经","permalink":"/tags/笔经面经凉凉经/"}],"keywords":[{"name":"吐槽","slug":"吐槽","permalink":"/categories/吐槽/"}]},{"title":"D3D渲染管线和Shader的一些事","slug":"Shader&HLSL","date":"2020-03-23T16:00:00.000Z","updated":"2020-04-11T14:44:27.090Z","comments":true,"path":"2020/03/24/Shader&HLSL/","link":"","permalink":"/2020/03/24/Shader&HLSL/","excerpt":"","text":"index？ Input Assembler Stage 输入装配阶段 Vertex Shader Stage 顶点着色器阶段 Tessellating Gometry Stage 镶嵌处理阶段 Hull Shader Stage 外壳着色器阶段 Tessellator Stage 曲面细分阶段 Domain shader Stage 域着色器阶段 Geometry Shader Stage 几何着色器阶段 Stream Output Stage 流输出阶段 Rasterizer Stage 光栅化阶段 Pixel Shader Stage 像素着色器阶段 Output Merger Stage 合并输出阶段 1 Input Assembler Stage 输入装配阶段这个阶段其实就是读取显存中我们存储的顶点和索引数据。按照所设置好的图元拓扑根据索引装配顶点。装配结果会被送VS（Vertex Shader） 这里从顶点的创建开始说明。 首先需要先定义顶点的结构体比如 struct Vertex { DirectX::XMFLOAT3 Pos; DirectX::XMFLOAT3 Normal; DirectX::XMFLOAT2 TexC; }; 接下来，为了让Direct3D知道怎么对待我们的数据，需要填写输入布局描述（Input Layout Description） typedef struct D3D12_INPUT_LAYOUT_DESC { const D3D12_INPUT_ELEMENT_DESC *pInputElementDescs; UINT NumElements; } D3D12_INPUT_LAYOUT_DESC; 而实际上描述布局的是其中的D3D12_INPUT_ELEMENT_DESC typedef struct D3D11_INPUT_ELEMENT_DESC { LPCSTR SemanticName; UINT SemanticIndex; DXGI_FORMAT Format; UINT InputSlot; UINT AlignedByteOffset D3D11_INPUT_CLASSIFICATION InputSlotClass; UINT InstanceDataStepRate; } D3D11_INPUT_ELEMENT_DESC; LPCSTR SemanticName：关于shader输入参数的HLSL的语义。 UINT SemanticIndex：语义的索引，用于给相同语义的变量，比如一个顶点由两组Texture，可以再不引入新语义的情况下区分他们。未指定默认为1。 DXGI_FORMAT Format：通过DXGI_FORMAT的变量来指定元素的类型。 UINT InputSlot：指定元素传入的输入槽，Direct3D支持16个（0~15）输入槽。可以通过输入槽来向输入装配阶段传递顶点数据。 UINT AlignedByteOffset：输入槽中数据的偏移量，一个结构体元素中会有多个变量，需要确定偏移量才能正确找到变量。 D3D11_INPUT_CLASSIFICATION InputSlotClass：单个输入槽的表示类。具体参照D3D12_INPUT_CLASSIFICATION UINT InstanceDataStepRate：与实例化技术有关，置为1意味着要是用实例化技术。 针对上述顶点，D3D11_INPUT_ELEMENT_DESC可填写为 { { &quot;POSITION&quot;, 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 }, { &quot;NORMAL&quot;, 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 12, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 }, { &quot;TEXCOORD&quot;, 0, DXGI_FORMAT_R32G32_FLOAT, 0, 24, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 }, }; 接下来就要准备顶点数据了。为了让GPU能得到数据，需要把顶点数据放到GPU资源（显存）中。DirectX12中使用ID3D12Resource来管理。 要创建ID3D12Resource首先需要填写D3D12_RESOURCE_DESC typedef struct D3D12_RESOURCE_DESC { D3D12_RESOURCE_DIMENSION Dimension; UINT64 Alignment; UINT64 Width; UINT Height; UINT16 DepthOrArraySize; UINT16 MipLevels; DXGI_FORMAT Format; DXGI_SAMPLE_DESC SampleDesc; D3D12_TEXTURE_LAYOUT Layout; D3D12_RESOURCE_FLAGS Flags; } D3D12_RESOURCE_DESC; D3D12_RESOURCE_DIMENSION Dimension：资源维度，使用D3D12_RESOURCE_DIMENSION 填写。 UINT64 Alignment;：没查到，一般为0。 UINT64 Width;：资源的宽度，对于缓冲区资源则是缓冲占用字节数。 UINT Height;：资源的高度。 UINT16 DepthOrArraySize;：资源深度（对于3DTexture），对于1D、2DTexture则表示数组大小。 UINT16 MipLevels：minmap的层数。 DXGI_FORMAT Format;：资源格式，使用DXGI_FORMAT填写 DXGI_SAMPLE_DESC SampleDesc;：采样器描述，使用DXGI_SAMPLE_DESC填写，实际上和多重采样（MSAA）有关，描述中设置了采样质量级别和采样次数。 D3D12_TEXTURE_LAYOUT Layout;：资源的layout，使用D3D12_TEXTURE_LAYOUT填写。 D3D12_RESOURCE_FLAGS Flags;：与资源有关的杂项标志位，使用D3D12_RESOURCE_FLAGS填写。 这里其实Direct3D 12提供了个包装类CD3DX12_RESOURCE_DESC，他派生自D3D12_RESOURCE_DESC，可以简化我们的创建过程。 填写完描述后就可以用它来再现存上开辟一块适合的空间了。创建该堆使用的是ID3D12Device::CreateCommittedResource方法 HRESULT CreateCommittedResource( const D3D12_HEAP_PROPERTIES *pHeapProperties, D3D12_HEAP_FLAGS HeapFlags, const D3D12_RESOURCE_DESC *pDesc, D3D12_RESOURCE_STATES InitialResourceState, const D3D12_CLEAR_VALUE *pOptimizedClearValue, REFIID riidResource, void **ppvResource ); const D3D12_HEAP_PROPERTIES *pHeapProperties：一个指向堆所具有的属性的指针，这里可以使用CD3DX12_HEAP_PROPERTIES 类来创建，所以一般情况只用关注D3D12_HEAP_TYPE就可以，这个类型稍后说明。 D3D12_HEAP_FLAGS HeapFlags：和堆有关的额外标志选项，参照D3D12_HEAP_FLAGS，通常使用D3D12_HEAP_FLAG_NONE/ const D3D12_RESOURCE_DESC *pDesc：一个指向D3D12_RESOURCE_DESC的指针，藐视待创建的资源。 D3D12_RESOURCE_STATES InitialResourceState：资源的初始状态。 const D3D12_CLEAR_VALUE *pOptimizedClearValue：描述一个用于清除资源的优化值，可以为NULL。 REFIID riidResource：希望获得的ID3D12Resource的接口的COM ID。 void **ppvResource：新建的资源的指针。 这里其实还有一种创建资源堆的方式ID3D12Device :: CreatePlacedResource有机会会说。 关于显存上堆的资源类型 typedef enum D3D12_HEAP_TYPE { D3D12_HEAP_TYPE_DEFAULT, D3D12_HEAP_TYPE_UPLOAD, D3D12_HEAP_TYPE_READBACK, D3D12_HEAP_TYPE_CUSTOM } ; D3D12_HEAP_TYPE_DEFAULT：默认堆，只允许GPU访问，所以速度最快。D3D12_HEAP_TYPE_UPLOAD：上传堆，向这里提交的都是要CPU上传到GPU的资源。D3D12_HEAP_TYPE_READBACK：回传堆，向这里提交的资源是需要CPU读取的资源。D3D12_HEAP_TYPE_CUSTOM：应用于高级特性。 显然，我们需要让GPU读取顶点资源，放在默认堆是比较合适的。但是CPU又不能直接访问，于是需要使用上传堆来完成顶点资源向显存的移动。这就需要创建两个堆，一个使用D3D12_HEAP_TYPE_DEFAULT一个使用D3D12_HEAP_TYPE_UPLOAD。 然后为了告诉Direct3D我们要提交什么样的数据，需要填写一个描述D3D12_SUBRESOURCE_DATA typedef struct D3D12_SUBRESOURCE_DATA { const void *pData; LONG_PTR RowPitch; LONG_PTR SlicePitch; } D3D12_SUBRESOURCE_DATA; 然后就可以使用UpdateSubresources函数来上传顶点资源了。 当然这里是CPU和GPU“一起工作”，这自然就遇到同步问题。对于D3D12，我们用资源屏障D3D12_RESOURCE_BARRIER来同步资源状态。 typedef struct D3D12_RESOURCE_BARRIER { D3D12_RESOURCE_BARRIER_TYPE Type; D3D12_RESOURCE_BARRIER_FLAGS Flags; union { D3D12_RESOURCE_TRANSITION_BARRIER Transition; D3D12_RESOURCE_ALIASING_BARRIER Aliasing; D3D12_RESOURCE_UAV_BARRIER UAV; }; } D3D12_RESOURCE_BARRIER; 然后就可以使用ID3D12GraphicsCommandList::ResourceBarrier方法来设置资源屏障。在使用资源之前和使用后都要记得同步资源属性。同样，依然有一个包装类CD3DX12_RESOURCE_BARRIER可以帮助我们简化创建操作。 当然，不是所有的顶点都会被送到默认堆上，一些需要频繁改动的对象的顶点这么操作就不合适，所以这类顶点可以就放在上传堆上。 到这里我们的数据才算是准备好了，接下在就是真正的输入装配阶段。我们需要调用三个方法来完成这个阶段 ID3D12GraphicsCommandList::IASetVertexBuffers ID3D12GraphicsCommandList::IASetIndexBuffer ID3D12GraphicsCommandList::IASetPrimitiveTopology 首先第一个方法是向渲染管线提供顶点，接下来分别是提供顶点索引和设置图元拓扑(primitive topology)。 为什么要提供顶点索引和图元拓扑，因为一堆顶点可以有许多种连接方式，而我们想要的只是其中的一种。图元拓扑就是说明顶点之间应该以什么方式进行连接。而图元拓扑从D3D_PRIMITIVE_TOPOLOGY选择。 2 Vertex Shader Stage 顶点着色器阶段图元被装配完毕后，顶点就会被送入VS(Vertex Shader)。这时候就需要使用着色器语言(Shader Language)来编写VS。VS可以实现很多东西，例如变换，光照，位移贴图等。而最多应用的就是顶点的变换处理。 我们知道3D模型的顶点都是按照局部空间的方式储存的。所以我们需要将局部空间坐标变换为世界空间坐标。而要做的只是仅仅需要给顶点坐标乘上以个世界坐标矩阵就可以了。但是这其实还不算完，我们只是将局部坐标变成了世界坐标。为了构建场景的2D图形，还需要一台摄像机，对世界坐标做取景变换(view transform)，取景变换使用的矩阵成为变换矩阵(view matrix)。最后我们需要做的就是把坐标投影到齐次剪裁空间中，就是我们得到的画面坐标。投影要做的被称为透视投影变换(perspective projection transformation)。 所以,基本的VS写法应该为:以顶点下列顶点为例 struct Vertex { DirectX::XMFLOAT3 Pos; DirectX::XMFLOAT3 Normal; ...... }; 则顶点着色器可以写成下列形式 // 定义输入顶点,应与c++文件中定义一致 struct VertexIn { // 冒号后为语义，和之前填写的输入布局描述的语义相同 float3 PosL : POSITION; float4 Color : COLOR; ...... }; // 定义输出顶点,可根据需要增加变量 struct VertexOut { float4 PosH : SV_POSITION; float4 Color : COLOR; ...... }; // 定义顶点着色器 VertexOut VS(VertexIn vin) { // 定义输出顶点 VertexOut vout; // 顶点坐标与世界矩阵相乘,局部坐标变换为世界坐标 float4 posW = mul(float4(vin.PosL, 1.0f), gWorld); // 世界坐标与观察矩阵和投影矩阵相乘,投影到齐次剪裁空间中 vout.PosH = mul(posW, gViewProj); // 顶点的颜色处理后和处理前保持一致 vout.Color = vin.Color; ...... ...... // 返回变换后顶点 return vout; } 顶点着色器会对每个顶点调用一次，但是是在GPU中进行，会并行计算，速度还是很快的。 接下来如果没有其他需求,就可以直接送入像素着色器了 3 Tessellating Gometry Stage 镶嵌处理阶段作为一个可选阶段，曲面细分阶段是渲染管线中对几何图形进行向前处理的三个阶段————外壳着色器阶段，镶嵌器阶段和域着色器阶段。这里所做的工作就是把几何体细分成更小的三角形，并以某种方式，把生成的顶点偏移到合适的位置。说白了就是在这个阶段通过几个着色器把低模变高模。 那为什么不直接使用高模？ 考虑如果一个物体距离摄像机很远，那么这个时候对于这种物体人们一般很少注意，所以，使用高模就很浪费空间，也为后面计算增加负担。在这里就可以通过距离摄像机判断是否进行和进行什么程度的镶嵌化处理。 在考虑如果一个物体根本不在视锥体（摄像机所看到的范围）内，那么就可以删除掉这部分的片面。如果是高模，这部分计算也会比较庞大，低模通过较小的代价，可以减少后续的一些计算，而且还省内存。 如果要进行曲面细分，我就不向输入装配阶段提交三角形。而是提交具有若干控制点的面片。图元类型使用D3D_PRIMITIVE_TOPOLOGY中的类型。当然三角形可以看作具有三个控制点的面片，所以依然可以提交普通的三角形网络。 3.1 Hull Shader Stage 外壳着色器阶段首先，外壳着色器（HS）实际上由两种着色器组成： 常量外壳着色器(constant hull shader) 控制点外壳着色器(control point hull shader)3.1.1 常量外壳着色器(constant hull shader) 常量外壳着色器将每一个面片的控制点作为输入（即一次只输入一个面片中的控制点），每处理一个面片就会调用一次。其工作是输出网格的曲面细分因子(Tessellation factor)。曲面细分因子指的是面片将要在曲面细分阶段中镶嵌处理后的份数。现在说一个将一个具有四个控制点的四边形面片从各方面分成三份的例子： // 首先要定义每个片面需要的信息作为常量外壳着色器的输出 struct PatchTess { // SV_TessFactor语义表示几何图形边缘细分份数 float EdgeTess[4] : SV_TessFactor; // SV_InsideTessFactor语义表示几何图形内部细分份数 float InsideTess[2] : SV_InsideTessFactor; ...... }; // 然后可以正式定义常量着色器 // 外壳着色器在顶点着色器之后，自然使用顶点着色器的输出作为输入。在这里就用InputPatch&lt;&gt;模板定义，VertexOut是VS的输出结构体，4代表我们的面片具有4个控制点。SV_PrimitiveID语义提供了面片的位标识。 PatchTess ConstantHS(InputPatch&lt;VertexOut, 4&gt; patch, uint patchID : SV_PrimitiveID) { // 声明输出变量。 PatchTess pt; pt.EdgeTess[0] = 3; // 面片左边缘份数 pt.EdgeTess[1] = 3; // 面片上边缘份数 pt.EdgeTess[2] = 3; // 面片右边缘份数 pt.EdgeTess[3] = 3; // 面片下边缘份数 pt.InsideTess[0] = 3; // 面片内部细分列数 pt.InsideTess[1] = 3; // 面片内部细分行数 ...... return pt; } 对于四边形，镶嵌化处理有两个部分， 4个边缘曲面细分因子对应边缘细分份数 两个内部曲面细分因子说明了如何对内部进行镶嵌化处理。 对于三角形来说，镶嵌化也是两个部分， 3个边缘曲面细分因子对应边缘细分份数 一个内部曲面细分因子表示三角形面片的镶嵌份数。 3.1.2 控制点外壳着色器(control point hull shader)控制点外壳着色器将控制点作为输入和输出，对每个控制点都会调用一次控制点外壳着色器。其应用之一是改变曲面的表示方式，如将一个普通的三角形转换成三次贝塞尔三角形面片（一个具有10个控制点的面片）一个简单的例子： // 定义HS的输出 struct HullOut { float3 PosL : POSITION; }; [domain(&quot;quad&quot;)] [partitioning(&quot;integer&quot;)] [outputtopology(&quot;triangle_cw&quot;)] [outputcontrolpoints(4)] [patchconstantfunc(&quot;ConstantHS&quot;)] [maxtessfactor(64.0f)] HullOut HS(InputPatch&lt;VertexOut, 4&gt; p, uint i : SV_OutputControlPointID, uint patchId : SV_PrimitiveID) { // 声明输出变量 HullOut hout; // 这里的HS其实是就是个传递的作用，没有改变什么值 hout.PosL = p[i].PosL; return hout; } 我们可以看到HS的前面多了很多[]括起来的内容，和C#的Attribute相似。没错，这个是Shader Model中的东西。更多可以看看Shader Model 5 Attributes这里就解释一下上面提到的 domain():定义了HS中使用的面片类型。可选参数为”tri”、”quad”、”isoline” partitioning()：定义了HS使用的镶嵌方案(tesselation scheme,不知道翻译好没)，可选参数为”integer”、”fractional_even”、”fractional_odd”、” pow2”。 3.2 Tessellator Stage 曲面细分（镶嵌器）阶段这个阶段由硬件自动完成，程序员无法干预。对于镶嵌化处理的结果，emmmmmmm，放两张图吧。 3.3 Domain shader Stage 域着色器阶段镶嵌器阶段会输出新生成的顶点与三角形。对于此阶段所创建的所有顶点都会依次调用域着色器(DS)。所以DS实际上和顶点着色器类似，是对已镶嵌完成的顶点进行处理的着色器。DS以曲面细分因子、控制点以及镶嵌画处理后的定点位置参数坐标(u,v)作为输入。这里的定点位置参数不是实际位置，而是位于面片域空间(patch domain space)的参数坐标。可以利用控制点和这些坐标来求出真正的坐标。下面使用双线性插值来求。（其他也可以，只是书中例子是这个） struct DomainOut { float4 PosH : SV_POSITION; }; [domain(&quot;quad&quot;)] DomainOut DS(PatchTess patchTess, float2 uv : SV_DomainLocation, const OutputPatch&lt;HullOut, 4&gt; quad) { // 声明输出变量 DomainOut dout; // 这里就是双线性插值 //lerp(u,v,t)是基于t∈[0，1]，在u，v之间进行线性插值 float3 v1 = lerp(quad[0].PosL, quad[1].PosL, uv.x); float3 v2 = lerp(quad[2].PosL, quad[3].PosL, uv.x); float3 p = lerp(v1, v2, uv.y); // 转换为世界坐标 float4 posW = mul(float4(p, 1.0f), gWorld); // 投影到齐次剪裁矩阵中 dout.PosH = mul(posW, gViewProj); return dout; } 4 Geometry Shader Stage 几何着色器阶段由于曲面细分阶段是一个可选阶段，几何着色器（GS）输入数据是一组完整的图元（其实也就是一组顶点？？），输出为几何着色器一大特点就是可以创建和销毁几何图形。利用GS可以做到点精灵的拓展、动态粒子系统、皮毛的申城、阴影体积的生成等效果。比较巧的是GS有一个简单的模板可以套用： // 输出顶点的最大数量 [maxvertexcount(N)] void Name (PrimitiveType InputVertexType InputNmae[NumElements],inout StreamOutputObject&lt;OutputVertexType&gt; OutputName) { ...... } GS每次调用前必须先制定可输出的定点最大数量，这里用属性[maxvertexcount()]来指定。 对于参数，第一个参数的构成为 图元类型 输入定点类型 数据名字，图元类型可用”point”（点）、”line”（线）、”triangle”（三角形）、”lineadj”（线列表及其邻接图元或线条带及其临界图元）、”triangleadj（三角型列表及其邻接图元或三角形带及其邻接图元）”，第二个参数首先是inout关键字，这个一定要有，而且他使用了一个模板类型流类型。流类型存有一系列顶点，定义了几何着色器输出的几何图形。几何着色器可以通过内置方法Append()向输出流添加顶点。void StreamOutputObject&lt;OutputVertexType&gt;::Append(OutputVertexType v); 对于流类型，其模板参数用指定输出顶点的类型，并且有三种类型。 PointStream&lt;OutPutVertexType&gt; // 一系列顶点所定义的点列表 LineStream&lt;OutPutVertexType&gt; // 一系列顶点所定义线条带 TriangleStream&lt;OutPutVertexType&gt; // 一系列顶点所定义三角形带 几何着色器输出的顶点会构成由流类型指定的图元，但是流类型未包括线条列表和三角形列表。其实可以使用内置函数RestartStrip()来实现线条列表和三角形列表。void StreamOutputObject&lt;OutputVertexType&gt;::RestartStript();想要实现三角形列表，需要在每次向流输出追加三个顶点后调用一次RestartStript()。线条列表则是没追加两个顶点后调用RestartStript()。这里给出一个将一个点拓展成一个四边形的例子，也就是“公告牌技术” // 这里假设不进行曲面镶嵌阶段，所以直接使用VS的输出 struct VertexOut { float3 CenterW : POSITION; float2 SizeW : SIZE; }; // 定义几何着色器的输出 struct GeoOut { float4 PosH : SV_POSITION; float3 PosW : POSITION; float3 NormalW : NORMAL; float2 TexC : TEXCOORD; uint PrimID : SV_PrimitiveID; }; // 指定GS输出顶点数最多为4个 [maxvertexcount(4)] void GS(point VertexOut gin[1], uint primID : SV_PrimitiveID, inout TriangleStream&lt;GeoOut&gt; triStream) { //这里计算精灵(Sprite)的局部坐标系与世界空间的相对关系。使得之后的四边形与和y轴对齐并面向观察者 float3 up = float3(0.0f, 1.0f, 0.0f); float3 look = gEyePosW - gin[0].CenterW; look.y = 0.0f; // 对齐y轴，使四边形立在xz平面上 look = normalize(look); float3 right = cross(up, look); // 计算四边形的宽和高，用来计算顶点坐标 float halfWidth = 0.5f*gin[0].SizeW.x; float halfHeight = 0.5f*gin[0].SizeW.y; // 开始计算顶点坐标 float4 v[4]; v[0] = float4(gin[0].CenterW + halfWidth*right - halfHeight*up, 1.0f); v[1] = float4(gin[0].CenterW + halfWidth*right + halfHeight*up, 1.0f); v[2] = float4(gin[0].CenterW - halfWidth*right - halfHeight*up, 1.0f); v[3] = float4(gin[0].CenterW - halfWidth*right + halfHeight*up, 1.0f); // 纹理坐标的操作 float2 texC[4] = { float2(0.0f, 1.0f), float2(0.0f, 0.0f), float2(1.0f, 1.0f), float2(1.0f, 0.0f) }; // 将四边形的顶点变化为世界坐标，并且以三角形带形式输出。 GeoOut gout; // for循环属性 unroll指的是展开循环，直到停止执行。 [unroll] for(int i = 0; i &lt; 4; ++i) { gout.PosH = mul(v[i], gViewProj); gout.PosW = v[i].xyz; gout.NormalW = look; gout.TexC = texC[i]; gout.PrimID = primID; triStream.Append(gout); } } 关于for循环的属性可以看这里 SV_PrimitiveID语义是一个无符号的整形参数，指定了这个语义，输入装配阶段就会自动为每个图元生成一个ID，每个ID的都是唯一的。尽管这里没有使用，但是GS将ID写入顶点中，下面的像色着色器中可以使用。 Stream Output Stage 流输出阶段流输出阶段就是将集合着色器的顶点数据连续输出到一个或多个缓冲区中，和几何着色器紧密联系在一起的。 6 Rasterizer Stage 光栅化阶段其实在光栅化之前还有一个阶段叫裁剪，在这个阶段会将完全位于视锥体之外的几何体全部丢弃，而对于一部分在外面的几何体也会被实施裁剪(clip)的操作。 光栅化阶段实际也是一个不可编程阶段，其功能是为投影在主屏幕上的3D三角形计算出对应的像素颜色。光栅化阶段中主要干了以下事情 视口变换 背面剔除 顶点属性插值6.1 视口变换 裁剪完成后硬件会通过透视除法，将物体从齐次裁剪空间变化为规格化设备坐(NDC)。一旦物体顶点坐标在NDC空间内，构成2D图像的2D顶点x，y坐标就会被变换到后台缓冲区中被称为视口(view port)的矩形中。变换完成后顶点坐标都是以像素为单位的。视口变换不会影响深度值（z坐标）。 6.2 背面剔除这里我们需要先了解什么是正面,什么是背面。 对于一个顶点为V0、V1、V2的三角形 $e_0 = V_1 - V_0$ $e_1 = V_2 - V_0$ 法向量为$$n = \\tfrac{e_0 \\times e_1}{e_0 \\times e_2}$$法向量从正面射出,则另一面为背面。 若观察者看到的是正面,则称三角形是正面朝向(front-facing)的否则称三角形为背面朝向(back-facing)的。 对于大多数物体而言,背面朝向的三角形都被正面朝向的所遮挡,绘制他们是没用的,所以背面剔除就是除去这些没用三角形. 6.3 顶点属性插值顶点中不止可以存放位置信息,还可以存放像颜色、法向量、纹理坐标等属性。视口变换后需要为三角形的每个像素所附有的属性进行插值。这部分使用的插值方法为透视矫正插值(perspective correct interpolation)，这个计算由硬件完成。 7 Pixel Shader Stage 像素着色器阶段像素着色器(PS)的输入是光栅化阶段期间输出的对顶点属性的插值。PS会对每一个像素片段进行处理,并根据顶点的插值属性作为输入来计算出对应的所以像素颜色,PS既可以返回一种单一恒定颜色,以实现逐像素光照(per-pixel linghting)、反射(reflection)、阴影(shadow)等效果。 像素片段并不一定是最后写入后台缓冲区中，有时候会有多个像素片段。需要通过一些规则来确定最后写入后台缓冲区的像素片段是哪一个。也就是说，像素着色器所做的工作就是为了计算颜色。最简单的像素着色器可以写成下列形式 // 定义输入顶点,应与c++文件中定义一致 struct VertexIn { // 冒号后为语义，和之前填写的输入布局描述的语义相同 float3 PosL : POSITION; float4 Color : COLOR; ...... }; // 定义输出顶点,可根据需要增加变量 struct VertexOut { float4 PosH : SV_POSITION; float4 Color : COLOR; ...... }; // 这里假设只存在VS和PS，所以VS输出就是PS输入 // SV_Target语义表示返回值类型应当与目标格式（render targer format）相匹配 // 而着色器本身只是输出了颜色插值 float4 PS(VertexOut pin) : SV_Target { return pin.Color; }; 关于像素着色器其实有很多很多有用的地方，值得好好弄弄，之后有机会也会说说。 8 Output Merger Stage 合并输出阶段也是一个不可编程阶段像素着色器生成的像素片段会会被送到合并输出阶段(OM)，该阶段中一些像素片段就会被丢弃。剩下的将会写入后台缓冲中。其中混合(Blend)操作也是在这个阶段实现的。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"你说这知识咋就不进脑子呢","slug":"你说这知识咋就不进脑子呢","permalink":"/tags/你说这知识咋就不进脑子呢/"},{"name":"DirectX","slug":"DirectX","permalink":"/tags/DirectX/"},{"name":"Shader","slug":"Shader","permalink":"/tags/Shader/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"NLP_EmotionClassfied","slug":"NLP_EmotionClassfied","date":"2020-02-11T16:00:00.000Z","updated":"2020-03-24T12:43:20.941Z","comments":true,"path":"2020/02/12/NLP_EmotionClassfied/","link":"","permalink":"/2020/02/12/NLP_EmotionClassfied/","excerpt":"","text":"不谈理论，不谈公式，就说用啥能实现！1. 整体过程 读取训练数据，调整数据格式。 对数据进行分词（字），可以按词，也可以按字。 统计词（字）频，建立词典（字典）。 对每个词（字）建立索引。 将之前分好词（字）的每个句子用索引替换。 调整句子长度，多的截取，少的补0。 建立模型 训练。 2. 详细说明2.0 导包其实这是句废话，不导包怎写代码？ import numpy as np; import tensorflow as tf; import jieba; # 用于分词 import re; # 用于删除特殊字符 import pandas as pd; # 用于统计词频，其实也可以用Tensorflow自己的Tokenizer 2.1 读取训练数据由于任何人的训练数据不一样，格式千奇百怪，整理方式也不尽相同，先说一下最终的样子吧。 简单来讲需要分成两个list，一个label用来存放标情感标记。一个sentencesList用于存放句子。 这里用自己的txt来举例子。 首先数据格式如下 1,&quot;距离川沙公路较近,但是公交指示不对,如果是&quot;&quot;蔡陆线&quot;&quot;的话,会非常麻烦.建议用别的路线.房间较为简单.&quot; ··· ··· 0,说实在的我很失望，之前看了其他人的点评后觉得还可以才去的，结果让我们大跌眼镜。我想这家酒店以后无论如何我都不会再去了。 第一个为label,1表示积极，0表示消极，之后为语句。我们只需要按行读取，先存标记，然后出去标点等特殊符号，接着将语句存入list就好。 在这个部分其实就可以使用jieba进行分词操作。这里就加上了。 lineList = []; lable = []; with open(&quot;ChnSentiCorp_htl_all.txt&quot;,encoding=&quot;utf-8&quot;) as file: for line in file: if(line[0]==&quot;1&quot;): lable.append(1); else: lable.append(0); line = re.sub(&#39;[’!&quot;#$%&amp;\\&#39;()*+,-./:;&lt;=&gt;?@[\\\\]^_`{|}，。（）/《》！~#￥%……&amp;*？：；”“‘’【】、\\n|]+&#39;,&#39;&#39;,line); lineList.append(list(jieba.cut(line[1:]))); 插一句题外话，这里肯定有人要问Python还打分号？不好意思，个人习惯，C++和JAVA写多了，习惯性打的，甚至还习惯性补分号，反正Python也不算错，还请见谅。 好的我们来看，首先with open()常规操作打开文件。对每一行进行读取，并判断第一行的label，接下来使用re进行特殊符号的删除。然后使用jieba对从第二个字符开始之后的字符串进行分词操作，因为第一个是label不需要他。 2.2 分词操作上面确实做了，如果没错可以在这里做。当然暂时我为了求快没有按字分。可能以后会写吧。 2.3 统计词（字）频，建立字典建立字典是为了其实是为了下一步的索引，索引是为了方便计算，数字的计算和查找要比字符串方便而且快得多。所以最后训练数据是很多条索引组成的句子。 这里使用的pandas来统计。 word_dictionary =[]; for line in lineList: for word in line: word_dictionary.append(word); print(word_dictionary); wordNum = pd.Series(word_dictionary).value_counts(); wordNum = wordNum[wordNum&gt;=5]; 首先是个笨办法，遍历每一个单词，然后添加进一个list（因为list不去重）。接着就是建立一个pandas.Series对象调用value_counts()方法统计词频。返回值是一个Series对象。里面储存了词和次出现的次数。 2.4 对每个词（字）建立索引。这里做的很简单，就是把频率换成索引就好。但是要注意，索引要从1开始，0用于填充补齐。还有就是，我们选择出现频率比较高的词，因为计算速度。但实际上低频词也未必不起到关键作用，滑稽保命之类的对吧？ wordNum = wordNum[wordNum&gt;=5]; # 保留词频大于等于5的词 wordNum[:] = list(range(1,len(wordNum)+1)); # 依照频率高低将频率换成索引， wordNum[&#39;&#39;] = 0; # 添加空的索引为0 首先是提取词频大于5的词，然后将频率换成索引，然后添加0索引。 2.5 用索引替换句子sentencesi = []; for line in lineList: sentenceindex = []; for word in line: if word in wordSet: sentenceindex.append(wordNum[word]); sentencesi.append(sentenceindex); 就是个替换，我觉得没啥可说的，就是遍历一遍所有单词，如果词再字典里那么久转换成索引添加进来，没有就放弃。 2.6 调整句子长度，多的截取，少的补0。为了计算速度，这里同时使用固定长度的句子，因此就要多截少补。 X =list(tf.keras.preprocessing.sequence.pad_sequences(sentencesi,maxlen=50)); 这里选取最大长度为50。当然好一点的方法是先统计一下句子长度，找一个能包含大多数完整句子的长度。 2.7 建立模型和训练。模型这里很简单的随便建立了一个，层数，损失函数和优化函数都可以看情况换，我是看有篇文章这么做了，我就这么写了。 x_train = np.array(X); y_train = np.array(lable); model = tf.keras.Sequential(); model.add(tf.keras.layers.Embedding(input_dim=len(wordSet),output_dim=200,input_length=50)); model.add(tf.keras.layers.LSTM(128)); model.add(tf.keras.layers.Dropout(0.5)); model.add(tf.keras.layers.Dense(1,activation=&quot;sigmoid&quot;)); model.compile(loss=&#39;binary_crossentropy&#39;, optimizer=&#39;rmsprop&#39;, metrics=[&#39;accuracy&#39;]); print(model.summary()); model.fit(x_train, y_train, batch_size=16, epochs=250); 这里因为是2分类所以就用sigmoid了，多分类要用softmax，将来会做一个多分类的。 补充3.1 程序说明整个程序习惯性的面向过程了。所以上面代码全部按顺序crtl+c、crtl+v下来差不多就能用了。为了流程叙述方便所以这么写了。而且为了快，很多地方没有优化，速度肯定还可以再快，再者为了维护，实际上最终要用的话最好面向对象一下。 其中需很多多西想重复用的话其实可以保存一下。像是模型，字典什么的。而且要生产开发用还需要预测，个人认为同样还需要字典等数据，所以保存下来会好一些？ 3.2 tf.keras.layers.Embedding()的一些小说明这个是个嵌入层，用于将索引转换为向量。参数如下 input_dim: int &gt; 0。词汇表大小， 即，最大整数 index + 1。 output_dim: int &gt;= 0。词向量的维度。 embeddings_initializer: embeddings 矩阵的初始化方法 (详见 initializers)。 embeddings_regularizer: embeddings matrix 的正则化方法 (详见 regularizer)。 embeddings_constraint: embeddings matrix 的约束函数 (详见 constraints)。 mask_zero: 是否把 0 看作为一个应该被遮蔽的特殊的 “padding” 值。 这对于可变长的 循环神经网络层 十分有用。 如果设定为 True，那么接下来的所有层都必须支持 masking，否则就会抛出异常。 如果 mask_zero 为 True，作为结果，索引 0 就不能被用于词汇表中 （input_dim 应该与 vocabulary + 1 大小相同）。 input_length: 输入序列的长度，当它是固定的时。 如果你需要连接 Flatten 和 Dense 层，则这个参数是必须的 （没有它，dense 层的输出尺寸就无法计算）。其实还可以指定一个weights=，这个是指定自己训练的词向量用的。默认他会通过initializer随机初始化一个，当然这个initializer你也可以指定。 3.3 词向量通常我们想让字典尽可能贴近我们的需求，所以需要自己训练词向量，这个时候就需要Word2Vec了。 3.2.1 词向量训练前准备首先是导包！ import gensim.models.word2vec; 然后自然是准备词（了），我们可以直接利用上面分完词还未转化为索引的句子，当然有的这里会使用字，有的也会追加停用词。不论怎样，我们最后得到一个字符串组成的列表就可以了。 3.2.2 词向量训练vecModel = gensim.models.Word2Vec(); 这里参数很多，说几个这里一般简单用的： sentences : 可迭代的对象 size : 词向量的维数。 window : 句子中当前词和预测词之间的最大距离。window越大，则与中心词较远的词也会产生上下文关系。 min_count :最小词频，忽略所有总频率低于此频率的单词 差不多就这些，剩下可以看API。（英文注意！中文百度） 对于语料库很大的情况，训练词向量需要通过从磁盘加载sentences。循环训练。 3.2.3 加载现有词向量可以通过加载现有词向量来使用。这个方法各不相同，至少Word2vec训练出来可的一通过gensim.models.KeyedVectors.load()来加载，具体参数见API。（英文注意！中文百度） 加载完后需要依据你的字典把对应的词的向量添加进来。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"你说这知识咋就不进脑子呢","slug":"你说这知识咋就不进脑子呢","permalink":"/tags/你说这知识咋就不进脑子呢/"},{"name":"AI","slug":"AI","permalink":"/tags/AI/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"DirectX12 Study log (仮)","slug":"DirectX12.log","date":"2019-12-29T16:00:00.000Z","updated":"2020-03-25T08:08:36.973Z","comments":true,"path":"2019/12/30/DirectX12.log/","link":"","permalink":"/2019/12/30/DirectX12.log/","excerpt":"","text":"DirectX12 Study log (仮)主要内容基于《3D GAMEPROGRAMMING WITH DIRECTX 12》内容学习。原文使用面向对象编程，个人强行改为“面向过程”。而且还是非常SB的。垃圾一枚。主要记录书里大致有些什么东西，干了些什么。学习的时候没有记录会有些很多缺漏。 关于具体的实现的东西想在新开个地方慢慢解释。关于HLSL和Shader也会新开一个文章慢慢说。 数学基础说白了，看了也记不住，记住了也不懂，懂了也不会用。2333333 Direct3dD initialize Direct3D的初始化DirectX10（9？）之后的变化其实个人只知道DirectX7，就是那本“超经典”的《Windows游戏大师编程技巧》。这本书用的很老。里面最主要的Surface的概念似乎从DirectX11开始就没了（或是极少被提到）。10似乎是最后使用这个概念的。（可能也是9，我什么也不知道，23333），之前大多数的操作是针对Surface的，DrawLine、Bitmap等操作都是基于Surface的。之前似乎没有涉及到Shader。还有Factory，7似乎所有东西基本都从这里创建。 初始化内容顺序就按照书上的了,其实不是特别有必要.比如就可以先创建交换链在创建命令队列. Devices 设备这个不论那个版本都是需要先初始化的东西，目的在于选择当前机器上显示适配器（显卡？）。获取所支持的DirectX的版本并设置需要使用的版本。而且接下来所有与Direct3D直接相关的东西由Devices创建. Fance 围栏Fance主要作用是标记命令执行的位置,用于同步CPU和GPU.防止CPU速度太快而GPU没执行完命令就把命令队列给刷新了. MASS 多重采样其实不开也可以,就是画面不好看而已.想恶心人可以不开.当然书上开的是4x的,也可以开8x,前提你渲染的东西不多,并且显卡得撑得住啊. CommandQueue and CommandList 命令队列和命令列表命令队列用于向GPU提交要执行的命令,相当于Windows的消息队列.命令列表用于记录队列需要执行的命令,然后将列表提交到队列中.至于为什么不直接加入到队列里.实际答案我也不机密.我猜可能是因为我们的目标是呈现一张完整的Frame.GPU又是并行计算,提交成批操作一可以更好利用GPU效率,二不至于因为一些错误导致可以看见画面生成过程. 而创建CommandList还需要先创建CommandAllocator(命令分配器),负责记录命令并自动写到List中.具体原理我也不懂,反正到时候直接获取然后Execute就行了.233333 Swap Chain 交换链用于切换用户能看到的是哪一块缓冲块(之间叫Surface来着?).通常有两块后台缓冲区,一块给用户看,一块用来绘制下一帧.绘制好了就交换一下,让用户看到下一帧并重绘前一帧.两块缓冲话技术又叫双缓冲,三块就是三缓冲,似乎再多就没啥用了.目的是为了让用户就看到以绘制好的画面.而不知道画面是怎么生成的. DescriptorHeap And Descriptor 描述符堆和描述符描述符就是资源视图,由于Rendering Pipeline不能直接绑定资源,所以使用视图来获取资源情况.描述符堆用来保存他们. 描述符最重要的两个,RTV(Render Target View)和DTV(Depth Target Viet). RTV相当于用于渲染的画面,在Draw任何东西先都应先清空并设置,创建时为每个后台缓冲区创建一个RTV. DTV用于深度模板. 之后还有SRV(Shader Resource View),用于保存着色器使用的资源,如纹理,贴图.SRV似乎应该在加载贴图的时候再创建,最基本的初始化阶段不是必须的.CBV(Constant Buffer View)和UAV(Unordered Access View)bulabulabula 在所有描述符堆前应使用GetDescriptorHandleIncrementSize();获取描述符大小,在创建多个描述符时需要用offset();进行偏移. ViewPort 视口视口就是描述你窗口大小的东西,DirectX只能在Windows上运行,通常视口大小与Windows窗口大小一致,同时视口还可以设置深度,但通常最小为0.0f最大为1.0f. Scissor Rectangle 裁剪矩形裁剪矩形是将矩形外的像素全部剔除,通常和视口大小保持一致. 计时器不管咋样最好有一个,高性能计时器对控制帧率有很好的帮助. 书中给出的GameTimer利用了Windows自带的计时器函数QueryPerformanceCounter();返回一个int64的整数,配合QueryPerformanceFrequency();返回计时器的频率一个int64的整数. 通过调用两次QueryPerformanceCounter();做差再乘上QueryPerformanceFrequency();即可得到两次调用之间经过的时间. Rendering Pipeline 渲染流水线(渲染管线)Profile 概述graph TD A(Input Assembler Stage 输入装配阶段) --&gt; B(Vertex Shader Stage 顶点着色器阶段) --&gt; C(Hull Shader Stage 外壳着色器阶段)--&gt;D(Tessellator Stage 曲面细分阶段)--&gt;E(Domain shader Stage 域着色器阶段)--&gt;F(Geometry Shader Stage 几何着色器阶段)--&gt;G(Stream Output Stage 流输出阶段)--&gt;H(Rasterizer Stage 光栅化阶段)--&gt;I(Pixel Shader Stage 像素着色器阶段)--&gt;J(Output Merger Stage 合并输出阶段) Input Assembler Stage 输入装配阶段 (IA)简单来讲就是从显存中模型的顶点坐标和面索引.注意这里是显存,这就意味之我们在此之前就应该把数据从内存中拷贝到显存里来. 然后需要设置图元拓扑,就是指定顶点之间的结构,读文件的一般不需要注意索引的绕序,想obj和m3d都是可以直接用的. Vertex Shader 顶点着色器阶段(VS)涉及一大堆一大堆数学东西.简而言之就是把相对坐标变成绝对坐标,把局部空间坐标系上的点,表示成世界空间坐标系的点.然后归一化深度值. Hull Shader 外壳着色器阶段(HS) 不是H Sence！其实是曲面细分阶段的一部分,但实际上工作量差不多,我就拿HS说了 Hull Shader包括两种SHader: 1.Constant Hull Shader 常量外壳着色器 2.Control Hull Shader 控制外壳着色器 Constant Hull Shader 常量外壳着色器常量外壳着色器的任务是输出网格的曲面细分因子(tessellation factor).曲面细分因子指示了曲面细分阶段中将面片镶嵌处理后份数. 说白了就是增加定点数量.简单操作就是将直线等分 等分分为两部分，对于四边面，一个是对每条边的细分，另一个是对内部空间几行几列的细分，对于三边面，一个是对每条边的细分，另一个是对内部空间的细分，三边面只有一个内部空间细分参数，可以理解成n行n列的细分。（嗯，应该吧。） Control Hull Shader 控制外壳着色器控制外壳着色器以大量控制顶点作为输入与输出,每输出一个控制点就调用一次.应用之一是改变曲面的表示方式.比如三次贝塞尔曲线.可以带来更丰富的细节. 说白了HS就是可以把低模变成高模 镶嵌器阶段这个是硬件自动完成的，这个环节会根据常量外壳着色器输出的曲面细分因子对面片进行镶嵌画处理，当然四边面和三边面的处理方式是不同的。 Domain Shader域着色器镶嵌器阶段会输出新建的所有顶点与三角形，在此阶段创建的顶点会逐一调用域着色器.其本质就是“对已经经过镶嵌化的面片进行处理的顶点着色器”。对镶嵌花化后的点进行做坐标变换。 Geometry Shader 几何着色器(GS)记得某个群的入群问题就是GS在PS前还是VS后？（还是VS前PS后来着）。总之书上说的是：“再不启用曲面细分这一环节，GS这个可选阶段便会位于VS与PS之间”。 GS的输入必须是完整的图元，如构成一条线的两个顶点，构成三角形的三个顶点。书中提到的一个常见应用是将一点拓展成为一个四边形（俩三角形）。并以此介绍了公告牌技术，用来显示远处的一些小东西。 GS其实就是把顶点来回折腾的一个东西，并且还可以改变图元拓扑（其实我想说的是变成不同的图元），一些小的细节变化和粒子效果似乎可以用这个实现。 Pixel Shader像素着色器(PS)PS会对每一个像素采样点进行计算，根据顶点的插值属性作为输入来计算对应为的像素的颜色。PS可以返回单一恒定的颜色，也可是实现逐像素光照，反射，和阴影等其他效果。 Output Marger 合并输出简单来讲就是去掉不符合要求的像素，如没通过深度缓冲区测试或模板缓冲区测试的像素。剩下的就写入后台缓冲区中，“Blend 混合”也是在这个阶段实现的。 Shader 着色器的写法和一些东西会专门找地方说。 Lighting 光照这个，要在这里面说嘛？就是很多很多的数学和物理知识，在Shader里实现就好了。 Texture Mapping 纹理贴图纹理其实就是一种资源，D3D12中几乎所有资源统一用ID3D12Resource来管理。 纹理具有特定的数据格式，不支持除这些格式之外的格式，并且纹理可以具有多个层级的mipmap（给我感觉的意思当相当于人工智能里的池化操作，就是具有多个大小的同一图，但他们都还在同一个“图”里）。 有一种技术叫“渲染到纹理”，是指即将纹理作用于渲染目标，有能将纹理作为着色器的资源（在着色器里对纹理采样）使用。 DirectX中纹理用DDS(DirectDraw Suaface Format)格式的文件。PS需要装插件才能导出和编辑（忙活了我半天）。 Blend 混合做了个和啥呢，就是把已经光栅化的像素（目标像素）和现在要光栅化的像素（源像素）进行融合的操作。常见操作就是半透明物体的运用，配合纹理贴图会有很多意想不到的效果，有种用代码玩AE的感觉。 Stencli 模板在这里我纳闷过模板为啥子不是Template，一般见到模板都是Template。查字典哇Stencli也是模板的意思。但就是Stencli的模板指的是印刷文字或图案的那个模板。Template有模框，样板的意思。 所以顾名思义，这里的模板是指根据某种规则来写入像素的。书中给的应用就是镜子。当然是平面镜。阴影书中也用了模板缓冲来防止双重混合。 第一人称视角摄像机在书中15章之前的内容中，视角都是通过一个DirectX::XMFLOAT3类型的EyePos变量，传到着色器中gEyePos，通过取景变换转换坐标。 第一人称摄像机就是把这个东西封装成类，添加一些方便计算的属性和方法。同时可以不仅仅“旋转”改变坐标，还可以移动摄像机坐标。每次角度和位置不同更新内部向量，供着色器使用。 动态索引说白了就是让着色器用索引访问资源。据说配合实例化有意想不到的效果。动态索引可以让所有纹理资源一次绑定后，让着色器自己选择适合的纹理。索引要求使用系统ID。如SV_InstanceID、SV_VertexID。 实例化","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"DirectX","slug":"DirectX","permalink":"/tags/DirectX/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Hexo-Theme-Sakura","slug":"Hexo-Theme-Sakura","date":"2018-12-12T14:16:01.000Z","updated":"2020-02-18T00:38:20.675Z","comments":true,"path":"2018/12/12/Hexo-Theme-Sakura/","link":"","permalink":"/2018/12/12/Hexo-Theme-Sakura/","excerpt":"","text":"hexo-theme-sakura主题 English document 基于WordPress主题Sakura修改成Hexo的主题。 demo预览 正在开发中…… 交流群若你是使用者，加群QQ: 801511924 若你是创作者，加群QQ: 194472590 主题特性 首页大屏视频 首页随机封面 图片懒加载 valine评论 fancy-box相册 pjax支持，音乐不间断 aplayer音乐播放器 多级导航菜单（按现在大部分hexo主题来说，这也算是个特性了） 赞赏作者如果喜欢hexo-theme-sakura主题，可以考虑资助一下哦~非常感激！ paypal | Alipay 支付宝 | WeChat Pay 微信支付 未完善的使用教程那啥？老实说我目前也不是很有条理233333333~ 1、主题下载安装hexo-theme-sakura建议下载压缩包格式，因为除了主题内容还有些source的配置对新手来说比较太麻烦，直接下载解压就省去这些麻烦咯。 下载好后解压到博客根目录（不是主题目录哦，重复的选择替换）。接着在命令行（cmd、bash）运行npm i安装依赖。 2、主题配置博客根目录下的_config配置站点 # Site title: 你的站点名 subtitle: description: 站点简介 keywords: author: 作者名 language: zh-cn timezone: 部署 deploy: type: git repo: github: 你的github仓库地址 # coding: 你的coding仓库地址 branch: master 备份 （使用hexo b发布备份到远程仓库） backup: type: git message: backup my blog of https://honjun.github.io/ repository: # 你的github仓库地址,备份分支名 （建议新建backup分支） github: https://github.com/honjun/honjun.github.io.git,backup # coding: https://git.coding.net/hojun/hojun.git,backup 主题目录下的_config配置其中标明【改】的是需要修改部门，标明【选】是可改可不改，标明【非】是不用改的部分 # site name # 站点名 【改】 prefixName: さくら荘その siteName: hojun # favicon and site master avatar # 站点的favicon和头像 输入图片路径（下面的配置是都是cdn的相对路径，没有cdn请填写完整路径，建议使用jsdeliver搭建一个cdn啦，先去下载我的cdn替换下图片就行了，简单方便~）【改】 favicon: /images/favicon.ico avatar: /img/custom/avatar.jpg # 站点url 【改】 url: https://sakura.hojun.cn # 站点介绍（或者说是个人签名）【改】 description: Live your life with passion! With some drive! # 站点cdn，没有就为空 【改】 若是cdn为空，一些图片地址就要填完整地址了，比如之前avatar就要填https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/custom/avatar.jpg cdn: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6 # 开启pjax 【选】 pjax: 1 # 站点首页的公告信息 【改】 notice: hexo-Sakura主题已经开源，目前正在开发中... # 懒加载的加载中图片 【选】 lazyloadImg: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/loader/orange.progress-bar-stripe-loader.svg # 站点菜单配置 【选】 menus: 首页: { path: /, fa: fa-fort-awesome faa-shake } 归档: { path: /archives, fa: fa-archive faa-shake, submenus: { 技术: {path: /categories/技术/, fa: fa-code }, 生活: {path: /categories/生活/, fa: fa-file-text-o }, 资源: {path: /categories/资源/, fa: fa-cloud-download }, 随想: {path: /categories/随想/, fa: fa-commenting-o }, 转载: {path: /categories/转载/, fa: fa-book } } } 清单: { path: javascript:;, fa: fa-list-ul faa-vertical, submenus: { 书单: {path: /tags/悦读/, fa: fa-th-list faa-bounce }, 番组: {path: /bangumi/, fa: fa-film faa-vertical }, 歌单: {path: /music/, fa: fa-headphones }, 图集: {path: /tags/图集/, fa: fa-photo } } } 留言板: { path: /comment/, fa: fa-pencil-square-o faa-tada } 友人帐: { path: /links/, fa: fa-link faa-shake } 赞赏: { path: /donate/, fa: fa-heart faa-pulse } 关于: { path: /, fa: fa-leaf faa-wrench , submenus: { 我？: {path: /about/, fa: fa-meetup}, 主题: {path: /theme-sakura/, fa: iconfont icon-sakura }, Lab: {path: /lab/, fa: fa-cogs }, } } 客户端: { path: /client/, fa: fa-android faa-vertical } RSS: { path: /atom.xml, fa: fa-rss faa-pulse } # Home page sort type: -1: newer first，1: older first. 【非】 homePageSortType: -1 # Home page article shown number) 【非】 homeArticleShown: 10 # 背景图片 【选】 bgn: 8 # startdash面板 url, title, desc img 【改】 startdash: - {url: /theme-sakura/, title: Sakura, desc: 本站 hexo 主题, img: /img/startdash/sakura.md.png} - {url: http://space.bilibili.com/271849279, title: Bilibili, desc: 博主的b站视频, img: /img/startdash/bilibili.jpg} - {url: /, title: hojun的万事屋, desc: 技术服务, img: /img/startdash/wangshiwu.jpg} # your site build time or founded date # 你的站点建立日期 【改】 siteBuildingTime: 07/17/2018 # 社交按钮(social) url, img PC端配置 【改】 social: github: {url: http://github.com/honjun, img: /img/social/github.png} sina: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/sina.png} wangyiyun: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/wangyiyun.png} zhihu: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/zhihu.png} email: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/email.svg} wechat: {url: /#, qrcode: /img/custom/wechat.jpg, img: /img/social/wechat.png} # 社交按钮(msocial) url, img 移动端配置 【改】 msocial: github: {url: http://github.com/honjun, fa: fa-github, color: 333} weibo: {url: http://weibo.com/mashirozx?is_all=1, fa: fa-weibo, color: dd4b39} qq: {url: https://wpa.qq.com/msgrd?v=3&amp;uin=954655431&amp;site=qq&amp;menu=yes, fa: fa-qq, color: 25c6fe} # 赞赏二维码（其中wechatSQ是赞赏单页面的赞赏码图片）【改】 donate: alipay: /img/custom/donate/AliPayQR.jpg wechat: /img/custom/donate/WeChanQR.jpg wechatSQ: /img/custom/donate/WeChanSQ.jpg # 首页视频地址为https://cdn.jsdelivr.net/gh/honjun/hojun@1.2/Unbroken.mp4，配置如下 【改】 movies: url: https://cdn.jsdelivr.net/gh/honjun/hojun@1.2 # 多个视频用逗号隔开，随机获取。支持的格式目前已知MP4,Flv。其他的可以试下，不保证有用 name: Unbroken.mp4 # 左下角aplayer播放器配置 主要改id和server这两项，修改详见[aplayer文档] 【改】 aplayer: id: 2660651585 server: netease type: playlist fixed: true mini: false autoplay: false loop: all order: random preload: auto volume: 0.7 mutex: true # Valine评论配置【改】 valine: true v_appId: GyC3NzMvd0hT9Yyd2hYIC0MN-gzGzoHsz v_appKey: mgOpfzbkHYqU92CV4IDlAUHQ 分类页和标签页配置分类页 标签页 配置项在\\themes\\Sakura\\languages\\zh-cn.yml里。新增一个分类或标签最好加下哦，当然嫌麻烦可以直接使用一张默认图片（可以改主题或者直接把404图片替换下，征求下意见要不要给这个在配置文件中加个开关，可以issue或群里提出来），现在是没设置的话会使用那种倒立小狗404哦。 #category # 按分类名创建 技术: #中文标题 zh: 野生技术协会 # 英文标题 en: Geek – Only for Love # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/coding.jpg 生活: zh: 生活 en: live img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/writing.jpg #tag # 标签名即是标题 悦读: # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/reading.jpg 单页面封面配置如留言板页面页面，位于source下的comment下，打开index.md如下： --- title: comment date: 2018-12-20 23:13:48 keywords: 留言板 description: comments: true # 在这里配置单页面头部图片，自定义替换哦~ photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/comment.jpg --- 单页面配置番组计划页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: bangumi title: bangumi comments: false date: 2019-02-10 21:32:48 keywords: description: bangumis: # 番组图片 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg # 番组名 title: 朝花夕誓——于离别之朝束起约定之花 # 追番状态 （追番ing/已追完） status: 已追完 # 追番进度 progress: 100 # 番剧日文名称 jp: さよならの朝に約束の花をかざろう # 放送时间 time: 放送时间: 2018-02-24 SUN. # 番剧介绍 desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg title: 朝花夕誓——于离别之朝束起约定之花 status: 已追完 progress: 50 jp: さよならの朝に約束の花をかざろう time: 放送时间: 2018-02-24 SUN. desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 --- 友链页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: links title: links # 创建日期，可以改下 date: 2018-12-19 23:11:06 # 图片上的标题，自定义修改 keywords: 友人帐 description: # true/false 开启/关闭评论 comments: true # 页面头部图片，自定义修改 photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/links.jpg # 友链配置 links: # 类型分组 - group: 个人项目 # 类型简介 desc: 充分说明这家伙是条咸鱼 &lt; (￣︶￣)&gt; items: # 友链链接 - url: https://shino.cc/fgvf # 友链头像 img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg # 友链站点名 name: Google # 友链介绍 下面雷同 desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 # 类型分组... - group: 小伙伴们 desc: 欢迎交换友链 ꉂ(ˊᗜˋ) items: - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 --- 写文章配置主题集成了个人插件hexo-tag-bili和hexo-tag-fancybox_img。其中hexo-tag-bili用来在文章或单页面中插入B站外链视频，使用语法如下： {% bili video_id [page] %} 详细使用教程详见hexo-tag-bili。 hexo-tag-fancybox_img用来在文章或单页面中图片，使用语法如下： {% fb_img src [caption] %} 详细使用教程详见hexo-tag-fancybox_img 还有啥，一时想不起来……To be continued…","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"/tags/悦读/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]}]}